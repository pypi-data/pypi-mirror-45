"""
Helper functions to construct/handle supercells for mixing calculations.
"""

import copy
import numpy as np


class SupercellError(Exception):
    """Base class to handle errors associated with supercell generation."""
    pass


def get_supercell_for_mixing(structure, min_image_dist=12, verbosity=0):
    """Generates a supercell with a specified minimum image distance.

    Args:

        structure (:obj:`atoms.Structure`):
            Base structure with which to construct supercell.

        min_image_dist (float, optional):
            Minimum distance between periodic images in Angstrom.

            Defaults to 10 Angstrom.

        verbosity (int, optional):
            Standard output verbosity.

            Defaults to 0 (no standard output).

    Returns (:obj:`atoms.Structure`):
        Supercell with the specified minimum image distance.

    """
    try:
        supercell = supercell_from_ase(structure=structure,
                                       min_image_dist=min_image_dist,
                                       verbosity=verbosity)
    except SupercellError:
        supercell = supercell_by_translation(structure=structure,
                                             min_image_dist=min_image_dist,
                                             verbosity=verbosity)
    return supercell


def supercell_by_translation(structure, min_image_dist=12, verbosity=0):
    """Generates a supercell with a specified minimum image distance.

    A supercell of `structure` is generated by simply translating it in X,
    Y, Z directions such that the minimum distance between periodic images
    is larger than `min_image_dist`.

    Args:

        structure (:obj:`atoms.Structure`):
            Base structure with which to construct supercell.

        min_image_dist (float, optional):
            Minimum distance between periodic images in Angstrom.

            Defaults to 10 Angstrom.

        verbosity (int, optional):
            Standard output verbosity.

            Defaults to 0 (no standard output).

    Returns (:obj:`atoms.Structure`):
        Supercell with the specified minimum image distance.

    """
    supercell = copy.deepcopy(structure)

    # translate the structure in x, y, z directions depending on the minimum
    # image distance specified
    lat_vec_mags = [np.linalg.norm(lv) for lv in structure.cell]
    translation_factors = [int(np.ceil(min_image_dist/lvg)) for lvg in
                           lat_vec_mags]
    supercell.supa('{} {} {}'.format(*translation_factors))
    image_dist = calc_min_image_dist(supercell)

    if verbosity:
        print('Supercell dimensions: [{} {} {}]'.format(*translation_factors))
        print('Image separation = {:0.2f} Angstrom'.format(image_dist))

    return supercell


def get_natoms_bounds_for_ase_supercell(structure, min_image_dist=12):
    """Gets lower and upper bounds for the number of atoms in the supercell
    generated with `ase`.

    Args:

        structure (:obj:`atoms.Structure`):
            Base structure with which to construct supercell.

        min_image_dist (float, optional):
            Minimum distance between periodic images in Angstrom.

            Defaults to 10 Angstrom.

    Returns (tuple(int, int)):
        Lower and upper bounds for the number of atoms in the supercell.

    """
    ideal_sc_volume = min_image_dist**3
    uc_volume = structure.volume
    sc_uc_scale = int(ideal_sc_volume/uc_volume)
    low = (sc_uc_scale - 1)*structure.totalnatoms
    high = min(512, 8*sc_uc_scale*structure.totalnatoms)
    return low, high


def calc_min_image_dist(structure):
    """Calculates the minimum distance between periodic images of structure.

    Args:

        structure (:obj:`atoms.Structure`):
            Base structure with which to construct supercell.

    Returns (float):
        Minimum distance between periodic images in Angstrom.

    """
    translations = [
        [0, 0, 1],
        [0, 1, 0],
        [1, 0, 0],
        [0, 1, 1],
        [1, 0, 1],
        [1, 1, 0],
        [1, 1, 1]
    ]
    image_distances = []
    for t in translations:
        image_distance = np.linalg.norm(t[0]*structure.a1
                                        + t[1]*structure.a2
                                        + t[2]*structure.a3)
        image_distances.append(image_distance)
    return min(image_distances)


def supercell_from_ase(structure, min_image_dist=12, verbosity=0):
    """Generates a cubic-like supercell with a specified minimum image
    distance using the `ase` package.

    Args:

        structure (:obj:`atoms.Structure`):
            Base structure with which to construct supercell.

        min_image_dist (float, optional):
            Minimum distance between periodic images in Angstrom.

            Defaults to 10 Angstrom.

        verbosity (int, optional):
            Standard output verbosity.

            Defaults to 0 (no standard output).

    Returns (:obj:`atoms.Structure`):
        Supercell with the specified minimum image distance.

    Raises:
        :exc:`SupercellError` if unable to generate a suitable supercell.

    """

    low, high = get_natoms_bounds_for_ase_supercell(
            structure=structure,
            min_image_dist=min_image_dist
    )

    found_sc = False
    for natoms in range(low, high, structure.totalnatoms):
        supercell = copy.deepcopy(structure)
        supercell.ase_supa(natoms)
        image_dist = calc_min_image_dist(supercell)
        if image_dist >= min_image_dist:
            found_sc = True
            break

    if not found_sc:
        error_msg = 'Unable to find suitable supercell via `ase`'
        raise SupercellError(error_msg)

    if verbosity:
        print('Successfully generated sc-like supercell using `ase`.')
        print('  Defect separation = {:0.2f} Angstrom'.format(image_dist))
        print('  Number of atoms in supercell = {}'.format(natoms))

    return supercell
