window["dash_large_upload"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/resumablejs/resumable.js":
/*!***********************************************!*\
  !*** ./node_modules/resumablejs/resumable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n* MIT Licensed\n* http://www.23developer.com/opensource\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@23company.com\n*/\n\n(function(){\n\"use strict\";\n\n  var Resumable = function(opts){\n    if ( !(this instanceof Resumable) ) {\n      return new Resumable(opts);\n    }\n    this.version = 1.0;\n    // SUPPORTED BY BROWSER?\n    // Check if these features are support by the browser:\n    // - File object type\n    // - Blob object type\n    // - FileList object type\n    // - slicing files\n    this.support = (\n                   (typeof(File)!=='undefined')\n                   &&\n                   (typeof(Blob)!=='undefined')\n                   &&\n                   (typeof(FileList)!=='undefined')\n                   &&\n                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)\n                   );\n    if(!this.support) return(false);\n\n\n    // PROPERTIES\n    var $ = this;\n    $.files = [];\n    $.defaults = {\n      chunkSize:1*1024*1024,\n      forceChunkSize:false,\n      simultaneousUploads:3,\n      fileParameterName:'file',\n      chunkNumberParameterName: 'resumableChunkNumber',\n      chunkSizeParameterName: 'resumableChunkSize',\n      currentChunkSizeParameterName: 'resumableCurrentChunkSize',\n      totalSizeParameterName: 'resumableTotalSize',\n      typeParameterName: 'resumableType',\n      identifierParameterName: 'resumableIdentifier',\n      fileNameParameterName: 'resumableFilename',\n      relativePathParameterName: 'resumableRelativePath',\n      totalChunksParameterName: 'resumableTotalChunks',\n      throttleProgressCallbacks: 0.5,\n      query:{},\n      headers:{},\n      preprocess:null,\n      method:'multipart',\n      uploadMethod: 'POST',\n      testMethod: 'GET',\n      prioritizeFirstAndLastChunk:false,\n      target:'/',\n      testTarget: null,\n      parameterNamespace:'',\n      testChunks:true,\n      generateUniqueIdentifier:null,\n      getTarget:null,\n      maxChunkRetries:100,\n      chunkRetryInterval:undefined,\n      permanentErrors:[400, 404, 415, 500, 501],\n      maxFiles:undefined,\n      withCredentials:false,\n      xhrTimeout:0,\n      clearInput:true,\n      chunkFormat:'blob',\n      setChunkTypeFromFile:false,\n      maxFilesErrorCallback:function (files, errorCount) {\n        var maxFiles = $.getOpt('maxFiles');\n        alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n      },\n      minFileSize:1,\n      minFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');\n      },\n      maxFileSize:undefined,\n      maxFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');\n      },\n      fileType: [],\n      fileTypeErrorCallback: function(file, errorCount) {\n        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');\n      }\n    };\n    $.opts = opts||{};\n    $.getOpt = function(o) {\n      var $opt = this;\n      // Get multiple option if passed an array\n      if(o instanceof Array) {\n        var options = {};\n        $h.each(o, function(option){\n          options[option] = $opt.getOpt(option);\n        });\n        return options;\n      }\n      // Otherwise, just return a simple option\n      if ($opt instanceof ResumableChunk) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.fileObj; }\n      }\n      if ($opt instanceof ResumableFile) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.resumableObj; }\n      }\n      if ($opt instanceof Resumable) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { return $opt.defaults[o]; }\n      }\n    };\n\n    // EVENTS\n    // catchAll(event, ...)\n    // fileSuccess(file), fileProgress(file), fileAdded(file, event), filesAdded(files, filesSkipped), fileRetry(file),\n    // fileError(file, message), complete(), progress(), error(message, file), pause()\n    $.events = [];\n    $.on = function(event,callback){\n      $.events.push(event.toLowerCase(), callback);\n    };\n    $.fire = function(){\n      // `arguments` is an object, not array, in FF, so:\n      var args = [];\n      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);\n      // Find event listeners, and support pseudo-event `catchAll`\n      var event = args[0].toLowerCase();\n      for (var i=0; i<=$.events.length; i+=2) {\n        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));\n        if($.events[i]=='catchall') $.events[i+1].apply(null,args);\n      }\n      if(event=='fileerror') $.fire('error', args[2], args[1]);\n      if(event=='fileprogress') $.fire('progress');\n    };\n\n\n    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\n    var $h = {\n      stopEvent: function(e){\n        e.stopPropagation();\n        e.preventDefault();\n      },\n      each: function(o,callback){\n        if(typeof(o.length)!=='undefined') {\n          for (var i=0; i<o.length; i++) {\n            // Array or FileList\n            if(callback(o[i])===false) return;\n          }\n        } else {\n          for (i in o) {\n            // Object\n            if(callback(i,o[i])===false) return;\n          }\n        }\n      },\n      generateUniqueIdentifier:function(file, event){\n        var custom = $.getOpt('generateUniqueIdentifier');\n        if(typeof custom === 'function') {\n          return custom(file, event);\n        }\n        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox\n        var size = file.size;\n        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n      },\n      contains:function(array,test) {\n        var result = false;\n\n        $h.each(array, function(value) {\n          if (value == test) {\n            result = true;\n            return false;\n          }\n          return true;\n        });\n\n        return result;\n      },\n      formatSize:function(size){\n        if(size<1024) {\n          return size + ' bytes';\n        } else if(size<1024*1024) {\n          return (size/1024.0).toFixed(0) + ' KB';\n        } else if(size<1024*1024*1024) {\n          return (size/1024.0/1024.0).toFixed(1) + ' MB';\n        } else {\n          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';\n        }\n      },\n      getTarget:function(request, params){\n        var target = $.getOpt('target');\n\n        if (request === 'test' && $.getOpt('testTarget')) {\n          target = $.getOpt('testTarget') === '/' ? $.getOpt('target') : $.getOpt('testTarget');\n        }\n\n        if (typeof target === 'function') {\n          return target(params);\n        }\n\n        var separator = target.indexOf('?') < 0 ? '?' : '&';\n        var joinedParams = params.join('&');\n\n        return target + separator + joinedParams;\n      }\n    };\n\n    var onDrop = function(event){\n      $h.stopEvent(event);\n\n      //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n      if (event.dataTransfer && event.dataTransfer.items) {\n        loadFiles(event.dataTransfer.items, event);\n      }\n      //else handle them as files\n      else if (event.dataTransfer && event.dataTransfer.files) {\n        loadFiles(event.dataTransfer.files, event);\n      }\n    };\n    var preventDefault = function(e) {\n      e.preventDefault();\n    };\n\n    /**\n     * processes a single upload item (file or directory)\n     * @param {Object} item item to upload, may be file or directory entry\n     * @param {string} path current file path\n     * @param {File[]} items list of files to append new items to\n     * @param {Function} cb callback invoked when item is processed\n     */\n    function processItem(item, path, items, cb) {\n      var entry;\n      if(item.isFile){\n        // file provided\n        return item.file(function(file){\n          file.relativePath = path + file.name;\n          items.push(file);\n          cb();\n        });\n      }else if(item.isDirectory){\n        // item is already a directory entry, just assign\n        entry = item;\n      }else if(item instanceof File) {\n        items.push(item);\n      }\n      if('function' === typeof item.webkitGetAsEntry){\n        // get entry from file object\n        entry = item.webkitGetAsEntry();\n      }\n      if(entry && entry.isDirectory){\n        // directory provided, process it\n        return processDirectory(entry, path + entry.name + '/', items, cb);\n      }\n      if('function' === typeof item.getAsFile){\n        // item represents a File object, convert it\n        item = item.getAsFile();\n        if(item instanceof File) {\n          item.relativePath = path + item.name;\n          items.push(item);\n        }\n      }\n      cb(); // indicate processing is done\n    }\n\n\n    /**\n     * cps-style list iteration.\n     * invokes all functions in list and waits for their callback to be\n     * triggered.\n     * @param  {Function[]}   items list of functions expecting callback parameter\n     * @param  {Function} cb    callback to trigger after the last callback has been invoked\n     */\n    function processCallbacks(items, cb){\n      if(!items || items.length === 0){\n        // empty or no list, invoke callback\n        return cb();\n      }\n      // invoke current function, pass the next part as continuation\n      items[0](function(){\n        processCallbacks(items.slice(1), cb);\n      });\n    }\n\n    /**\n     * recursively traverse directory and collect files to upload\n     * @param  {Object}   directory directory to process\n     * @param  {string}   path      current path\n     * @param  {File[]}   items     target list of items\n     * @param  {Function} cb        callback invoked after traversing directory\n     */\n    function processDirectory (directory, path, items, cb) {\n      var dirReader = directory.createReader();\n      dirReader.readEntries(function(entries){\n        if(!entries.length){\n          // empty directory, skip\n          return cb();\n        }\n        // process all conversion callbacks, finally invoke own one\n        processCallbacks(\n          entries.map(function(entry){\n            // bind all properties except for callback\n            return processItem.bind(null, entry, path, items);\n          }),\n          cb\n        );\n      });\n    }\n\n    /**\n     * process items to extract files to be uploaded\n     * @param  {File[]} items items to process\n     * @param  {Event} event event that led to upload\n     */\n    function loadFiles(items, event) {\n      if(!items.length){\n        return; // nothing to do\n      }\n      $.fire('beforeAdd');\n      var files = [];\n      processCallbacks(\n          Array.prototype.map.call(items, function(item){\n            // bind all properties except for callback\n            return processItem.bind(null, item, \"\", files);\n          }),\n          function(){\n            if(files.length){\n              // at least one file found\n              appendFilesFromFileList(files, event);\n            }\n          }\n      );\n    };\n\n    var appendFilesFromFileList = function(fileList, event){\n      // check for uploading too many files\n      var errorCount = 0;\n      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);\n      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {\n        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {\n          $.removeFile($.files[0]);\n        } else {\n          o.maxFilesErrorCallback(fileList, errorCount++);\n          return false;\n        }\n      }\n      var files = [], filesSkipped = [], remaining = fileList.length;\n      var decreaseReamining = function(){\n        if(!--remaining){\n          // all files processed, trigger event\n          if(!files.length && !filesSkipped.length){\n            // no succeeded files, just skip\n            return;\n          }\n          window.setTimeout(function(){\n            $.fire('filesAdded', files, filesSkipped);\n          },0);\n        }\n      };\n      $h.each(fileList, function(file){\n        var fileName = file.name;\n        if(o.fileType.length > 0){\n          var fileTypeFound = false;\n          for(var index in o.fileType){\n            var extension = '.' + o.fileType[index];\n\t\t\tif(fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1){\n              fileTypeFound = true;\n              break;\n            }\n          }\n          if (!fileTypeFound) {\n            o.fileTypeErrorCallback(file, errorCount++);\n            return false;\n          }\n        }\n\n        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {\n          o.minFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {\n          o.maxFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        function addFile(uniqueIdentifier){\n          if (!$.getFromUniqueIdentifier(uniqueIdentifier)) {(function(){\n            file.uniqueIdentifier = uniqueIdentifier;\n            var f = new ResumableFile($, file, uniqueIdentifier);\n            $.files.push(f);\n            files.push(f);\n            f.container = (typeof event != 'undefined' ? event.srcElement : null);\n            window.setTimeout(function(){\n              $.fire('fileAdded', f, event)\n            },0);\n          })()} else {\n            filesSkipped.push(file);\n          };\n          decreaseReamining();\n        }\n        // directories have size == 0\n        var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);\n        if(uniqueIdentifier && typeof uniqueIdentifier.then === 'function'){\n          // Promise or Promise-like object provided as unique identifier\n          uniqueIdentifier\n          .then(\n            function(uniqueIdentifier){\n              // unique identifier generation succeeded\n              addFile(uniqueIdentifier);\n            },\n           function(){\n              // unique identifier generation failed\n              // skip further processing, only decrease file count\n              decreaseReamining();\n            }\n          );\n        }else{\n          // non-Promise provided as unique identifier, process synchronously\n          addFile(uniqueIdentifier);\n        }\n      });\n    };\n\n    // INTERNAL OBJECT TYPES\n    function ResumableFile(resumableObj, file, uniqueIdentifier){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $._prevProgress = 0;\n      $.resumableObj = resumableObj;\n      $.file = file;\n      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox\n      $.size = file.size;\n      $.relativePath = file.relativePath || file.webkitRelativePath || $.fileName;\n      $.uniqueIdentifier = uniqueIdentifier;\n      $._pause = false;\n      $.container = '';\n      var _error = uniqueIdentifier !== undefined;\n\n      // Callback when something happens within the chunk\n      var chunkEvent = function(event, message){\n        // event can be 'progress', 'success', 'error' or 'retry'\n        switch(event){\n        case 'progress':\n          $.resumableObj.fire('fileProgress', $, message);\n          break;\n        case 'error':\n          $.abort();\n          _error = true;\n          $.chunks = [];\n          $.resumableObj.fire('fileError', $, message);\n          break;\n        case 'success':\n          if(_error) return;\n          $.resumableObj.fire('fileProgress', $); // it's at least progress\n          if($.isComplete()) {\n            $.resumableObj.fire('fileSuccess', $, message);\n          }\n          break;\n        case 'retry':\n          $.resumableObj.fire('fileRetry', $);\n          break;\n        }\n      };\n\n      // Main code to set up a file object with chunks,\n      // packaged to be able to handle retries if needed.\n      $.chunks = [];\n      $.abort = function(){\n        // Stop current uploads\n        var abortCount = 0;\n        $h.each($.chunks, function(c){\n          if(c.status()=='uploading') {\n            c.abort();\n            abortCount++;\n          }\n        });\n        if(abortCount>0) $.resumableObj.fire('fileProgress', $);\n      };\n      $.cancel = function(){\n        // Reset this file to be void\n        var _chunks = $.chunks;\n        $.chunks = [];\n        // Stop current uploads\n        $h.each(_chunks, function(c){\n          if(c.status()=='uploading')  {\n            c.abort();\n            $.resumableObj.uploadNextChunk();\n          }\n        });\n        $.resumableObj.removeFile($);\n        $.resumableObj.fire('fileProgress', $);\n      };\n      $.retry = function(){\n        $.bootstrap();\n        var firedRetry = false;\n        $.resumableObj.on('chunkingComplete', function(){\n          if(!firedRetry) $.resumableObj.upload();\n          firedRetry = true;\n        });\n      };\n      $.bootstrap = function(){\n        $.abort();\n        _error = false;\n        // Rebuild stack of chunks from file\n        $.chunks = [];\n        $._prevProgress = 0;\n        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;\n        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);\n        for (var offset=0; offset<maxOffset; offset++) {(function(offset){\n            window.setTimeout(function(){\n                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));\n                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);\n            },0);\n        })(offset)}\n        window.setTimeout(function(){\n            $.resumableObj.fire('chunkingComplete',$);\n        },0);\n      };\n      $.progress = function(){\n        if(_error) return(1);\n        // Sum up progress across everything\n        var ret = 0;\n        var error = false;\n        $h.each($.chunks, function(c){\n          if(c.status()=='error') error = true;\n          ret += c.progress(true); // get chunk progress relative to entire file\n        });\n        ret = (error ? 1 : (ret>0.99999 ? 1 : ret));\n        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n        $._prevProgress = ret;\n        return(ret);\n      };\n      $.isUploading = function(){\n        var uploading = false;\n        $h.each($.chunks, function(chunk){\n          if(chunk.status()=='uploading') {\n            uploading = true;\n            return(false);\n          }\n        });\n        return(uploading);\n      };\n      $.isComplete = function(){\n        var outstanding = false;\n        $h.each($.chunks, function(chunk){\n          var status = chunk.status();\n          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {\n            outstanding = true;\n            return(false);\n          }\n        });\n        return(!outstanding);\n      };\n      $.pause = function(pause){\n          if(typeof(pause)==='undefined'){\n              $._pause = ($._pause ? false : true);\n          }else{\n              $._pause = pause;\n          }\n      };\n      $.isPaused = function() {\n        return $._pause;\n      };\n\n\n      // Bootstrap and return\n      $.resumableObj.fire('chunkingStart', $);\n      $.bootstrap();\n      return(this);\n    }\n\n\n    function ResumableChunk(resumableObj, fileObj, offset, callback){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $.resumableObj = resumableObj;\n      $.fileObj = fileObj;\n      $.fileObjSize = fileObj.size;\n      $.fileObjType = fileObj.file.type;\n      $.offset = offset;\n      $.callback = callback;\n      $.lastProgressCallback = (new Date);\n      $.tested = false;\n      $.retries = 0;\n      $.pendingRetry = false;\n      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished\n\n      // Computed properties\n      var chunkSize = $.getOpt('chunkSize');\n      $.loaded = 0;\n      $.startByte = $.offset*chunkSize;\n      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);\n      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {\n        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n        $.endByte = $.fileObjSize;\n      }\n      $.xhr = null;\n\n      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n      $.test = function(){\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        var testHandler = function(e){\n          $.tested = true;\n          var status = $.status();\n          if(status=='success') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.send();\n          }\n        };\n        $.xhr.addEventListener('load', testHandler, false);\n        $.xhr.addEventListener('error', testHandler, false);\n        $.xhr.addEventListener('timeout', testHandler, false);\n\n        // Add data from the query options\n        var params = [];\n        var parameterNamespace = $.getOpt('parameterNamespace');\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));\n        });\n        // Add extra data to identify chunk\n        params = params.concat(\n          [\n            // define key/value pairs for additional parameters\n            ['chunkNumberParameterName', $.offset + 1],\n            ['chunkSizeParameterName', $.getOpt('chunkSize')],\n            ['currentChunkSizeParameterName', $.endByte - $.startByte],\n            ['totalSizeParameterName', $.fileObjSize],\n            ['typeParameterName', $.fileObjType],\n            ['identifierParameterName', $.fileObj.uniqueIdentifier],\n            ['fileNameParameterName', $.fileObj.fileName],\n            ['relativePathParameterName', $.fileObj.relativePath],\n            ['totalChunksParameterName', $.fileObj.chunks.length]\n          ].filter(function(pair){\n            // include items that resolve to truthy values\n            // i.e. exclude false, null, undefined and empty strings\n            return $.getOpt(pair[0]);\n          })\n          .map(function(pair){\n            // map each key/value pair to its final form\n            return [\n              parameterNamespace + $.getOpt(pair[0]),\n              encodeURIComponent(pair[1])\n            ].join('=');\n          })\n        );\n        // Append the relevant chunk and send it\n        $.xhr.open($.getOpt('testMethod'), $h.getTarget('test', params));\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(null);\n      };\n\n      $.preprocessFinished = function(){\n        $.preprocessState = 2;\n        $.send();\n      };\n\n      // send() uploads the actual data in a POST call\n      $.send = function(){\n        var preprocess = $.getOpt('preprocess');\n        if(typeof preprocess === 'function') {\n          switch($.preprocessState) {\n          case 0: $.preprocessState = 1; preprocess($); return;\n          case 1: return;\n          case 2: break;\n          }\n        }\n        if($.getOpt('testChunks') && !$.tested) {\n          $.test();\n          return;\n        }\n\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        // Progress\n        $.xhr.upload.addEventListener('progress', function(e){\n          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {\n            $.callback('progress');\n            $.lastProgressCallback = (new Date);\n          }\n          $.loaded=e.loaded||0;\n        }, false);\n        $.loaded = 0;\n        $.pendingRetry = false;\n        $.callback('progress');\n\n        // Done (either done, failed or retry)\n        var doneHandler = function(e){\n          var status = $.status();\n          if(status=='success'||status=='error') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.callback('retry', $.message());\n            $.abort();\n            $.retries++;\n            var retryInterval = $.getOpt('chunkRetryInterval');\n            if(retryInterval !== undefined) {\n              $.pendingRetry = true;\n              setTimeout($.send, retryInterval);\n            } else {\n              $.send();\n            }\n          }\n        };\n        $.xhr.addEventListener('load', doneHandler, false);\n        $.xhr.addEventListener('error', doneHandler, false);\n        $.xhr.addEventListener('timeout', doneHandler, false);\n\n        // Set up the basic query data from Resumable\n        var query = [\n          ['chunkNumberParameterName', $.offset + 1],\n          ['chunkSizeParameterName', $.getOpt('chunkSize')],\n          ['currentChunkSizeParameterName', $.endByte - $.startByte],\n          ['totalSizeParameterName', $.fileObjSize],\n          ['typeParameterName', $.fileObjType],\n          ['identifierParameterName', $.fileObj.uniqueIdentifier],\n          ['fileNameParameterName', $.fileObj.fileName],\n          ['relativePathParameterName', $.fileObj.relativePath],\n          ['totalChunksParameterName', $.fileObj.chunks.length],\n        ].filter(function(pair){\n          // include items that resolve to truthy values\n          // i.e. exclude false, null, undefined and empty strings\n          return $.getOpt(pair[0]);\n        })\n        .reduce(function(query, pair){\n          // assign query key/value\n          query[$.getOpt(pair[0])] = pair[1];\n          return query;\n        }, {});\n        // Mix in custom data\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          query[k] = v;\n        });\n\n        var func = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice')));\n        var bytes = $.fileObj.file[func]($.startByte, $.endByte, $.getOpt('setChunkTypeFromFile') ? $.fileObj.file.type : \"\");\n        var data = null;\n        var params = [];\n\n        var parameterNamespace = $.getOpt('parameterNamespace');\n                if ($.getOpt('method') === 'octet') {\n                    // Add data from the query options\n                    data = bytes;\n                    $h.each(query, function (k, v) {\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                } else {\n                    // Add data from the query options\n                    data = new FormData();\n                    $h.each(query, function (k, v) {\n                        data.append(parameterNamespace + k, v);\n                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));\n                    });\n                    if ($.getOpt('chunkFormat') == 'blob') {\n                        data.append(parameterNamespace + $.getOpt('fileParameterName'), bytes, $.fileObj.fileName);\n                    }\n                    else if ($.getOpt('chunkFormat') == 'base64') {\n                        var fr = new FileReader();\n                        fr.onload = function (e) {\n                            data.append(parameterNamespace + $.getOpt('fileParameterName'), fr.result);\n                            $.xhr.send(data);\n                        }\n                        fr.readAsDataURL(bytes);\n                    }\n                }\n\n        var target = $h.getTarget('upload', params);\n        var method = $.getOpt('uploadMethod');\n\n        $.xhr.open(method, target);\n        if ($.getOpt('method') === 'octet') {\n          $.xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n        }\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        var customHeaders = $.getOpt('headers');\n        if(typeof customHeaders === 'function') {\n          customHeaders = customHeaders($.fileObj, $);\n        }\n\n        $h.each(customHeaders, function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n\n                if ($.getOpt('chunkFormat') == 'blob') {\n                    $.xhr.send(data);\n                }\n      };\n      $.abort = function(){\n        // Abort and reset\n        if($.xhr) $.xhr.abort();\n        $.xhr = null;\n      };\n      $.status = function(){\n        // Returns: 'pending', 'uploading', 'success', 'error'\n        if($.pendingRetry) {\n          // if pending retry then that's effectively the same as actively uploading,\n          // there might just be a slight delay before the retry starts\n          return('uploading');\n        } else if(!$.xhr) {\n          return('pending');\n        } else if($.xhr.readyState<4) {\n          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n          return('uploading');\n        } else {\n          if($.xhr.status == 200 || $.xhr.status == 201) {\n            // HTTP 200, 201 (created)\n            return('success');\n          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {\n            // HTTP 415/500/501, permanent error\n            return('error');\n          } else {\n            // this should never happen, but we'll reset and queue a retry\n            // a likely case for this would be 503 service unavailable\n            $.abort();\n            return('pending');\n          }\n        }\n      };\n      $.message = function(){\n        return($.xhr ? $.xhr.responseText : '');\n      };\n      $.progress = function(relative){\n        if(typeof(relative)==='undefined') relative = false;\n        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);\n        if($.pendingRetry) return(0);\n        if(!$.xhr || !$.xhr.status) factor*=.95;\n        var s = $.status();\n        switch(s){\n        case 'success':\n        case 'error':\n          return(1*factor);\n        case 'pending':\n          return(0*factor);\n        default:\n          return($.loaded/($.endByte-$.startByte)*factor);\n        }\n      };\n      return(this);\n    }\n\n    // QUEUE\n    $.uploadNextChunk = function(){\n      var found = false;\n\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      if ($.getOpt('prioritizeFirstAndLastChunk')) {\n        $h.each($.files, function(file){\n          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {\n            file.chunks[0].send();\n            found = true;\n            return(false);\n          }\n          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {\n            file.chunks[file.chunks.length-1].send();\n            found = true;\n            return(false);\n          }\n        });\n        if(found) return(true);\n      }\n\n      // Now, simply look for the next, best thing to upload\n      $h.each($.files, function(file){\n        if(file.isPaused()===false){\n         $h.each(file.chunks, function(chunk){\n           if(chunk.status()=='pending' && chunk.preprocessState === 0) {\n             chunk.send();\n             found = true;\n             return(false);\n           }\n          });\n        }\n        if(found) return(false);\n      });\n      if(found) return(true);\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      $h.each($.files, function(file){\n        if(!file.isComplete()) {\n          outstanding = true;\n          return(false);\n        }\n      });\n      if(!outstanding) {\n        // All chunks have been uploaded, complete\n        $.fire('complete');\n      }\n      return(false);\n    };\n\n\n    // PUBLIC METHODS FOR RESUMABLE.JS\n    $.assignBrowse = function(domNodes, isDirectory){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        var input;\n        if(domNode.tagName==='INPUT' && domNode.type==='file'){\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          input.style.display = 'none';\n          domNode.addEventListener('click', function(){\n            input.style.opacity = 0;\n            input.style.display='block';\n            input.focus();\n            input.click();\n            input.style.display='none';\n          }, false);\n          domNode.appendChild(input);\n        }\n        var maxFiles = $.getOpt('maxFiles');\n        if (typeof(maxFiles)==='undefined'||maxFiles!=1){\n          input.setAttribute('multiple', 'multiple');\n        } else {\n          input.removeAttribute('multiple');\n        }\n        if(isDirectory){\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        } else {\n          input.removeAttribute('webkitdirectory');\n        }\n        var fileTypes = $.getOpt('fileType');\n        if (typeof (fileTypes) !== 'undefined' && fileTypes.length >= 1) {\n          input.setAttribute('accept', fileTypes.map(function (e) { return '.' + e }).join(','));\n        }\n        else {\n          input.removeAttribute('accept');\n        }\n        // When new files are added, simply append them to the overall list\n        input.addEventListener('change', function(e){\n          appendFilesFromFileList(e.target.files,e);\n          var clearInput = $.getOpt('clearInput');\n          if (clearInput) {\n            e.target.value = '';\n          }\n        }, false);\n      });\n    };\n    $.assignDrop = function(domNodes){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.addEventListener('dragover', preventDefault, false);\n        domNode.addEventListener('dragenter', preventDefault, false);\n        domNode.addEventListener('drop', onDrop, false);\n      });\n    };\n    $.unAssignDrop = function(domNodes) {\n      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.removeEventListener('dragover', preventDefault);\n        domNode.removeEventListener('dragenter', preventDefault);\n        domNode.removeEventListener('drop', onDrop);\n      });\n    };\n    $.isUploading = function(){\n      var uploading = false;\n      $h.each($.files, function(file){\n        if (file.isUploading()) {\n          uploading = true;\n          return(false);\n        }\n      });\n      return(uploading);\n    };\n    $.upload = function(){\n      // Make sure we don't start too many uploads at once\n      if($.isUploading()) return;\n      // Kick off the queue\n      $.fire('uploadStart');\n      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {\n        $.uploadNextChunk();\n      }\n    };\n    $.pause = function(){\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        file.abort();\n      });\n      $.fire('pause');\n    };\n    $.cancel = function(){\n      $.fire('beforeCancel');\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        $.files[i].cancel();\n      }\n      $.fire('cancel');\n    };\n    $.progress = function(){\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        totalDone += file.progress()*file.size;\n        totalSize += file.size;\n      });\n      return(totalSize>0 ? totalDone/totalSize : 0);\n    };\n    $.addFile = function(file, event){\n      appendFilesFromFileList([file], event);\n    };\n    $.addFiles = function(files, event){\n      appendFilesFromFileList(files, event);\n    };\n    $.removeFile = function(file){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        if($.files[i] === file) {\n          $.files.splice(i, 1);\n        }\n      }\n    };\n    $.getFromUniqueIdentifier = function(uniqueIdentifier){\n      var ret = false;\n      $h.each($.files, function(f){\n        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;\n      });\n      return(ret);\n    };\n    $.getSize = function(){\n      var totalSize = 0;\n      $h.each($.files, function(file){\n        totalSize += file.size;\n      });\n      return(totalSize);\n    };\n    $.handleDropEvent = function (e) {\n      onDrop(e);\n    };\n    $.handleChangeEvent = function (e) {\n      appendFilesFromFileList(e.target.files, e);\n      e.target.value = '';\n    };\n    $.updateQuery = function(query){\n        $.opts.query = query;\n    };\n\n    return(this);\n  };\n\n\n  // Node.js-style export for Node and Component\n  if (true) {\n    module.exports = Resumable;\n  } else {}\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZC8uL25vZGVfbW9kdWxlcy9yZXN1bWFibGVqcy9yZXN1bWFibGUuanM/ZjA1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQixZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUE0QjtBQUNsQztBQUNBLEdBQUcsTUFBTSxFQVFOOztBQUVILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVzdW1hYmxlanMvcmVzdW1hYmxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogTUlUIExpY2Vuc2VkXG4qIGh0dHA6Ly93d3cuMjNkZXZlbG9wZXIuY29tL29wZW5zb3VyY2VcbiogaHR0cDovL2dpdGh1Yi5jb20vMjMvcmVzdW1hYmxlLmpzXG4qIFN0ZWZmZW4gVGllZGVtYW5uIENocmlzdGVuc2VuLCBzdGVmZmVuQDIzY29tcGFueS5jb21cbiovXG5cbihmdW5jdGlvbigpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIFJlc3VtYWJsZSA9IGZ1bmN0aW9uKG9wdHMpe1xuICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgUmVzdW1hYmxlKSApIHtcbiAgICAgIHJldHVybiBuZXcgUmVzdW1hYmxlKG9wdHMpO1xuICAgIH1cbiAgICB0aGlzLnZlcnNpb24gPSAxLjA7XG4gICAgLy8gU1VQUE9SVEVEIEJZIEJST1dTRVI/XG4gICAgLy8gQ2hlY2sgaWYgdGhlc2UgZmVhdHVyZXMgYXJlIHN1cHBvcnQgYnkgdGhlIGJyb3dzZXI6XG4gICAgLy8gLSBGaWxlIG9iamVjdCB0eXBlXG4gICAgLy8gLSBCbG9iIG9iamVjdCB0eXBlXG4gICAgLy8gLSBGaWxlTGlzdCBvYmplY3QgdHlwZVxuICAgIC8vIC0gc2xpY2luZyBmaWxlc1xuICAgIHRoaXMuc3VwcG9ydCA9IChcbiAgICAgICAgICAgICAgICAgICAodHlwZW9mKEZpbGUpIT09J3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAgICAodHlwZW9mKEJsb2IpIT09J3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgICAgICAgICAodHlwZW9mKEZpbGVMaXN0KSE9PSd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgICAgICAgKCEhQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2V8fCEhQmxvYi5wcm90b3R5cGUubW96U2xpY2V8fCEhQmxvYi5wcm90b3R5cGUuc2xpY2V8fGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICk7XG4gICAgaWYoIXRoaXMuc3VwcG9ydCkgcmV0dXJuKGZhbHNlKTtcblxuXG4gICAgLy8gUFJPUEVSVElFU1xuICAgIHZhciAkID0gdGhpcztcbiAgICAkLmZpbGVzID0gW107XG4gICAgJC5kZWZhdWx0cyA9IHtcbiAgICAgIGNodW5rU2l6ZToxKjEwMjQqMTAyNCxcbiAgICAgIGZvcmNlQ2h1bmtTaXplOmZhbHNlLFxuICAgICAgc2ltdWx0YW5lb3VzVXBsb2FkczozLFxuICAgICAgZmlsZVBhcmFtZXRlck5hbWU6J2ZpbGUnLFxuICAgICAgY2h1bmtOdW1iZXJQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlQ2h1bmtOdW1iZXInLFxuICAgICAgY2h1bmtTaXplUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZUNodW5rU2l6ZScsXG4gICAgICBjdXJyZW50Q2h1bmtTaXplUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZUN1cnJlbnRDaHVua1NpemUnLFxuICAgICAgdG90YWxTaXplUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZVRvdGFsU2l6ZScsXG4gICAgICB0eXBlUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZVR5cGUnLFxuICAgICAgaWRlbnRpZmllclBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVJZGVudGlmaWVyJyxcbiAgICAgIGZpbGVOYW1lUGFyYW1ldGVyTmFtZTogJ3Jlc3VtYWJsZUZpbGVuYW1lJyxcbiAgICAgIHJlbGF0aXZlUGF0aFBhcmFtZXRlck5hbWU6ICdyZXN1bWFibGVSZWxhdGl2ZVBhdGgnLFxuICAgICAgdG90YWxDaHVua3NQYXJhbWV0ZXJOYW1lOiAncmVzdW1hYmxlVG90YWxDaHVua3MnLFxuICAgICAgdGhyb3R0bGVQcm9ncmVzc0NhbGxiYWNrczogMC41LFxuICAgICAgcXVlcnk6e30sXG4gICAgICBoZWFkZXJzOnt9LFxuICAgICAgcHJlcHJvY2VzczpudWxsLFxuICAgICAgbWV0aG9kOidtdWx0aXBhcnQnLFxuICAgICAgdXBsb2FkTWV0aG9kOiAnUE9TVCcsXG4gICAgICB0ZXN0TWV0aG9kOiAnR0VUJyxcbiAgICAgIHByaW9yaXRpemVGaXJzdEFuZExhc3RDaHVuazpmYWxzZSxcbiAgICAgIHRhcmdldDonLycsXG4gICAgICB0ZXN0VGFyZ2V0OiBudWxsLFxuICAgICAgcGFyYW1ldGVyTmFtZXNwYWNlOicnLFxuICAgICAgdGVzdENodW5rczp0cnVlLFxuICAgICAgZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyOm51bGwsXG4gICAgICBnZXRUYXJnZXQ6bnVsbCxcbiAgICAgIG1heENodW5rUmV0cmllczoxMDAsXG4gICAgICBjaHVua1JldHJ5SW50ZXJ2YWw6dW5kZWZpbmVkLFxuICAgICAgcGVybWFuZW50RXJyb3JzOls0MDAsIDQwNCwgNDE1LCA1MDAsIDUwMV0sXG4gICAgICBtYXhGaWxlczp1bmRlZmluZWQsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6ZmFsc2UsXG4gICAgICB4aHJUaW1lb3V0OjAsXG4gICAgICBjbGVhcklucHV0OnRydWUsXG4gICAgICBjaHVua0Zvcm1hdDonYmxvYicsXG4gICAgICBzZXRDaHVua1R5cGVGcm9tRmlsZTpmYWxzZSxcbiAgICAgIG1heEZpbGVzRXJyb3JDYWxsYmFjazpmdW5jdGlvbiAoZmlsZXMsIGVycm9yQ291bnQpIHtcbiAgICAgICAgdmFyIG1heEZpbGVzID0gJC5nZXRPcHQoJ21heEZpbGVzJyk7XG4gICAgICAgIGFsZXJ0KCdQbGVhc2UgdXBsb2FkIG5vIG1vcmUgdGhhbiAnICsgbWF4RmlsZXMgKyAnIGZpbGUnICsgKG1heEZpbGVzID09PSAxID8gJycgOiAncycpICsgJyBhdCBhIHRpbWUuJyk7XG4gICAgICB9LFxuICAgICAgbWluRmlsZVNpemU6MSxcbiAgICAgIG1pbkZpbGVTaXplRXJyb3JDYWxsYmFjazpmdW5jdGlvbihmaWxlLCBlcnJvckNvdW50KSB7XG4gICAgICAgIGFsZXJ0KGZpbGUuZmlsZU5hbWV8fGZpbGUubmFtZSArJyBpcyB0b28gc21hbGwsIHBsZWFzZSB1cGxvYWQgZmlsZXMgbGFyZ2VyIHRoYW4gJyArICRoLmZvcm1hdFNpemUoJC5nZXRPcHQoJ21pbkZpbGVTaXplJykpICsgJy4nKTtcbiAgICAgIH0sXG4gICAgICBtYXhGaWxlU2l6ZTp1bmRlZmluZWQsXG4gICAgICBtYXhGaWxlU2l6ZUVycm9yQ2FsbGJhY2s6ZnVuY3Rpb24oZmlsZSwgZXJyb3JDb3VudCkge1xuICAgICAgICBhbGVydChmaWxlLmZpbGVOYW1lfHxmaWxlLm5hbWUgKycgaXMgdG9vIGxhcmdlLCBwbGVhc2UgdXBsb2FkIGZpbGVzIGxlc3MgdGhhbiAnICsgJGguZm9ybWF0U2l6ZSgkLmdldE9wdCgnbWF4RmlsZVNpemUnKSkgKyAnLicpO1xuICAgICAgfSxcbiAgICAgIGZpbGVUeXBlOiBbXSxcbiAgICAgIGZpbGVUeXBlRXJyb3JDYWxsYmFjazogZnVuY3Rpb24oZmlsZSwgZXJyb3JDb3VudCkge1xuICAgICAgICBhbGVydChmaWxlLmZpbGVOYW1lfHxmaWxlLm5hbWUgKycgaGFzIHR5cGUgbm90IGFsbG93ZWQsIHBsZWFzZSB1cGxvYWQgZmlsZXMgb2YgdHlwZSAnICsgJC5nZXRPcHQoJ2ZpbGVUeXBlJykgKyAnLicpO1xuICAgICAgfVxuICAgIH07XG4gICAgJC5vcHRzID0gb3B0c3x8e307XG4gICAgJC5nZXRPcHQgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgJG9wdCA9IHRoaXM7XG4gICAgICAvLyBHZXQgbXVsdGlwbGUgb3B0aW9uIGlmIHBhc3NlZCBhbiBhcnJheVxuICAgICAgaWYobyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICRoLmVhY2gobywgZnVuY3Rpb24ob3B0aW9uKXtcbiAgICAgICAgICBvcHRpb25zW29wdGlvbl0gPSAkb3B0LmdldE9wdChvcHRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgc2ltcGxlIG9wdGlvblxuICAgICAgaWYgKCRvcHQgaW5zdGFuY2VvZiBSZXN1bWFibGVDaHVuaykge1xuICAgICAgICBpZiAodHlwZW9mICRvcHQub3B0c1tvXSAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuICRvcHQub3B0c1tvXTsgfVxuICAgICAgICBlbHNlIHsgJG9wdCA9ICRvcHQuZmlsZU9iajsgfVxuICAgICAgfVxuICAgICAgaWYgKCRvcHQgaW5zdGFuY2VvZiBSZXN1bWFibGVGaWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJG9wdC5vcHRzW29dICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gJG9wdC5vcHRzW29dOyB9XG4gICAgICAgIGVsc2UgeyAkb3B0ID0gJG9wdC5yZXN1bWFibGVPYmo7IH1cbiAgICAgIH1cbiAgICAgIGlmICgkb3B0IGluc3RhbmNlb2YgUmVzdW1hYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJG9wdC5vcHRzW29dICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gJG9wdC5vcHRzW29dOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gJG9wdC5kZWZhdWx0c1tvXTsgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFVkVOVFNcbiAgICAvLyBjYXRjaEFsbChldmVudCwgLi4uKVxuICAgIC8vIGZpbGVTdWNjZXNzKGZpbGUpLCBmaWxlUHJvZ3Jlc3MoZmlsZSksIGZpbGVBZGRlZChmaWxlLCBldmVudCksIGZpbGVzQWRkZWQoZmlsZXMsIGZpbGVzU2tpcHBlZCksIGZpbGVSZXRyeShmaWxlKSxcbiAgICAvLyBmaWxlRXJyb3IoZmlsZSwgbWVzc2FnZSksIGNvbXBsZXRlKCksIHByb2dyZXNzKCksIGVycm9yKG1lc3NhZ2UsIGZpbGUpLCBwYXVzZSgpXG4gICAgJC5ldmVudHMgPSBbXTtcbiAgICAkLm9uID0gZnVuY3Rpb24oZXZlbnQsY2FsbGJhY2spe1xuICAgICAgJC5ldmVudHMucHVzaChldmVudC50b0xvd2VyQ2FzZSgpLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAkLmZpcmUgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gYGFyZ3VtZW50c2AgaXMgYW4gb2JqZWN0LCBub3QgYXJyYXksIGluIEZGLCBzbzpcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIC8vIEZpbmQgZXZlbnQgbGlzdGVuZXJzLCBhbmQgc3VwcG9ydCBwc2V1ZG8tZXZlbnQgYGNhdGNoQWxsYFxuICAgICAgdmFyIGV2ZW50ID0gYXJnc1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPD0kLmV2ZW50cy5sZW5ndGg7IGkrPTIpIHtcbiAgICAgICAgaWYoJC5ldmVudHNbaV09PWV2ZW50KSAkLmV2ZW50c1tpKzFdLmFwcGx5KCQsYXJncy5zbGljZSgxKSk7XG4gICAgICAgIGlmKCQuZXZlbnRzW2ldPT0nY2F0Y2hhbGwnKSAkLmV2ZW50c1tpKzFdLmFwcGx5KG51bGwsYXJncyk7XG4gICAgICB9XG4gICAgICBpZihldmVudD09J2ZpbGVlcnJvcicpICQuZmlyZSgnZXJyb3InLCBhcmdzWzJdLCBhcmdzWzFdKTtcbiAgICAgIGlmKGV2ZW50PT0nZmlsZXByb2dyZXNzJykgJC5maXJlKCdwcm9ncmVzcycpO1xuICAgIH07XG5cblxuICAgIC8vIElOVEVSTkFMIEhFTFBFUiBNRVRIT0RTIChoYW5keSwgYnV0IHVsdGltYXRlbHkgbm90IHBhcnQgb2YgdXBsb2FkaW5nKVxuICAgIHZhciAkaCA9IHtcbiAgICAgIHN0b3BFdmVudDogZnVuY3Rpb24oZSl7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgICBlYWNoOiBmdW5jdGlvbihvLGNhbGxiYWNrKXtcbiAgICAgICAgaWYodHlwZW9mKG8ubGVuZ3RoKSE9PSd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEFycmF5IG9yIEZpbGVMaXN0XG4gICAgICAgICAgICBpZihjYWxsYmFjayhvW2ldKT09PWZhbHNlKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSBpbiBvKSB7XG4gICAgICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKGksb1tpXSk9PT1mYWxzZSkgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcjpmdW5jdGlvbihmaWxlLCBldmVudCl7XG4gICAgICAgIHZhciBjdXN0b20gPSAkLmdldE9wdCgnZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyJyk7XG4gICAgICAgIGlmKHR5cGVvZiBjdXN0b20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gY3VzdG9tKGZpbGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGh8fGZpbGUuZmlsZU5hbWV8fGZpbGUubmFtZTsgLy8gU29tZSBjb25mdXNpb24gaW4gZGlmZmVyZW50IHZlcnNpb25zIG9mIEZpcmVmb3hcbiAgICAgICAgdmFyIHNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgIHJldHVybihzaXplICsgJy0nICsgcmVsYXRpdmVQYXRoLnJlcGxhY2UoL1teMC05YS16QS1aXy1dL2ltZywgJycpKTtcbiAgICAgIH0sXG4gICAgICBjb250YWluczpmdW5jdGlvbihhcnJheSx0ZXN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAkaC5lYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSB0ZXN0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBmb3JtYXRTaXplOmZ1bmN0aW9uKHNpemUpe1xuICAgICAgICBpZihzaXplPDEwMjQpIHtcbiAgICAgICAgICByZXR1cm4gc2l6ZSArICcgYnl0ZXMnO1xuICAgICAgICB9IGVsc2UgaWYoc2l6ZTwxMDI0KjEwMjQpIHtcbiAgICAgICAgICByZXR1cm4gKHNpemUvMTAyNC4wKS50b0ZpeGVkKDApICsgJyBLQic7XG4gICAgICAgIH0gZWxzZSBpZihzaXplPDEwMjQqMTAyNCoxMDI0KSB7XG4gICAgICAgICAgcmV0dXJuIChzaXplLzEwMjQuMC8xMDI0LjApLnRvRml4ZWQoMSkgKyAnIE1CJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKHNpemUvMTAyNC4wLzEwMjQuMC8xMDI0LjApLnRvRml4ZWQoMSkgKyAnIEdCJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFRhcmdldDpmdW5jdGlvbihyZXF1ZXN0LCBwYXJhbXMpe1xuICAgICAgICB2YXIgdGFyZ2V0ID0gJC5nZXRPcHQoJ3RhcmdldCcpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSAndGVzdCcgJiYgJC5nZXRPcHQoJ3Rlc3RUYXJnZXQnKSkge1xuICAgICAgICAgIHRhcmdldCA9ICQuZ2V0T3B0KCd0ZXN0VGFyZ2V0JykgPT09ICcvJyA/ICQuZ2V0T3B0KCd0YXJnZXQnKSA6ICQuZ2V0T3B0KCd0ZXN0VGFyZ2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQocGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSB0YXJnZXQuaW5kZXhPZignPycpIDwgMCA/ICc/JyA6ICcmJztcbiAgICAgICAgdmFyIGpvaW5lZFBhcmFtcyA9IHBhcmFtcy5qb2luKCcmJyk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCArIHNlcGFyYXRvciArIGpvaW5lZFBhcmFtcztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uRHJvcCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICRoLnN0b3BFdmVudChldmVudCk7XG5cbiAgICAgIC8vaGFuZGxlIGRyb3BwZWQgdGhpbmdzIGFzIGl0ZW1zIGlmIHdlIGNhbiAodGhpcyBsZXRzIHVzIGRlYWwgd2l0aCBmb2xkZXJzIG5pY2VyIGluIHNvbWUgY2FzZXMpXG4gICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyICYmIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgICBsb2FkRmlsZXMoZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zLCBldmVudCk7XG4gICAgICB9XG4gICAgICAvL2Vsc2UgaGFuZGxlIHRoZW0gYXMgZmlsZXNcbiAgICAgIGVsc2UgaWYgKGV2ZW50LmRhdGFUcmFuc2ZlciAmJiBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpIHtcbiAgICAgICAgbG9hZEZpbGVzKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzZXMgYSBzaW5nbGUgdXBsb2FkIGl0ZW0gKGZpbGUgb3IgZGlyZWN0b3J5KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIGl0ZW0gdG8gdXBsb2FkLCBtYXkgYmUgZmlsZSBvciBkaXJlY3RvcnkgZW50cnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBjdXJyZW50IGZpbGUgcGF0aFxuICAgICAqIEBwYXJhbSB7RmlsZVtdfSBpdGVtcyBsaXN0IG9mIGZpbGVzIHRvIGFwcGVuZCBuZXcgaXRlbXMgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBjYWxsYmFjayBpbnZva2VkIHdoZW4gaXRlbSBpcyBwcm9jZXNzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzSXRlbShpdGVtLCBwYXRoLCBpdGVtcywgY2IpIHtcbiAgICAgIHZhciBlbnRyeTtcbiAgICAgIGlmKGl0ZW0uaXNGaWxlKXtcbiAgICAgICAgLy8gZmlsZSBwcm92aWRlZFxuICAgICAgICByZXR1cm4gaXRlbS5maWxlKGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICAgIGZpbGUucmVsYXRpdmVQYXRoID0gcGF0aCArIGZpbGUubmFtZTtcbiAgICAgICAgICBpdGVtcy5wdXNoKGZpbGUpO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfWVsc2UgaWYoaXRlbS5pc0RpcmVjdG9yeSl7XG4gICAgICAgIC8vIGl0ZW0gaXMgYWxyZWFkeSBhIGRpcmVjdG9yeSBlbnRyeSwganVzdCBhc3NpZ25cbiAgICAgICAgZW50cnkgPSBpdGVtO1xuICAgICAgfWVsc2UgaWYoaXRlbSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBpdGVtLndlYmtpdEdldEFzRW50cnkpe1xuICAgICAgICAvLyBnZXQgZW50cnkgZnJvbSBmaWxlIG9iamVjdFxuICAgICAgICBlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgICAgfVxuICAgICAgaWYoZW50cnkgJiYgZW50cnkuaXNEaXJlY3Rvcnkpe1xuICAgICAgICAvLyBkaXJlY3RvcnkgcHJvdmlkZWQsIHByb2Nlc3MgaXRcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NEaXJlY3RvcnkoZW50cnksIHBhdGggKyBlbnRyeS5uYW1lICsgJy8nLCBpdGVtcywgY2IpO1xuICAgICAgfVxuICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGl0ZW0uZ2V0QXNGaWxlKXtcbiAgICAgICAgLy8gaXRlbSByZXByZXNlbnRzIGEgRmlsZSBvYmplY3QsIGNvbnZlcnQgaXRcbiAgICAgICAgaXRlbSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgIGlmKGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgaXRlbS5yZWxhdGl2ZVBhdGggPSBwYXRoICsgaXRlbS5uYW1lO1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNiKCk7IC8vIGluZGljYXRlIHByb2Nlc3NpbmcgaXMgZG9uZVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogY3BzLXN0eWxlIGxpc3QgaXRlcmF0aW9uLlxuICAgICAqIGludm9rZXMgYWxsIGZ1bmN0aW9ucyBpbiBsaXN0IGFuZCB3YWl0cyBmb3IgdGhlaXIgY2FsbGJhY2sgdG8gYmVcbiAgICAgKiB0cmlnZ2VyZWQuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb25bXX0gICBpdGVtcyBsaXN0IG9mIGZ1bmN0aW9ucyBleHBlY3RpbmcgY2FsbGJhY2sgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiICAgIGNhbGxiYWNrIHRvIHRyaWdnZXIgYWZ0ZXIgdGhlIGxhc3QgY2FsbGJhY2sgaGFzIGJlZW4gaW52b2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NDYWxsYmFja3MoaXRlbXMsIGNiKXtcbiAgICAgIGlmKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApe1xuICAgICAgICAvLyBlbXB0eSBvciBubyBsaXN0LCBpbnZva2UgY2FsbGJhY2tcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9XG4gICAgICAvLyBpbnZva2UgY3VycmVudCBmdW5jdGlvbiwgcGFzcyB0aGUgbmV4dCBwYXJ0IGFzIGNvbnRpbnVhdGlvblxuICAgICAgaXRlbXNbMF0oZnVuY3Rpb24oKXtcbiAgICAgICAgcHJvY2Vzc0NhbGxiYWNrcyhpdGVtcy5zbGljZSgxKSwgY2IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVjdXJzaXZlbHkgdHJhdmVyc2UgZGlyZWN0b3J5IGFuZCBjb2xsZWN0IGZpbGVzIHRvIHVwbG9hZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBkaXJlY3RvcnkgZGlyZWN0b3J5IHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgcGF0aCAgICAgIGN1cnJlbnQgcGF0aFxuICAgICAqIEBwYXJhbSAge0ZpbGVbXX0gICBpdGVtcyAgICAgdGFyZ2V0IGxpc3Qgb2YgaXRlbXNcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgICAgIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdHJhdmVyc2luZyBkaXJlY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGlyZWN0b3J5IChkaXJlY3RvcnksIHBhdGgsIGl0ZW1zLCBjYikge1xuICAgICAgdmFyIGRpclJlYWRlciA9IGRpcmVjdG9yeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbihlbnRyaWVzKXtcbiAgICAgICAgaWYoIWVudHJpZXMubGVuZ3RoKXtcbiAgICAgICAgICAvLyBlbXB0eSBkaXJlY3RvcnksIHNraXBcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9jZXNzIGFsbCBjb252ZXJzaW9uIGNhbGxiYWNrcywgZmluYWxseSBpbnZva2Ugb3duIG9uZVxuICAgICAgICBwcm9jZXNzQ2FsbGJhY2tzKFxuICAgICAgICAgIGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KXtcbiAgICAgICAgICAgIC8vIGJpbmQgYWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NJdGVtLmJpbmQobnVsbCwgZW50cnksIHBhdGgsIGl0ZW1zKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjYlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBpdGVtcyB0byBleHRyYWN0IGZpbGVzIHRvIGJlIHVwbG9hZGVkXG4gICAgICogQHBhcmFtICB7RmlsZVtdfSBpdGVtcyBpdGVtcyB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IGV2ZW50IHRoYXQgbGVkIHRvIHVwbG9hZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvYWRGaWxlcyhpdGVtcywgZXZlbnQpIHtcbiAgICAgIGlmKCFpdGVtcy5sZW5ndGgpe1xuICAgICAgICByZXR1cm47IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgIH1cbiAgICAgICQuZmlyZSgnYmVmb3JlQWRkJyk7XG4gICAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICAgIHByb2Nlc3NDYWxsYmFja3MoXG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGl0ZW1zLCBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIC8vIGJpbmQgYWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NJdGVtLmJpbmQobnVsbCwgaXRlbSwgXCJcIiwgZmlsZXMpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZihmaWxlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgZmlsZSBmb3VuZFxuICAgICAgICAgICAgICBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdChmaWxlcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmRGaWxlc0Zyb21GaWxlTGlzdCA9IGZ1bmN0aW9uKGZpbGVMaXN0LCBldmVudCl7XG4gICAgICAvLyBjaGVjayBmb3IgdXBsb2FkaW5nIHRvbyBtYW55IGZpbGVzXG4gICAgICB2YXIgZXJyb3JDb3VudCA9IDA7XG4gICAgICB2YXIgbyA9ICQuZ2V0T3B0KFsnbWF4RmlsZXMnLCAnbWluRmlsZVNpemUnLCAnbWF4RmlsZVNpemUnLCAnbWF4RmlsZXNFcnJvckNhbGxiYWNrJywgJ21pbkZpbGVTaXplRXJyb3JDYWxsYmFjaycsICdtYXhGaWxlU2l6ZUVycm9yQ2FsbGJhY2snLCAnZmlsZVR5cGUnLCAnZmlsZVR5cGVFcnJvckNhbGxiYWNrJ10pO1xuICAgICAgaWYgKHR5cGVvZihvLm1heEZpbGVzKSE9PSd1bmRlZmluZWQnICYmIG8ubWF4RmlsZXM8KGZpbGVMaXN0Lmxlbmd0aCskLmZpbGVzLmxlbmd0aCkpIHtcbiAgICAgICAgLy8gaWYgc2luZ2xlLWZpbGUgdXBsb2FkLCBmaWxlIGlzIGFscmVhZHkgYWRkZWQsIGFuZCB0cnlpbmcgdG8gYWRkIDEgbmV3IGZpbGUsIHNpbXBseSByZXBsYWNlIHRoZSBhbHJlYWR5LWFkZGVkIGZpbGVcbiAgICAgICAgaWYgKG8ubWF4RmlsZXM9PT0xICYmICQuZmlsZXMubGVuZ3RoPT09MSAmJiBmaWxlTGlzdC5sZW5ndGg9PT0xKSB7XG4gICAgICAgICAgJC5yZW1vdmVGaWxlKCQuZmlsZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ubWF4RmlsZXNFcnJvckNhbGxiYWNrKGZpbGVMaXN0LCBlcnJvckNvdW50KyspO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZpbGVzID0gW10sIGZpbGVzU2tpcHBlZCA9IFtdLCByZW1haW5pbmcgPSBmaWxlTGlzdC5sZW5ndGg7XG4gICAgICB2YXIgZGVjcmVhc2VSZWFtaW5pbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZighLS1yZW1haW5pbmcpe1xuICAgICAgICAgIC8vIGFsbCBmaWxlcyBwcm9jZXNzZWQsIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgICBpZighZmlsZXMubGVuZ3RoICYmICFmaWxlc1NraXBwZWQubGVuZ3RoKXtcbiAgICAgICAgICAgIC8vIG5vIHN1Y2NlZWRlZCBmaWxlcywganVzdCBza2lwXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkLmZpcmUoJ2ZpbGVzQWRkZWQnLCBmaWxlcywgZmlsZXNTa2lwcGVkKTtcbiAgICAgICAgICB9LDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJGguZWFjaChmaWxlTGlzdCwgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgaWYoby5maWxlVHlwZS5sZW5ndGggPiAwKXtcbiAgICAgICAgICB2YXIgZmlsZVR5cGVGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGZvcih2YXIgaW5kZXggaW4gby5maWxlVHlwZSl7XG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gJy4nICsgby5maWxlVHlwZVtpbmRleF07XG5cdFx0XHRpZihmaWxlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCksIGZpbGVOYW1lLmxlbmd0aCAtIGV4dGVuc2lvbi5sZW5ndGgpICE9PSAtMSl7XG4gICAgICAgICAgICAgIGZpbGVUeXBlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmaWxlVHlwZUZvdW5kKSB7XG4gICAgICAgICAgICBvLmZpbGVUeXBlRXJyb3JDYWxsYmFjayhmaWxlLCBlcnJvckNvdW50KyspO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Yoby5taW5GaWxlU2l6ZSkhPT0ndW5kZWZpbmVkJyAmJiBmaWxlLnNpemU8by5taW5GaWxlU2l6ZSkge1xuICAgICAgICAgIG8ubWluRmlsZVNpemVFcnJvckNhbGxiYWNrKGZpbGUsIGVycm9yQ291bnQrKyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yoby5tYXhGaWxlU2l6ZSkhPT0ndW5kZWZpbmVkJyAmJiBmaWxlLnNpemU+by5tYXhGaWxlU2l6ZSkge1xuICAgICAgICAgIG8ubWF4RmlsZVNpemVFcnJvckNhbGxiYWNrKGZpbGUsIGVycm9yQ291bnQrKyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkRmlsZSh1bmlxdWVJZGVudGlmaWVyKXtcbiAgICAgICAgICBpZiAoISQuZ2V0RnJvbVVuaXF1ZUlkZW50aWZpZXIodW5pcXVlSWRlbnRpZmllcikpIHsoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZpbGUudW5pcXVlSWRlbnRpZmllciA9IHVuaXF1ZUlkZW50aWZpZXI7XG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBSZXN1bWFibGVGaWxlKCQsIGZpbGUsIHVuaXF1ZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgJC5maWxlcy5wdXNoKGYpO1xuICAgICAgICAgICAgZmlsZXMucHVzaChmKTtcbiAgICAgICAgICAgIGYuY29udGFpbmVyID0gKHR5cGVvZiBldmVudCAhPSAndW5kZWZpbmVkJyA/IGV2ZW50LnNyY0VsZW1lbnQgOiBudWxsKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICQuZmlyZSgnZmlsZUFkZGVkJywgZiwgZXZlbnQpXG4gICAgICAgICAgICB9LDApO1xuICAgICAgICAgIH0pKCl9IGVsc2Uge1xuICAgICAgICAgICAgZmlsZXNTa2lwcGVkLnB1c2goZmlsZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWNyZWFzZVJlYW1pbmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpcmVjdG9yaWVzIGhhdmUgc2l6ZSA9PSAwXG4gICAgICAgIHZhciB1bmlxdWVJZGVudGlmaWVyID0gJGguZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyKGZpbGUsIGV2ZW50KTtcbiAgICAgICAgaWYodW5pcXVlSWRlbnRpZmllciAmJiB0eXBlb2YgdW5pcXVlSWRlbnRpZmllci50aGVuID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAvLyBQcm9taXNlIG9yIFByb21pc2UtbGlrZSBvYmplY3QgcHJvdmlkZWQgYXMgdW5pcXVlIGlkZW50aWZpZXJcbiAgICAgICAgICB1bmlxdWVJZGVudGlmaWVyXG4gICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbih1bmlxdWVJZGVudGlmaWVyKXtcbiAgICAgICAgICAgICAgLy8gdW5pcXVlIGlkZW50aWZpZXIgZ2VuZXJhdGlvbiBzdWNjZWVkZWRcbiAgICAgICAgICAgICAgYWRkRmlsZSh1bmlxdWVJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIC8vIHVuaXF1ZSBpZGVudGlmaWVyIGdlbmVyYXRpb24gZmFpbGVkXG4gICAgICAgICAgICAgIC8vIHNraXAgZnVydGhlciBwcm9jZXNzaW5nLCBvbmx5IGRlY3JlYXNlIGZpbGUgY291bnRcbiAgICAgICAgICAgICAgZGVjcmVhc2VSZWFtaW5pbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyBub24tUHJvbWlzZSBwcm92aWRlZCBhcyB1bmlxdWUgaWRlbnRpZmllciwgcHJvY2VzcyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgYWRkRmlsZSh1bmlxdWVJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIElOVEVSTkFMIE9CSkVDVCBUWVBFU1xuICAgIGZ1bmN0aW9uIFJlc3VtYWJsZUZpbGUocmVzdW1hYmxlT2JqLCBmaWxlLCB1bmlxdWVJZGVudGlmaWVyKXtcbiAgICAgIHZhciAkID0gdGhpcztcbiAgICAgICQub3B0cyA9IHt9O1xuICAgICAgJC5nZXRPcHQgPSByZXN1bWFibGVPYmouZ2V0T3B0O1xuICAgICAgJC5fcHJldlByb2dyZXNzID0gMDtcbiAgICAgICQucmVzdW1hYmxlT2JqID0gcmVzdW1hYmxlT2JqO1xuICAgICAgJC5maWxlID0gZmlsZTtcbiAgICAgICQuZmlsZU5hbWUgPSBmaWxlLmZpbGVOYW1lfHxmaWxlLm5hbWU7IC8vIFNvbWUgY29uZnVzaW9uIGluIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBGaXJlZm94XG4gICAgICAkLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAkLnJlbGF0aXZlUGF0aCA9IGZpbGUucmVsYXRpdmVQYXRoIHx8IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoIHx8ICQuZmlsZU5hbWU7XG4gICAgICAkLnVuaXF1ZUlkZW50aWZpZXIgPSB1bmlxdWVJZGVudGlmaWVyO1xuICAgICAgJC5fcGF1c2UgPSBmYWxzZTtcbiAgICAgICQuY29udGFpbmVyID0gJyc7XG4gICAgICB2YXIgX2Vycm9yID0gdW5pcXVlSWRlbnRpZmllciAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBDYWxsYmFjayB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGhpbiB0aGUgY2h1bmtcbiAgICAgIHZhciBjaHVua0V2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIG1lc3NhZ2Upe1xuICAgICAgICAvLyBldmVudCBjYW4gYmUgJ3Byb2dyZXNzJywgJ3N1Y2Nlc3MnLCAnZXJyb3InIG9yICdyZXRyeSdcbiAgICAgICAgc3dpdGNoKGV2ZW50KXtcbiAgICAgICAgY2FzZSAncHJvZ3Jlc3MnOlxuICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVQcm9ncmVzcycsICQsIG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgJC5hYm9ydCgpO1xuICAgICAgICAgIF9lcnJvciA9IHRydWU7XG4gICAgICAgICAgJC5jaHVua3MgPSBbXTtcbiAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlRXJyb3InLCAkLCBtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgaWYoX2Vycm9yKSByZXR1cm47XG4gICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVByb2dyZXNzJywgJCk7IC8vIGl0J3MgYXQgbGVhc3QgcHJvZ3Jlc3NcbiAgICAgICAgICBpZigkLmlzQ29tcGxldGUoKSkge1xuICAgICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnZmlsZVN1Y2Nlc3MnLCAkLCBtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JldHJ5JzpcbiAgICAgICAgICAkLnJlc3VtYWJsZU9iai5maXJlKCdmaWxlUmV0cnknLCAkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gTWFpbiBjb2RlIHRvIHNldCB1cCBhIGZpbGUgb2JqZWN0IHdpdGggY2h1bmtzLFxuICAgICAgLy8gcGFja2FnZWQgdG8gYmUgYWJsZSB0byBoYW5kbGUgcmV0cmllcyBpZiBuZWVkZWQuXG4gICAgICAkLmNodW5rcyA9IFtdO1xuICAgICAgJC5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFN0b3AgY3VycmVudCB1cGxvYWRzXG4gICAgICAgIHZhciBhYm9ydENvdW50ID0gMDtcbiAgICAgICAgJGguZWFjaCgkLmNodW5rcywgZnVuY3Rpb24oYyl7XG4gICAgICAgICAgaWYoYy5zdGF0dXMoKT09J3VwbG9hZGluZycpIHtcbiAgICAgICAgICAgIGMuYWJvcnQoKTtcbiAgICAgICAgICAgIGFib3J0Q291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZihhYm9ydENvdW50PjApICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVQcm9ncmVzcycsICQpO1xuICAgICAgfTtcbiAgICAgICQuY2FuY2VsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gUmVzZXQgdGhpcyBmaWxlIHRvIGJlIHZvaWRcbiAgICAgICAgdmFyIF9jaHVua3MgPSAkLmNodW5rcztcbiAgICAgICAgJC5jaHVua3MgPSBbXTtcbiAgICAgICAgLy8gU3RvcCBjdXJyZW50IHVwbG9hZHNcbiAgICAgICAgJGguZWFjaChfY2h1bmtzLCBmdW5jdGlvbihjKXtcbiAgICAgICAgICBpZihjLnN0YXR1cygpPT0ndXBsb2FkaW5nJykgIHtcbiAgICAgICAgICAgIGMuYWJvcnQoKTtcbiAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLnVwbG9hZE5leHRDaHVuaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICQucmVzdW1hYmxlT2JqLnJlbW92ZUZpbGUoJCk7XG4gICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2ZpbGVQcm9ncmVzcycsICQpO1xuICAgICAgfTtcbiAgICAgICQucmV0cnkgPSBmdW5jdGlvbigpe1xuICAgICAgICAkLmJvb3RzdHJhcCgpO1xuICAgICAgICB2YXIgZmlyZWRSZXRyeSA9IGZhbHNlO1xuICAgICAgICAkLnJlc3VtYWJsZU9iai5vbignY2h1bmtpbmdDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoIWZpcmVkUmV0cnkpICQucmVzdW1hYmxlT2JqLnVwbG9hZCgpO1xuICAgICAgICAgIGZpcmVkUmV0cnkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAkLmJvb3RzdHJhcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICQuYWJvcnQoKTtcbiAgICAgICAgX2Vycm9yID0gZmFsc2U7XG4gICAgICAgIC8vIFJlYnVpbGQgc3RhY2sgb2YgY2h1bmtzIGZyb20gZmlsZVxuICAgICAgICAkLmNodW5rcyA9IFtdO1xuICAgICAgICAkLl9wcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgICB2YXIgcm91bmQgPSAkLmdldE9wdCgnZm9yY2VDaHVua1NpemUnKSA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLm1heChyb3VuZCgkLmZpbGUuc2l6ZS8kLmdldE9wdCgnY2h1bmtTaXplJykpLDEpO1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQ9MDsgb2Zmc2V0PG1heE9mZnNldDsgb2Zmc2V0KyspIHsoZnVuY3Rpb24ob2Zmc2V0KXtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJC5jaHVua3MucHVzaChuZXcgUmVzdW1hYmxlQ2h1bmsoJC5yZXN1bWFibGVPYmosICQsIG9mZnNldCwgY2h1bmtFdmVudCkpO1xuICAgICAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLmZpcmUoJ2NodW5raW5nUHJvZ3Jlc3MnLCQsb2Zmc2V0L21heE9mZnNldCk7XG4gICAgICAgICAgICB9LDApO1xuICAgICAgICB9KShvZmZzZXQpfVxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnY2h1bmtpbmdDb21wbGV0ZScsJCk7XG4gICAgICAgIH0sMCk7XG4gICAgICB9O1xuICAgICAgJC5wcm9ncmVzcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKF9lcnJvcikgcmV0dXJuKDEpO1xuICAgICAgICAvLyBTdW0gdXAgcHJvZ3Jlc3MgYWNyb3NzIGV2ZXJ5dGhpbmdcbiAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgIHZhciBlcnJvciA9IGZhbHNlO1xuICAgICAgICAkaC5lYWNoKCQuY2h1bmtzLCBmdW5jdGlvbihjKXtcbiAgICAgICAgICBpZihjLnN0YXR1cygpPT0nZXJyb3InKSBlcnJvciA9IHRydWU7XG4gICAgICAgICAgcmV0ICs9IGMucHJvZ3Jlc3ModHJ1ZSk7IC8vIGdldCBjaHVuayBwcm9ncmVzcyByZWxhdGl2ZSB0byBlbnRpcmUgZmlsZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0ID0gKGVycm9yID8gMSA6IChyZXQ+MC45OTk5OSA/IDEgOiByZXQpKTtcbiAgICAgICAgcmV0ID0gTWF0aC5tYXgoJC5fcHJldlByb2dyZXNzLCByZXQpOyAvLyBXZSBkb24ndCB3YW50IHRvIGxvc2UgcGVyY2VudGFnZXMgd2hlbiBhbiB1cGxvYWQgaXMgcGF1c2VkXG4gICAgICAgICQuX3ByZXZQcm9ncmVzcyA9IHJldDtcbiAgICAgICAgcmV0dXJuKHJldCk7XG4gICAgICB9O1xuICAgICAgJC5pc1VwbG9hZGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB1cGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgJGguZWFjaCgkLmNodW5rcywgZnVuY3Rpb24oY2h1bmspe1xuICAgICAgICAgIGlmKGNodW5rLnN0YXR1cygpPT0ndXBsb2FkaW5nJykge1xuICAgICAgICAgICAgdXBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuKHVwbG9hZGluZyk7XG4gICAgICB9O1xuICAgICAgJC5pc0NvbXBsZXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG91dHN0YW5kaW5nID0gZmFsc2U7XG4gICAgICAgICRoLmVhY2goJC5jaHVua3MsIGZ1bmN0aW9uKGNodW5rKXtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gY2h1bmsuc3RhdHVzKCk7XG4gICAgICAgICAgaWYoc3RhdHVzPT0ncGVuZGluZycgfHwgc3RhdHVzPT0ndXBsb2FkaW5nJyB8fCBjaHVuay5wcmVwcm9jZXNzU3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIG91dHN0YW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuKCFvdXRzdGFuZGluZyk7XG4gICAgICB9O1xuICAgICAgJC5wYXVzZSA9IGZ1bmN0aW9uKHBhdXNlKXtcbiAgICAgICAgICBpZih0eXBlb2YocGF1c2UpPT09J3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgICAkLl9wYXVzZSA9ICgkLl9wYXVzZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICQuX3BhdXNlID0gcGF1c2U7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgICQuaXNQYXVzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICQuX3BhdXNlO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBCb290c3RyYXAgYW5kIHJldHVyblxuICAgICAgJC5yZXN1bWFibGVPYmouZmlyZSgnY2h1bmtpbmdTdGFydCcsICQpO1xuICAgICAgJC5ib290c3RyYXAoKTtcbiAgICAgIHJldHVybih0aGlzKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIFJlc3VtYWJsZUNodW5rKHJlc3VtYWJsZU9iaiwgZmlsZU9iaiwgb2Zmc2V0LCBjYWxsYmFjayl7XG4gICAgICB2YXIgJCA9IHRoaXM7XG4gICAgICAkLm9wdHMgPSB7fTtcbiAgICAgICQuZ2V0T3B0ID0gcmVzdW1hYmxlT2JqLmdldE9wdDtcbiAgICAgICQucmVzdW1hYmxlT2JqID0gcmVzdW1hYmxlT2JqO1xuICAgICAgJC5maWxlT2JqID0gZmlsZU9iajtcbiAgICAgICQuZmlsZU9ialNpemUgPSBmaWxlT2JqLnNpemU7XG4gICAgICAkLmZpbGVPYmpUeXBlID0gZmlsZU9iai5maWxlLnR5cGU7XG4gICAgICAkLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICQuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICQubGFzdFByb2dyZXNzQ2FsbGJhY2sgPSAobmV3IERhdGUpO1xuICAgICAgJC50ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICQucmV0cmllcyA9IDA7XG4gICAgICAkLnBlbmRpbmdSZXRyeSA9IGZhbHNlO1xuICAgICAgJC5wcmVwcm9jZXNzU3RhdGUgPSAwOyAvLyAwID0gdW5wcm9jZXNzZWQsIDEgPSBwcm9jZXNzaW5nLCAyID0gZmluaXNoZWRcblxuICAgICAgLy8gQ29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgdmFyIGNodW5rU2l6ZSA9ICQuZ2V0T3B0KCdjaHVua1NpemUnKTtcbiAgICAgICQubG9hZGVkID0gMDtcbiAgICAgICQuc3RhcnRCeXRlID0gJC5vZmZzZXQqY2h1bmtTaXplO1xuICAgICAgJC5lbmRCeXRlID0gTWF0aC5taW4oJC5maWxlT2JqU2l6ZSwgKCQub2Zmc2V0KzEpKmNodW5rU2l6ZSk7XG4gICAgICBpZiAoJC5maWxlT2JqU2l6ZS0kLmVuZEJ5dGUgPCBjaHVua1NpemUgJiYgISQuZ2V0T3B0KCdmb3JjZUNodW5rU2l6ZScpKSB7XG4gICAgICAgIC8vIFRoZSBsYXN0IGNodW5rIHdpbGwgYmUgYmlnZ2VyIHRoYW4gdGhlIGNodW5rIHNpemUsIGJ1dCBsZXNzIHRoYW4gMipjaHVua1NpemVcbiAgICAgICAgJC5lbmRCeXRlID0gJC5maWxlT2JqU2l6ZTtcbiAgICAgIH1cbiAgICAgICQueGhyID0gbnVsbDtcblxuICAgICAgLy8gdGVzdCgpIG1ha2VzIGEgR0VUIHJlcXVlc3Qgd2l0aG91dCBhbnkgZGF0YSB0byBzZWUgaWYgdGhlIGNodW5rIGhhcyBhbHJlYWR5IGJlZW4gdXBsb2FkZWQgaW4gYSBwcmV2aW91cyBzZXNzaW9uXG4gICAgICAkLnRlc3QgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBTZXQgdXAgcmVxdWVzdCBhbmQgbGlzdGVuIGZvciBldmVudFxuICAgICAgICAkLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIHZhciB0ZXN0SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICQudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gJC5zdGF0dXMoKTtcbiAgICAgICAgICBpZihzdGF0dXM9PSdzdWNjZXNzJykge1xuICAgICAgICAgICAgJC5jYWxsYmFjayhzdGF0dXMsICQubWVzc2FnZSgpKTtcbiAgICAgICAgICAgICQucmVzdW1hYmxlT2JqLnVwbG9hZE5leHRDaHVuaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLnNlbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0ZXN0SGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRlc3RIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICQueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0ZXN0SGFuZGxlciwgZmFsc2UpO1xuXG4gICAgICAgIC8vIEFkZCBkYXRhIGZyb20gdGhlIHF1ZXJ5IG9wdGlvbnNcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZXNwYWNlID0gJC5nZXRPcHQoJ3BhcmFtZXRlck5hbWVzcGFjZScpO1xuICAgICAgICB2YXIgY3VzdG9tUXVlcnkgPSAkLmdldE9wdCgncXVlcnknKTtcbiAgICAgICAgaWYodHlwZW9mIGN1c3RvbVF1ZXJ5ID09ICdmdW5jdGlvbicpIGN1c3RvbVF1ZXJ5ID0gY3VzdG9tUXVlcnkoJC5maWxlT2JqLCAkKTtcbiAgICAgICAgJGguZWFjaChjdXN0b21RdWVyeSwgZnVuY3Rpb24oayx2KXtcbiAgICAgICAgICBwYXJhbXMucHVzaChbZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlck5hbWVzcGFjZStrKSwgZW5jb2RlVVJJQ29tcG9uZW50KHYpXS5qb2luKCc9JykpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIGV4dHJhIGRhdGEgdG8gaWRlbnRpZnkgY2h1bmtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zLmNvbmNhdChcbiAgICAgICAgICBbXG4gICAgICAgICAgICAvLyBkZWZpbmUga2V5L3ZhbHVlIHBhaXJzIGZvciBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIFsnY2h1bmtOdW1iZXJQYXJhbWV0ZXJOYW1lJywgJC5vZmZzZXQgKyAxXSxcbiAgICAgICAgICAgIFsnY2h1bmtTaXplUGFyYW1ldGVyTmFtZScsICQuZ2V0T3B0KCdjaHVua1NpemUnKV0sXG4gICAgICAgICAgICBbJ2N1cnJlbnRDaHVua1NpemVQYXJhbWV0ZXJOYW1lJywgJC5lbmRCeXRlIC0gJC5zdGFydEJ5dGVdLFxuICAgICAgICAgICAgWyd0b3RhbFNpemVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqU2l6ZV0sXG4gICAgICAgICAgICBbJ3R5cGVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqVHlwZV0sXG4gICAgICAgICAgICBbJ2lkZW50aWZpZXJQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLnVuaXF1ZUlkZW50aWZpZXJdLFxuICAgICAgICAgICAgWydmaWxlTmFtZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmouZmlsZU5hbWVdLFxuICAgICAgICAgICAgWydyZWxhdGl2ZVBhdGhQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLnJlbGF0aXZlUGF0aF0sXG4gICAgICAgICAgICBbJ3RvdGFsQ2h1bmtzUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5jaHVua3MubGVuZ3RoXVxuICAgICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uKHBhaXIpe1xuICAgICAgICAgICAgLy8gaW5jbHVkZSBpdGVtcyB0aGF0IHJlc29sdmUgdG8gdHJ1dGh5IHZhbHVlc1xuICAgICAgICAgICAgLy8gaS5lLiBleGNsdWRlIGZhbHNlLCBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgIHJldHVybiAkLmdldE9wdChwYWlyWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocGFpcil7XG4gICAgICAgICAgICAvLyBtYXAgZWFjaCBrZXkvdmFsdWUgcGFpciB0byBpdHMgZmluYWwgZm9ybVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgcGFyYW1ldGVyTmFtZXNwYWNlICsgJC5nZXRPcHQocGFpclswXSksXG4gICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKVxuICAgICAgICAgICAgXS5qb2luKCc9Jyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQXBwZW5kIHRoZSByZWxldmFudCBjaHVuayBhbmQgc2VuZCBpdFxuICAgICAgICAkLnhoci5vcGVuKCQuZ2V0T3B0KCd0ZXN0TWV0aG9kJyksICRoLmdldFRhcmdldCgndGVzdCcsIHBhcmFtcykpO1xuICAgICAgICAkLnhoci50aW1lb3V0ID0gJC5nZXRPcHQoJ3hoclRpbWVvdXQnKTtcbiAgICAgICAgJC54aHIud2l0aENyZWRlbnRpYWxzID0gJC5nZXRPcHQoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgICAgICAvLyBBZGQgZGF0YSBmcm9tIGhlYWRlciBvcHRpb25zXG4gICAgICAgIHZhciBjdXN0b21IZWFkZXJzID0gJC5nZXRPcHQoJ2hlYWRlcnMnKTtcbiAgICAgICAgaWYodHlwZW9mIGN1c3RvbUhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjdXN0b21IZWFkZXJzID0gY3VzdG9tSGVhZGVycygkLmZpbGVPYmosICQpO1xuICAgICAgICB9XG4gICAgICAgICRoLmVhY2goY3VzdG9tSGVhZGVycywgZnVuY3Rpb24oayx2KSB7XG4gICAgICAgICAgJC54aHIuc2V0UmVxdWVzdEhlYWRlcihrLCB2KTtcbiAgICAgICAgfSk7XG4gICAgICAgICQueGhyLnNlbmQobnVsbCk7XG4gICAgICB9O1xuXG4gICAgICAkLnByZXByb2Nlc3NGaW5pc2hlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICQucHJlcHJvY2Vzc1N0YXRlID0gMjtcbiAgICAgICAgJC5zZW5kKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzZW5kKCkgdXBsb2FkcyB0aGUgYWN0dWFsIGRhdGEgaW4gYSBQT1NUIGNhbGxcbiAgICAgICQuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwcmVwcm9jZXNzID0gJC5nZXRPcHQoJ3ByZXByb2Nlc3MnKTtcbiAgICAgICAgaWYodHlwZW9mIHByZXByb2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzd2l0Y2goJC5wcmVwcm9jZXNzU3RhdGUpIHtcbiAgICAgICAgICBjYXNlIDA6ICQucHJlcHJvY2Vzc1N0YXRlID0gMTsgcHJlcHJvY2VzcygkKTsgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuO1xuICAgICAgICAgIGNhc2UgMjogYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKCQuZ2V0T3B0KCd0ZXN0Q2h1bmtzJykgJiYgISQudGVzdGVkKSB7XG4gICAgICAgICAgJC50ZXN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHVwIHJlcXVlc3QgYW5kIGxpc3RlbiBmb3IgZXZlbnRcbiAgICAgICAgJC54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAvLyBQcm9ncmVzc1xuICAgICAgICAkLnhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBpZiggKG5ldyBEYXRlKSAtICQubGFzdFByb2dyZXNzQ2FsbGJhY2sgPiAkLmdldE9wdCgndGhyb3R0bGVQcm9ncmVzc0NhbGxiYWNrcycpICogMTAwMCApIHtcbiAgICAgICAgICAgICQuY2FsbGJhY2soJ3Byb2dyZXNzJyk7XG4gICAgICAgICAgICAkLmxhc3RQcm9ncmVzc0NhbGxiYWNrID0gKG5ldyBEYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJC5sb2FkZWQ9ZS5sb2FkZWR8fDA7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgJC5sb2FkZWQgPSAwO1xuICAgICAgICAkLnBlbmRpbmdSZXRyeSA9IGZhbHNlO1xuICAgICAgICAkLmNhbGxiYWNrKCdwcm9ncmVzcycpO1xuXG4gICAgICAgIC8vIERvbmUgKGVpdGhlciBkb25lLCBmYWlsZWQgb3IgcmV0cnkpXG4gICAgICAgIHZhciBkb25lSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIHZhciBzdGF0dXMgPSAkLnN0YXR1cygpO1xuICAgICAgICAgIGlmKHN0YXR1cz09J3N1Y2Nlc3MnfHxzdGF0dXM9PSdlcnJvcicpIHtcbiAgICAgICAgICAgICQuY2FsbGJhY2soc3RhdHVzLCAkLm1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAkLnJlc3VtYWJsZU9iai51cGxvYWROZXh0Q2h1bmsoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5jYWxsYmFjaygncmV0cnknLCAkLm1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAkLmFib3J0KCk7XG4gICAgICAgICAgICAkLnJldHJpZXMrKztcbiAgICAgICAgICAgIHZhciByZXRyeUludGVydmFsID0gJC5nZXRPcHQoJ2NodW5rUmV0cnlJbnRlcnZhbCcpO1xuICAgICAgICAgICAgaWYocmV0cnlJbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICQucGVuZGluZ1JldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgkLnNlbmQsIHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJC5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZG9uZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgJC54aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBkb25lSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAkLnhoci5hZGRFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgZG9uZUhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGJhc2ljIHF1ZXJ5IGRhdGEgZnJvbSBSZXN1bWFibGVcbiAgICAgICAgdmFyIHF1ZXJ5ID0gW1xuICAgICAgICAgIFsnY2h1bmtOdW1iZXJQYXJhbWV0ZXJOYW1lJywgJC5vZmZzZXQgKyAxXSxcbiAgICAgICAgICBbJ2NodW5rU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmdldE9wdCgnY2h1bmtTaXplJyldLFxuICAgICAgICAgIFsnY3VycmVudENodW5rU2l6ZVBhcmFtZXRlck5hbWUnLCAkLmVuZEJ5dGUgLSAkLnN0YXJ0Qnl0ZV0sXG4gICAgICAgICAgWyd0b3RhbFNpemVQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqU2l6ZV0sXG4gICAgICAgICAgWyd0eXBlUGFyYW1ldGVyTmFtZScsICQuZmlsZU9ialR5cGVdLFxuICAgICAgICAgIFsnaWRlbnRpZmllclBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmoudW5pcXVlSWRlbnRpZmllcl0sXG4gICAgICAgICAgWydmaWxlTmFtZVBhcmFtZXRlck5hbWUnLCAkLmZpbGVPYmouZmlsZU5hbWVdLFxuICAgICAgICAgIFsncmVsYXRpdmVQYXRoUGFyYW1ldGVyTmFtZScsICQuZmlsZU9iai5yZWxhdGl2ZVBhdGhdLFxuICAgICAgICAgIFsndG90YWxDaHVua3NQYXJhbWV0ZXJOYW1lJywgJC5maWxlT2JqLmNodW5rcy5sZW5ndGhdLFxuICAgICAgICBdLmZpbHRlcihmdW5jdGlvbihwYWlyKXtcbiAgICAgICAgICAvLyBpbmNsdWRlIGl0ZW1zIHRoYXQgcmVzb2x2ZSB0byB0cnV0aHkgdmFsdWVzXG4gICAgICAgICAgLy8gaS5lLiBleGNsdWRlIGZhbHNlLCBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICByZXR1cm4gJC5nZXRPcHQocGFpclswXSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ocXVlcnksIHBhaXIpe1xuICAgICAgICAgIC8vIGFzc2lnbiBxdWVyeSBrZXkvdmFsdWVcbiAgICAgICAgICBxdWVyeVskLmdldE9wdChwYWlyWzBdKV0gPSBwYWlyWzFdO1xuICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBNaXggaW4gY3VzdG9tIGRhdGFcbiAgICAgICAgdmFyIGN1c3RvbVF1ZXJ5ID0gJC5nZXRPcHQoJ3F1ZXJ5Jyk7XG4gICAgICAgIGlmKHR5cGVvZiBjdXN0b21RdWVyeSA9PSAnZnVuY3Rpb24nKSBjdXN0b21RdWVyeSA9IGN1c3RvbVF1ZXJ5KCQuZmlsZU9iaiwgJCk7XG4gICAgICAgICRoLmVhY2goY3VzdG9tUXVlcnksIGZ1bmN0aW9uKGssdil7XG4gICAgICAgICAgcXVlcnlba10gPSB2O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZnVuYyA9ICgkLmZpbGVPYmouZmlsZS5zbGljZSA/ICdzbGljZScgOiAoJC5maWxlT2JqLmZpbGUubW96U2xpY2UgPyAnbW96U2xpY2UnIDogKCQuZmlsZU9iai5maWxlLndlYmtpdFNsaWNlID8gJ3dlYmtpdFNsaWNlJyA6ICdzbGljZScpKSk7XG4gICAgICAgIHZhciBieXRlcyA9ICQuZmlsZU9iai5maWxlW2Z1bmNdKCQuc3RhcnRCeXRlLCAkLmVuZEJ5dGUsICQuZ2V0T3B0KCdzZXRDaHVua1R5cGVGcm9tRmlsZScpID8gJC5maWxlT2JqLmZpbGUudHlwZSA6IFwiXCIpO1xuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZXNwYWNlID0gJC5nZXRPcHQoJ3BhcmFtZXRlck5hbWVzcGFjZScpO1xuICAgICAgICAgICAgICAgIGlmICgkLmdldE9wdCgnbWV0aG9kJykgPT09ICdvY3RldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGRhdGEgZnJvbSB0aGUgcXVlcnkgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgICRoLmVhY2gocXVlcnksIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChbZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlck5hbWVzcGFjZSArIGspLCBlbmNvZGVVUklDb21wb25lbnQodildLmpvaW4oJz0nKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBkYXRhIGZyb20gdGhlIHF1ZXJ5IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAkaC5lYWNoKHF1ZXJ5LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQocGFyYW1ldGVyTmFtZXNwYWNlICsgaywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChbZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlck5hbWVzcGFjZSArIGspLCBlbmNvZGVVUklDb21wb25lbnQodildLmpvaW4oJz0nKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJC5nZXRPcHQoJ2NodW5rRm9ybWF0JykgPT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFwcGVuZChwYXJhbWV0ZXJOYW1lc3BhY2UgKyAkLmdldE9wdCgnZmlsZVBhcmFtZXRlck5hbWUnKSwgYnl0ZXMsICQuZmlsZU9iai5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5nZXRPcHQoJ2NodW5rRm9ybWF0JykgPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYXBwZW5kKHBhcmFtZXRlck5hbWVzcGFjZSArICQuZ2V0T3B0KCdmaWxlUGFyYW1ldGVyTmFtZScpLCBmci5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQueGhyLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5yZWFkQXNEYXRhVVJMKGJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0ID0gJGguZ2V0VGFyZ2V0KCd1cGxvYWQnLCBwYXJhbXMpO1xuICAgICAgICB2YXIgbWV0aG9kID0gJC5nZXRPcHQoJ3VwbG9hZE1ldGhvZCcpO1xuXG4gICAgICAgICQueGhyLm9wZW4obWV0aG9kLCB0YXJnZXQpO1xuICAgICAgICBpZiAoJC5nZXRPcHQoJ21ldGhvZCcpID09PSAnb2N0ZXQnKSB7XG4gICAgICAgICAgJC54aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9XG4gICAgICAgICQueGhyLnRpbWVvdXQgPSAkLmdldE9wdCgneGhyVGltZW91dCcpO1xuICAgICAgICAkLnhoci53aXRoQ3JlZGVudGlhbHMgPSAkLmdldE9wdCgnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgICAgIC8vIEFkZCBkYXRhIGZyb20gaGVhZGVyIG9wdGlvbnNcbiAgICAgICAgdmFyIGN1c3RvbUhlYWRlcnMgPSAkLmdldE9wdCgnaGVhZGVycycpO1xuICAgICAgICBpZih0eXBlb2YgY3VzdG9tSGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbUhlYWRlcnMgPSBjdXN0b21IZWFkZXJzKCQuZmlsZU9iaiwgJCk7XG4gICAgICAgIH1cblxuICAgICAgICAkaC5lYWNoKGN1c3RvbUhlYWRlcnMsIGZ1bmN0aW9uKGssdikge1xuICAgICAgICAgICQueGhyLnNldFJlcXVlc3RIZWFkZXIoaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQuZ2V0T3B0KCdjaHVua0Zvcm1hdCcpID09ICdibG9iJykge1xuICAgICAgICAgICAgICAgICAgICAkLnhoci5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICAkLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gQWJvcnQgYW5kIHJlc2V0XG4gICAgICAgIGlmKCQueGhyKSAkLnhoci5hYm9ydCgpO1xuICAgICAgICAkLnhociA9IG51bGw7XG4gICAgICB9O1xuICAgICAgJC5zdGF0dXMgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBSZXR1cm5zOiAncGVuZGluZycsICd1cGxvYWRpbmcnLCAnc3VjY2VzcycsICdlcnJvcidcbiAgICAgICAgaWYoJC5wZW5kaW5nUmV0cnkpIHtcbiAgICAgICAgICAvLyBpZiBwZW5kaW5nIHJldHJ5IHRoZW4gdGhhdCdzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGFjdGl2ZWx5IHVwbG9hZGluZyxcbiAgICAgICAgICAvLyB0aGVyZSBtaWdodCBqdXN0IGJlIGEgc2xpZ2h0IGRlbGF5IGJlZm9yZSB0aGUgcmV0cnkgc3RhcnRzXG4gICAgICAgICAgcmV0dXJuKCd1cGxvYWRpbmcnKTtcbiAgICAgICAgfSBlbHNlIGlmKCEkLnhocikge1xuICAgICAgICAgIHJldHVybigncGVuZGluZycpO1xuICAgICAgICB9IGVsc2UgaWYoJC54aHIucmVhZHlTdGF0ZTw0KSB7XG4gICAgICAgICAgLy8gU3RhdHVzIGlzIHJlYWxseSAnT1BFTkVEJywgJ0hFQURFUlNfUkVDRUlWRUQnIG9yICdMT0FESU5HJyAtIG1lYW5pbmcgdGhhdCBzdHVmZiBpcyBoYXBwZW5pbmdcbiAgICAgICAgICByZXR1cm4oJ3VwbG9hZGluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCQueGhyLnN0YXR1cyA9PSAyMDAgfHwgJC54aHIuc3RhdHVzID09IDIwMSkge1xuICAgICAgICAgICAgLy8gSFRUUCAyMDAsIDIwMSAoY3JlYXRlZClcbiAgICAgICAgICAgIHJldHVybignc3VjY2VzcycpO1xuICAgICAgICAgIH0gZWxzZSBpZigkaC5jb250YWlucygkLmdldE9wdCgncGVybWFuZW50RXJyb3JzJyksICQueGhyLnN0YXR1cykgfHwgJC5yZXRyaWVzID49ICQuZ2V0T3B0KCdtYXhDaHVua1JldHJpZXMnKSkge1xuICAgICAgICAgICAgLy8gSFRUUCA0MTUvNTAwLzUwMSwgcGVybWFuZW50IGVycm9yXG4gICAgICAgICAgICByZXR1cm4oJ2Vycm9yJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IHdlJ2xsIHJlc2V0IGFuZCBxdWV1ZSBhIHJldHJ5XG4gICAgICAgICAgICAvLyBhIGxpa2VseSBjYXNlIGZvciB0aGlzIHdvdWxkIGJlIDUwMyBzZXJ2aWNlIHVuYXZhaWxhYmxlXG4gICAgICAgICAgICAkLmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm4oJ3BlbmRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAkLm1lc3NhZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4oJC54aHIgPyAkLnhoci5yZXNwb25zZVRleHQgOiAnJyk7XG4gICAgICB9O1xuICAgICAgJC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHJlbGF0aXZlKXtcbiAgICAgICAgaWYodHlwZW9mKHJlbGF0aXZlKT09PSd1bmRlZmluZWQnKSByZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZmFjdG9yID0gKHJlbGF0aXZlID8gKCQuZW5kQnl0ZS0kLnN0YXJ0Qnl0ZSkvJC5maWxlT2JqU2l6ZSA6IDEpO1xuICAgICAgICBpZigkLnBlbmRpbmdSZXRyeSkgcmV0dXJuKDApO1xuICAgICAgICBpZighJC54aHIgfHwgISQueGhyLnN0YXR1cykgZmFjdG9yKj0uOTU7XG4gICAgICAgIHZhciBzID0gJC5zdGF0dXMoKTtcbiAgICAgICAgc3dpdGNoKHMpe1xuICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIHJldHVybigxKmZhY3Rvcik7XG4gICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgIHJldHVybigwKmZhY3Rvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuKCQubG9hZGVkLygkLmVuZEJ5dGUtJC5zdGFydEJ5dGUpKmZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4odGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUVVFVUVcbiAgICAkLnVwbG9hZE5leHRDaHVuayA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgLy8gSW4gc29tZSBjYXNlcyAoc3VjaCBhcyB2aWRlb3MpIGl0J3MgcmVhbGx5IGhhbmR5IHRvIHVwbG9hZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IGNodW5rIG9mIGEgZmlsZSBxdWlja2x5OyB0aGlzIGxldCdzIHRoZSBzZXJ2ZXIgY2hlY2sgdGhlIGZpbGUnc1xuICAgICAgLy8gbWV0YWRhdGEgYW5kIGRldGVybWluZSBpZiB0aGVyZSdzIGV2ZW4gYSBwb2ludCBpbiBjb250aW51aW5nLlxuICAgICAgaWYgKCQuZ2V0T3B0KCdwcmlvcml0aXplRmlyc3RBbmRMYXN0Q2h1bmsnKSkge1xuICAgICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICAgIGlmKGZpbGUuY2h1bmtzLmxlbmd0aCAmJiBmaWxlLmNodW5rc1swXS5zdGF0dXMoKT09J3BlbmRpbmcnICYmIGZpbGUuY2h1bmtzWzBdLnByZXByb2Nlc3NTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZmlsZS5jaHVua3NbMF0uc2VuZCgpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZmlsZS5jaHVua3MubGVuZ3RoPjEgJiYgZmlsZS5jaHVua3NbZmlsZS5jaHVua3MubGVuZ3RoLTFdLnN0YXR1cygpPT0ncGVuZGluZycgJiYgZmlsZS5jaHVua3NbZmlsZS5jaHVua3MubGVuZ3RoLTFdLnByZXByb2Nlc3NTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZmlsZS5jaHVua3NbZmlsZS5jaHVua3MubGVuZ3RoLTFdLnNlbmQoKTtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYoZm91bmQpIHJldHVybih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBzaW1wbHkgbG9vayBmb3IgdGhlIG5leHQsIGJlc3QgdGhpbmcgdG8gdXBsb2FkXG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICBpZihmaWxlLmlzUGF1c2VkKCk9PT1mYWxzZSl7XG4gICAgICAgICAkaC5lYWNoKGZpbGUuY2h1bmtzLCBmdW5jdGlvbihjaHVuayl7XG4gICAgICAgICAgIGlmKGNodW5rLnN0YXR1cygpPT0ncGVuZGluZycgJiYgY2h1bmsucHJlcHJvY2Vzc1N0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgY2h1bmsuc2VuZCgpO1xuICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICByZXR1cm4oZmFsc2UpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZm91bmQpIHJldHVybihmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIGlmKGZvdW5kKSByZXR1cm4odHJ1ZSk7XG5cbiAgICAgIC8vIFRoZSBhcmUgbm8gbW9yZSBvdXRzdGFuZGluZyBjaHVua3MgdG8gdXBsb2FkLCBjaGVjayBpcyBldmVyeXRoaW5nIGlzIGRvbmVcbiAgICAgIHZhciBvdXRzdGFuZGluZyA9IGZhbHNlO1xuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgaWYoIWZpbGUuaXNDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgb3V0c3RhbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYoIW91dHN0YW5kaW5nKSB7XG4gICAgICAgIC8vIEFsbCBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkLCBjb21wbGV0ZVxuICAgICAgICAkLmZpcmUoJ2NvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4oZmFsc2UpO1xuICAgIH07XG5cblxuICAgIC8vIFBVQkxJQyBNRVRIT0RTIEZPUiBSRVNVTUFCTEUuSlNcbiAgICAkLmFzc2lnbkJyb3dzZSA9IGZ1bmN0aW9uKGRvbU5vZGVzLCBpc0RpcmVjdG9yeSl7XG4gICAgICBpZih0eXBlb2YoZG9tTm9kZXMubGVuZ3RoKT09J3VuZGVmaW5lZCcpIGRvbU5vZGVzID0gW2RvbU5vZGVzXTtcblxuICAgICAgJGguZWFjaChkb21Ob2RlcywgZnVuY3Rpb24oZG9tTm9kZSkge1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIGlmKGRvbU5vZGUudGFnTmFtZT09PSdJTlBVVCcgJiYgZG9tTm9kZS50eXBlPT09J2ZpbGUnKXtcbiAgICAgICAgICBpbnB1dCA9IGRvbU5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdmaWxlJyk7XG4gICAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheT0nYmxvY2snO1xuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICBpbnB1dC5zdHlsZS5kaXNwbGF5PSdub25lJztcbiAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgZG9tTm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heEZpbGVzID0gJC5nZXRPcHQoJ21heEZpbGVzJyk7XG4gICAgICAgIGlmICh0eXBlb2YobWF4RmlsZXMpPT09J3VuZGVmaW5lZCd8fG1heEZpbGVzIT0xKXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdtdWx0aXBsZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGlzRGlyZWN0b3J5KXtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3dlYmtpdGRpcmVjdG9yeScsICd3ZWJraXRkaXJlY3RvcnknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ3dlYmtpdGRpcmVjdG9yeScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWxlVHlwZXMgPSAkLmdldE9wdCgnZmlsZVR5cGUnKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZmlsZVR5cGVzKSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZVR5cGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCBmaWxlVHlwZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAnLicgKyBlIH0pLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhY2NlcHQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG5ldyBmaWxlcyBhcmUgYWRkZWQsIHNpbXBseSBhcHBlbmQgdGhlbSB0byB0aGUgb3ZlcmFsbCBsaXN0XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0KGUudGFyZ2V0LmZpbGVzLGUpO1xuICAgICAgICAgIHZhciBjbGVhcklucHV0ID0gJC5nZXRPcHQoJ2NsZWFySW5wdXQnKTtcbiAgICAgICAgICBpZiAoY2xlYXJJbnB1dCkge1xuICAgICAgICAgICAgZS50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJC5hc3NpZ25Ecm9wID0gZnVuY3Rpb24oZG9tTm9kZXMpe1xuICAgICAgaWYodHlwZW9mKGRvbU5vZGVzLmxlbmd0aCk9PSd1bmRlZmluZWQnKSBkb21Ob2RlcyA9IFtkb21Ob2Rlc107XG5cbiAgICAgICRoLmVhY2goZG9tTm9kZXMsIGZ1bmN0aW9uKGRvbU5vZGUpIHtcbiAgICAgICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcbiAgICAgICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgb25Ecm9wLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgICQudW5Bc3NpZ25Ecm9wID0gZnVuY3Rpb24oZG9tTm9kZXMpIHtcbiAgICAgIGlmICh0eXBlb2YoZG9tTm9kZXMubGVuZ3RoKSA9PSAndW5kZWZpbmVkJykgZG9tTm9kZXMgPSBbZG9tTm9kZXNdO1xuXG4gICAgICAkaC5lYWNoKGRvbU5vZGVzLCBmdW5jdGlvbihkb21Ob2RlKSB7XG4gICAgICAgIGRvbU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIGRvbU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgcHJldmVudERlZmF1bHQpO1xuICAgICAgICBkb21Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBvbkRyb3ApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAkLmlzVXBsb2FkaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciB1cGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICRoLmVhY2goJC5maWxlcywgZnVuY3Rpb24oZmlsZSl7XG4gICAgICAgIGlmIChmaWxlLmlzVXBsb2FkaW5nKCkpIHtcbiAgICAgICAgICB1cGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuKHVwbG9hZGluZyk7XG4gICAgfTtcbiAgICAkLnVwbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3Qgc3RhcnQgdG9vIG1hbnkgdXBsb2FkcyBhdCBvbmNlXG4gICAgICBpZigkLmlzVXBsb2FkaW5nKCkpIHJldHVybjtcbiAgICAgIC8vIEtpY2sgb2ZmIHRoZSBxdWV1ZVxuICAgICAgJC5maXJlKCd1cGxvYWRTdGFydCcpO1xuICAgICAgZm9yICh2YXIgbnVtPTE7IG51bTw9JC5nZXRPcHQoJ3NpbXVsdGFuZW91c1VwbG9hZHMnKTsgbnVtKyspIHtcbiAgICAgICAgJC51cGxvYWROZXh0Q2h1bmsoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICQucGF1c2UgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gUmVzdW1lIGFsbCBjaHVua3MgY3VycmVudGx5IGJlaW5nIHVwbG9hZGVkXG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICBmaWxlLmFib3J0KCk7XG4gICAgICB9KTtcbiAgICAgICQuZmlyZSgncGF1c2UnKTtcbiAgICB9O1xuICAgICQuY2FuY2VsID0gZnVuY3Rpb24oKXtcbiAgICAgICQuZmlyZSgnYmVmb3JlQ2FuY2VsJyk7XG4gICAgICBmb3IodmFyIGkgPSAkLmZpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICQuZmlsZXNbaV0uY2FuY2VsKCk7XG4gICAgICB9XG4gICAgICAkLmZpcmUoJ2NhbmNlbCcpO1xuICAgIH07XG4gICAgJC5wcm9ncmVzcyA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdG90YWxEb25lID0gMDtcbiAgICAgIHZhciB0b3RhbFNpemUgPSAwO1xuICAgICAgLy8gUmVzdW1lIGFsbCBjaHVua3MgY3VycmVudGx5IGJlaW5nIHVwbG9hZGVkXG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICB0b3RhbERvbmUgKz0gZmlsZS5wcm9ncmVzcygpKmZpbGUuc2l6ZTtcbiAgICAgICAgdG90YWxTaXplICs9IGZpbGUuc2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuKHRvdGFsU2l6ZT4wID8gdG90YWxEb25lL3RvdGFsU2l6ZSA6IDApO1xuICAgIH07XG4gICAgJC5hZGRGaWxlID0gZnVuY3Rpb24oZmlsZSwgZXZlbnQpe1xuICAgICAgYXBwZW5kRmlsZXNGcm9tRmlsZUxpc3QoW2ZpbGVdLCBldmVudCk7XG4gICAgfTtcbiAgICAkLmFkZEZpbGVzID0gZnVuY3Rpb24oZmlsZXMsIGV2ZW50KXtcbiAgICAgIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0KGZpbGVzLCBldmVudCk7XG4gICAgfTtcbiAgICAkLnJlbW92ZUZpbGUgPSBmdW5jdGlvbihmaWxlKXtcbiAgICAgIGZvcih2YXIgaSA9ICQuZmlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYoJC5maWxlc1tpXSA9PT0gZmlsZSkge1xuICAgICAgICAgICQuZmlsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAkLmdldEZyb21VbmlxdWVJZGVudGlmaWVyID0gZnVuY3Rpb24odW5pcXVlSWRlbnRpZmllcil7XG4gICAgICB2YXIgcmV0ID0gZmFsc2U7XG4gICAgICAkaC5lYWNoKCQuZmlsZXMsIGZ1bmN0aW9uKGYpe1xuICAgICAgICBpZihmLnVuaXF1ZUlkZW50aWZpZXI9PXVuaXF1ZUlkZW50aWZpZXIpIHJldCA9IGY7XG4gICAgICB9KTtcbiAgICAgIHJldHVybihyZXQpO1xuICAgIH07XG4gICAgJC5nZXRTaXplID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0b3RhbFNpemUgPSAwO1xuICAgICAgJGguZWFjaCgkLmZpbGVzLCBmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgdG90YWxTaXplICs9IGZpbGUuc2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuKHRvdGFsU2l6ZSk7XG4gICAgfTtcbiAgICAkLmhhbmRsZURyb3BFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBvbkRyb3AoZSk7XG4gICAgfTtcbiAgICAkLmhhbmRsZUNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGFwcGVuZEZpbGVzRnJvbUZpbGVMaXN0KGUudGFyZ2V0LmZpbGVzLCBlKTtcbiAgICAgIGUudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgfTtcbiAgICAkLnVwZGF0ZVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpe1xuICAgICAgICAkLm9wdHMucXVlcnkgPSBxdWVyeTtcbiAgICB9O1xuXG4gICAgcmV0dXJuKHRoaXMpO1xuICB9O1xuXG5cbiAgLy8gTm9kZS5qcy1zdHlsZSBleHBvcnQgZm9yIE5vZGUgYW5kIENvbXBvbmVudFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUmVzdW1hYmxlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EL3JlcXVpcmVqczogRGVmaW5lIHRoZSBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBSZXN1bWFibGU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuICAgIHdpbmRvdy5SZXN1bWFibGUgPSBSZXN1bWFibGU7XG4gIH1cblxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/resumablejs/resumable.js\n");

/***/ }),

/***/ "./src/lib/components/Upload.react.js":
/*!********************************************!*\
  !*** ./src/lib/components/Upload.react.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _resumablejs = __webpack_require__(/*! resumablejs */ \"./node_modules/resumablejs/resumable.js\");\n\nvar _resumablejs2 = _interopRequireDefault(_resumablejs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Upload = function (_Component) {\n    _inherits(Upload, _Component);\n\n    function Upload(props) {\n        _classCallCheck(this, Upload);\n\n        var _this = _possibleConstructorReturn(this, (Upload.__proto__ || Object.getPrototypeOf(Upload)).call(this, props));\n\n        _this.state = {\n            progressBar: 0,\n            messageStatus: '',\n            fileList: { files: [] },\n            isPaused: false,\n            isUploading: false,\n            isHovered: false,\n            isComplete: false\n        };\n        _this.toggleHovered = _this.toggleHovered.bind(_this);\n        _this.cancelUpload = _this.cancelUpload.bind(_this);\n        _this.pauseUpload = _this.pauseUpload.bind(_this);\n        _this.startUpload = _this.startUpload.bind(_this);\n        _this.resumable = null;\n        return _this;\n    }\n\n    _createClass(Upload, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            var _this2 = this;\n\n            var ResumableField = new _resumablejs2.default({\n                target: this.props.service,\n                query: {},\n                fileType: this.props.filetypes,\n                maxFiles: this.props.maxFiles,\n                maxFileSize: this.props.maxFileSize,\n                fileTypeErrorCallback: function fileTypeErrorCallback() {\n                    _this2.setState({\n                        messageStatus: 'Invalid file type!'\n                    });\n                },\n                testMethod: 'post',\n                testChunks: false,\n                headers: {},\n                chunkSize: this.props.chunkSize,\n                simultaneousUploads: this.props.simultaneousUploads,\n                forceChunkSize: false\n            });\n\n            ResumableField.assignBrowse(this.uploader);\n\n            //Enable or Disable DragAnd Drop\n            if (this.props.disableDragAndDrop === false) {\n                ResumableField.assignDrop(this.dropZone);\n            }\n\n            ResumableField.on('fileAdded', function (file) {\n                _this2.setState({\n                    messageStatus: _this2.props.fileAddedMessage || ' Starting upload! of ' + file.fileName,\n                    isComplete: false\n                });\n\n                if (typeof _this2.props.onFileAdded === 'function') {\n                    _this2.props.onFileAdded(file, _this2.resumable);\n                } else {\n                    ResumableField.upload();\n                }\n            });\n\n            ResumableField.on('fileSuccess', function (file, fileServer) {\n\n                if (_this2.props.fileNameServer) {\n                    var objectServer = JSON.parse(fileServer);\n                    file.fileName = objectServer[_this2.props.fileNameServer];\n                } else {\n                    file.fileName = fileServer;\n                }\n                var currentFiles = _this2.state.fileList.files;\n                currentFiles.push(file);\n\n                var fileNames = _this2.props.fileNames;\n                fileNames.push(file.fileName);\n\n                if (_this2.props.setProps) {\n                    _this2.props.setProps({\n                        fileNames: fileNames\n                    });\n                }\n                _this2.setState({\n                    fileList: { files: currentFiles },\n                    isComplete: true,\n                    messageStatus: _this2.props.completedMessage + file.fileName || fileServer\n                }, function () {\n                    if (typeof _this2.props.onFileSuccess === 'function') {\n                        _this2.props.onFileSuccess(file, fileServer);\n                    }\n                });\n            });\n\n            ResumableField.on('progress', function () {\n\n                _this2.setState({\n                    isUploading: ResumableField.isUploading()\n                });\n\n                if (ResumableField.progress() * 100 < 100) {\n                    _this2.setState({\n                        messageStatus: parseInt(ResumableField.progress() * 100, 10) + '%',\n                        progressBar: ResumableField.progress() * 100\n                    });\n                } else {\n                    setTimeout(function () {\n                        _this2.setState({\n                            progressBar: 0\n                        });\n                    }, 1000);\n                }\n            });\n\n            ResumableField.on('fileError', function (file, errorCount) {\n                _this2.props.onUploadErrorCallback(file, errorCount);\n            });\n\n            this.resumable = ResumableField;\n        }\n    }, {\n        key: 'cancelUpload',\n        value: function cancelUpload() {\n            this.resumable.cancel();\n\n            this.setState({\n                fileList: { files: [] }\n            });\n        }\n    }, {\n        key: 'pauseUpload',\n        value: function pauseUpload() {\n            if (!this.state.isPaused) {\n                this.resumable.pause();\n                this.setState({\n                    isPaused: true,\n                    isUploading: true\n                });\n            } else {\n                this.resumable.upload();\n                this.setState({\n                    isPaused: false,\n                    isUploading: true\n                });\n            }\n        }\n    }, {\n        key: 'startUpload',\n        value: function startUpload() {\n            this.setState({\n                isPaused: false\n            });\n        }\n    }, {\n        key: 'toggleHovered',\n        value: function toggleHovered() {\n            this.setState({\n                isHovered: !this.state.isHovered\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this3 = this;\n\n            var fileList = null;\n\n            var textLabel = null;\n            if (this.props.textLabel) {\n                textLabel = this.props.textLabel;\n            }\n\n            var startButton = null;\n            if (this.props.startButton) {\n                if (typeof this.props.startButton === 'string' || typeof this.props.startButton === 'boolean') startButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: this.state.isUploading,\n                            className: 'resumable-btn-start',\n                            onClick: this.startUpload },\n                        this.props.startButton && 'upload'\n                    )\n                );else startButton = this.props.startButton;\n            }\n\n            var cancelButton = null;\n            if (this.props.cancelButton) {\n                if (typeof this.props.cancelButton === 'string' || typeof this.props.cancelButton === 'boolean') cancelButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: !this.state.isUploading,\n                            className: 'resumable-btn-cancel',\n                            onClick: this.cancelUpload },\n                        this.props.cancelButton && 'cancel'\n                    )\n                );else cancelButton = this.props.cancelButton;\n            }\n\n            var pauseButton = null;\n            if (this.props.pauseButton) {\n                if (typeof this.props.pauseButton === 'string' || typeof this.props.pauseButton === 'boolean') pauseButton = _react2.default.createElement(\n                    'label',\n                    null,\n                    _react2.default.createElement(\n                        'button',\n                        {\n                            disabled: !this.state.isUploading,\n                            className: 'resumable-btn-pause',\n                            onClick: this.pauseUpload },\n                        this.props.pauseButton && (this.state.isPaused ? 'resume' : 'pause')\n                    )\n                );else pauseButton = this.props.pauseButton;\n            }\n\n            var getStyle = function getStyle() {\n                if (_this3.state.isComplete) {\n                    return _this3.props.completeStyle;\n                } else if (_this3.state.isHovered || _this3.state.isUploading) {\n                    return _this3.props.activeStyle;\n                } else {\n                    return _this3.props.defaultStyle;\n                }\n            };\n\n            var getClass = function getClass() {\n                if (_this3.props.disabledInput) {\n                    return _this3.props.disableClass;\n                } else if (_this3.state.isHovered) {\n                    return _this3.props.hoveredClass;\n                } else if (_this3.state.isUploading) {\n                    return _this3.props.uploadingClass;\n                } else if (_this3.state.isComplete) {\n                    return _this3.props.completeClass;\n                } else if (_this3.state.isPaused) {\n                    return _this3.props.completeClass;\n                } else {\n                    return _this3.props.className;\n                }\n            };\n\n            return _react2.default.createElement(\n                'div',\n                { id: this.props.id, className: getClass(), ref: function ref(node) {\n                        return _this3.dropZone = node;\n                    } },\n                _react2.default.createElement(\n                    'label',\n                    {\n                        style: getStyle(),\n                        onMouseEnter: this.toggleHovered,\n                        onMouseLeave: this.toggleHovered\n                    },\n                    this.state.messageStatus == '' ? textLabel : this.state.messageStatus,\n                    _react2.default.createElement('input', {\n                        ref: function ref(node) {\n                            return _this3.uploader = node;\n                        },\n                        type: 'file',\n                        className: 'btn',\n                        name: this.props.id + '-upload',\n                        accept: this.props.fileAccept || '*',\n                        disabled: this.props.disableInput || false,\n                        style: { 'opacity': '0',\n                            'width': '0.1px%',\n                            'height': '0.1px%',\n                            'position': 'absolute',\n                            'overflow': 'hidden',\n                            'z-index': '-1' }\n                    })\n                ),\n                _react2.default.createElement(\n                    'div',\n                    { className: 'progress',\n                        style: {\n                            display: this.state.progressBar === 0 ? 'none' : 'block'\n                        } },\n                    _react2.default.createElement('div', { className: 'progress-bar',\n                        style: {\n                            width: this.state.progressBar + '%',\n                            height: '100%'\n                        } })\n                ),\n                fileList,\n                startButton,\n                pauseButton,\n                cancelButton\n            );\n        }\n    }]);\n\n    return Upload;\n}(_react.Component);\n\nexports.default = Upload;\n\n\nUpload.propTypes = {\n    /**\n     * Maximum number of files that can be uploaded in one session\n     */\n    maxFiles: _react.PropTypes.number,\n\n    /**\n     * Maximum size per file in bytes.\n     */\n    maxFileSize: _react.PropTypes.number,\n\n    /**\n     * Size of file chunks to send to server.\n     */\n    chunkSize: _react.PropTypes.number,\n\n    /**\n     * Number of simultaneous uploads to select\n     */\n    simultaneousUploads: _react.PropTypes.number,\n\n    /**\n     * The service to send the files to\n     */\n    service: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component by default\n     */\n    className: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component when it is hovered\n     */\n    hoveredClass: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component when it is disabled\n     */\n    disabledClass: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component when it is paused\n     */\n    pausedClass: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component when it is complete\n     */\n    completeClass: _react.PropTypes.string,\n\n    /**\n     * Class to add to the upload component when it is uploading\n     */\n    uploadingClass: _react.PropTypes.string,\n\n    /**\n     * Style attributes to add to the upload component\n     */\n    defaultStyle: _react.PropTypes.object,\n\n    /**\n     * Style when upload component is hovered over\n     */\n    activeStyle: _react.PropTypes.object,\n\n    /**\n     * Style when upload is completed (upload finished)\n     */\n    completeStyle: _react.PropTypes.object,\n\n    /**\n     * The string to display in the upload component\n     */\n    textLabel: _react.PropTypes.string,\n\n    /**\n     * Message to display when upload completed\n     */\n    completedMessage: _react.PropTypes.string,\n\n    /**\n     * The names of the files uploaded\n     */\n    fileNames: _react.PropTypes.arrayOf(_react.PropTypes.string),\n\n    /**\n     * List of allowed file types, e.g. ['jpg', 'png']\n     */\n    filetypes: _react.PropTypes.arrayOf(_react.PropTypes.string),\n\n    /**\n     * Whether or not to have a start button\n     */\n    startButton: _react.PropTypes.bool,\n\n    /**\n     * Whether or not to have a pause button\n     */\n    pauseButton: _react.PropTypes.bool,\n\n    /**\n     * Whether or not to have a cancel button\n     */\n    cancelButton: _react.PropTypes.bool,\n\n    /**\n     * Whether or not to allow file drag and drop\n     */\n    disableDragAndDrop: _react.PropTypes.bool,\n\n    /**\n     * Dash-supplied function for updating props\n     */\n    setProps: _react.PropTypes.func,\n\n    /**\n     * User supplied id of this component\n     */\n    id: _react.PropTypes.string\n\n};\n\nUpload.defaultProps = {\n    maxFiles: 1,\n    maxFileSize: 1024 * 1024 * 10,\n    chunkSize: 1024 * 1024,\n    simultaneuosUploads: 1,\n    service: '/upload',\n    className: 'resumable-default',\n    hoveredClass: 'resumable-hovered',\n    completeClass: 'resumable-complete',\n    disabledClass: 'resumable-disabled',\n    pausedClass: 'resumable-paused',\n    uploadingClass: 'resumable-uploading',\n    defaultStyle: {},\n    activeStyle: {},\n    completeStyle: {},\n    textLabel: 'Click Here to Select a File',\n    completedMessage: 'Complete! ',\n    fileNames: [],\n    filetypes: undefined,\n    startButton: true,\n    pauseButton: true,\n    cancelButton: true,\n    disableDragAndDrop: false,\n    id: 'default-uploader-id'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZC8uL3NyYy9saWIvY29tcG9uZW50cy9VcGxvYWQucmVhY3QuanM/NDgyMSJdLCJuYW1lcyI6WyJVcGxvYWQiLCJwcm9wcyIsInN0YXRlIiwicHJvZ3Jlc3NCYXIiLCJtZXNzYWdlU3RhdHVzIiwiZmlsZUxpc3QiLCJmaWxlcyIsImlzUGF1c2VkIiwiaXNVcGxvYWRpbmciLCJpc0hvdmVyZWQiLCJpc0NvbXBsZXRlIiwidG9nZ2xlSG92ZXJlZCIsImJpbmQiLCJjYW5jZWxVcGxvYWQiLCJwYXVzZVVwbG9hZCIsInN0YXJ0VXBsb2FkIiwicmVzdW1hYmxlIiwiUmVzdW1hYmxlRmllbGQiLCJSZXN1bWFibGVqcyIsInRhcmdldCIsInNlcnZpY2UiLCJxdWVyeSIsImZpbGVUeXBlIiwiZmlsZXR5cGVzIiwibWF4RmlsZXMiLCJtYXhGaWxlU2l6ZSIsImZpbGVUeXBlRXJyb3JDYWxsYmFjayIsInNldFN0YXRlIiwidGVzdE1ldGhvZCIsInRlc3RDaHVua3MiLCJoZWFkZXJzIiwiY2h1bmtTaXplIiwic2ltdWx0YW5lb3VzVXBsb2FkcyIsImZvcmNlQ2h1bmtTaXplIiwiYXNzaWduQnJvd3NlIiwidXBsb2FkZXIiLCJkaXNhYmxlRHJhZ0FuZERyb3AiLCJhc3NpZ25Ecm9wIiwiZHJvcFpvbmUiLCJvbiIsImZpbGUiLCJmaWxlQWRkZWRNZXNzYWdlIiwiZmlsZU5hbWUiLCJvbkZpbGVBZGRlZCIsInVwbG9hZCIsImZpbGVTZXJ2ZXIiLCJmaWxlTmFtZVNlcnZlciIsIm9iamVjdFNlcnZlciIsIkpTT04iLCJwYXJzZSIsImN1cnJlbnRGaWxlcyIsInB1c2giLCJmaWxlTmFtZXMiLCJzZXRQcm9wcyIsImNvbXBsZXRlZE1lc3NhZ2UiLCJvbkZpbGVTdWNjZXNzIiwicHJvZ3Jlc3MiLCJwYXJzZUludCIsInNldFRpbWVvdXQiLCJlcnJvckNvdW50Iiwib25VcGxvYWRFcnJvckNhbGxiYWNrIiwiY2FuY2VsIiwicGF1c2UiLCJ0ZXh0TGFiZWwiLCJzdGFydEJ1dHRvbiIsImNhbmNlbEJ1dHRvbiIsInBhdXNlQnV0dG9uIiwiZ2V0U3R5bGUiLCJjb21wbGV0ZVN0eWxlIiwiYWN0aXZlU3R5bGUiLCJkZWZhdWx0U3R5bGUiLCJnZXRDbGFzcyIsImRpc2FibGVkSW5wdXQiLCJkaXNhYmxlQ2xhc3MiLCJob3ZlcmVkQ2xhc3MiLCJ1cGxvYWRpbmdDbGFzcyIsImNvbXBsZXRlQ2xhc3MiLCJjbGFzc05hbWUiLCJpZCIsIm5vZGUiLCJmaWxlQWNjZXB0IiwiZGlzYWJsZUlucHV0IiwiZGlzcGxheSIsIndpZHRoIiwiaGVpZ2h0IiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwibnVtYmVyIiwic3RyaW5nIiwiZGlzYWJsZWRDbGFzcyIsInBhdXNlZENsYXNzIiwib2JqZWN0IiwiYXJyYXlPZiIsImJvb2wiLCJmdW5jIiwiZGVmYXVsdFByb3BzIiwic2ltdWx0YW5ldW9zVXBsb2FkcyIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFcUJBLE07OztBQUNqQixvQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBLG9IQUNUQSxLQURTOztBQUVmLGNBQUtDLEtBQUwsR0FBYTtBQUNUQyx5QkFBYSxDQURKO0FBRVRDLDJCQUFlLEVBRk47QUFHVEMsc0JBQVUsRUFBQ0MsT0FBTyxFQUFSLEVBSEQ7QUFJVEMsc0JBQVUsS0FKRDtBQUtUQyx5QkFBYSxLQUxKO0FBTVRDLHVCQUFXLEtBTkY7QUFPVEMsd0JBQVk7QUFQSCxTQUFiO0FBU0EsY0FBS0MsYUFBTCxHQUFxQixNQUFLQSxhQUFMLENBQW1CQyxJQUFuQixPQUFyQjtBQUNBLGNBQUtDLFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQkQsSUFBbEIsT0FBcEI7QUFDQSxjQUFLRSxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJGLElBQWpCLE9BQW5CO0FBQ0EsY0FBS0csV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCSCxJQUFqQixPQUFuQjtBQUNBLGNBQUtJLFNBQUwsR0FBaUIsSUFBakI7QUFmZTtBQWdCbEI7Ozs7NENBRW1CO0FBQUE7O0FBRWhCLGdCQUFNQyxpQkFBaUIsSUFBSUMscUJBQUosQ0FBZ0I7QUFDbkNDLHdCQUFRLEtBQUtsQixLQUFMLENBQVdtQixPQURnQjtBQUVuQ0MsdUJBQU8sRUFGNEI7QUFHbkNDLDBCQUFVLEtBQUtyQixLQUFMLENBQVdzQixTQUhjO0FBSW5DQywwQkFBVSxLQUFLdkIsS0FBTCxDQUFXdUIsUUFKYztBQUtuQ0MsNkJBQWEsS0FBS3hCLEtBQUwsQ0FBV3dCLFdBTFc7QUFNbkNDLHVDQUF1QixpQ0FBTTtBQUN6QiwyQkFBS0MsUUFBTCxDQUFjO0FBQ1Z2Qix1Q0FBZTtBQURMLHFCQUFkO0FBR0gsaUJBVmtDO0FBV25Dd0IsNEJBQVksTUFYdUI7QUFZbkNDLDRCQUFZLEtBWnVCO0FBYW5DQyx5QkFBUyxFQWIwQjtBQWNuQ0MsMkJBQVcsS0FBSzlCLEtBQUwsQ0FBVzhCLFNBZGE7QUFlbkNDLHFDQUFxQixLQUFLL0IsS0FBTCxDQUFXK0IsbUJBZkc7QUFnQm5DQyxnQ0FBZ0I7QUFoQm1CLGFBQWhCLENBQXZCOztBQW1CQWhCLDJCQUFlaUIsWUFBZixDQUE0QixLQUFLQyxRQUFqQzs7QUFFQTtBQUNBLGdCQUFJLEtBQUtsQyxLQUFMLENBQVdtQyxrQkFBWCxLQUFrQyxLQUF0QyxFQUE2QztBQUN6Q25CLCtCQUFlb0IsVUFBZixDQUEwQixLQUFLQyxRQUEvQjtBQUNIOztBQUVEckIsMkJBQWVzQixFQUFmLENBQWtCLFdBQWxCLEVBQStCLFVBQUNDLElBQUQsRUFBVTtBQUNyQyx1QkFBS2IsUUFBTCxDQUFjO0FBQ1Z2QixtQ0FBZSxPQUFLSCxLQUFMLENBQVd3QyxnQkFBWCxJQUErQiwwQkFBMEJELEtBQUtFLFFBRG5FO0FBRVZoQyxnQ0FBWTtBQUZGLGlCQUFkOztBQUtDLG9CQUFJLE9BQU8sT0FBS1QsS0FBTCxDQUFXMEMsV0FBbEIsS0FBa0MsVUFBdEMsRUFBa0Q7QUFDOUMsMkJBQUsxQyxLQUFMLENBQVcwQyxXQUFYLENBQXVCSCxJQUF2QixFQUE2QixPQUFLeEIsU0FBbEM7QUFDSCxpQkFGRCxNQUVPO0FBQ0hDLG1DQUFlMkIsTUFBZjtBQUNIO0FBQ0wsYUFYRDs7QUFhQTNCLDJCQUFlc0IsRUFBZixDQUFrQixhQUFsQixFQUFpQyxVQUFDQyxJQUFELEVBQU9LLFVBQVAsRUFBc0I7O0FBRW5ELG9CQUFJLE9BQUs1QyxLQUFMLENBQVc2QyxjQUFmLEVBQStCO0FBQzNCLHdCQUFJQyxlQUFlQyxLQUFLQyxLQUFMLENBQVdKLFVBQVgsQ0FBbkI7QUFDQUwseUJBQUtFLFFBQUwsR0FBZ0JLLGFBQWEsT0FBSzlDLEtBQUwsQ0FBVzZDLGNBQXhCLENBQWhCO0FBQ0gsaUJBSEQsTUFHTztBQUNITix5QkFBS0UsUUFBTCxHQUFnQkcsVUFBaEI7QUFDSDtBQUNELG9CQUFJSyxlQUFlLE9BQUtoRCxLQUFMLENBQVdHLFFBQVgsQ0FBb0JDLEtBQXZDO0FBQ0E0Qyw2QkFBYUMsSUFBYixDQUFrQlgsSUFBbEI7O0FBRUEsb0JBQUlZLFlBQVksT0FBS25ELEtBQUwsQ0FBV21ELFNBQTNCO0FBQ0FBLDBCQUFVRCxJQUFWLENBQWVYLEtBQUtFLFFBQXBCOztBQUVBLG9CQUFJLE9BQUt6QyxLQUFMLENBQVdvRCxRQUFmLEVBQXlCO0FBQ3JCLDJCQUFLcEQsS0FBTCxDQUFXb0QsUUFBWCxDQUFvQjtBQUNkRCxtQ0FBV0E7QUFERyxxQkFBcEI7QUFHSDtBQUNELHVCQUFLekIsUUFBTCxDQUFjO0FBQ1Z0Qiw4QkFBVSxFQUFDQyxPQUFPNEMsWUFBUixFQURBO0FBRVZ4QyxnQ0FBWSxJQUZGO0FBR1ZOLG1DQUFlLE9BQUtILEtBQUwsQ0FBV3FELGdCQUFYLEdBQThCZCxLQUFLRSxRQUFuQyxJQUErQ0c7QUFIcEQsaUJBQWQsRUFJRyxZQUFNO0FBQ0wsd0JBQUksT0FBTyxPQUFLNUMsS0FBTCxDQUFXc0QsYUFBbEIsS0FBb0MsVUFBeEMsRUFBb0Q7QUFDaEQsK0JBQUt0RCxLQUFMLENBQVdzRCxhQUFYLENBQXlCZixJQUF6QixFQUErQkssVUFBL0I7QUFDSDtBQUNKLGlCQVJEO0FBU0gsYUE1QkQ7O0FBOEJBNUIsMkJBQWVzQixFQUFmLENBQWtCLFVBQWxCLEVBQThCLFlBQU07O0FBR2hDLHVCQUFLWixRQUFMLENBQWM7QUFDVm5CLGlDQUFhUyxlQUFlVCxXQUFmO0FBREgsaUJBQWQ7O0FBSUEsb0JBQUtTLGVBQWV1QyxRQUFmLEtBQTRCLEdBQTdCLEdBQW9DLEdBQXhDLEVBQTZDO0FBQ3pDLDJCQUFLN0IsUUFBTCxDQUFjO0FBQ1Z2Qix1Q0FBZXFELFNBQVN4QyxlQUFldUMsUUFBZixLQUE0QixHQUFyQyxFQUEwQyxFQUExQyxJQUFnRCxHQURyRDtBQUVWckQscUNBQWFjLGVBQWV1QyxRQUFmLEtBQTRCO0FBRi9CLHFCQUFkO0FBSUgsaUJBTEQsTUFLTztBQUNIRSwrQkFBVyxZQUFNO0FBQ2IsK0JBQUsvQixRQUFMLENBQWM7QUFDVnhCLHlDQUFhO0FBREgseUJBQWQ7QUFHSCxxQkFKRCxFQUlHLElBSkg7QUFLSDtBQUVKLGFBcEJEOztBQXNCQWMsMkJBQWVzQixFQUFmLENBQWtCLFdBQWxCLEVBQStCLFVBQUNDLElBQUQsRUFBT21CLFVBQVAsRUFBc0I7QUFDakQsdUJBQUsxRCxLQUFMLENBQVcyRCxxQkFBWCxDQUFpQ3BCLElBQWpDLEVBQXVDbUIsVUFBdkM7QUFDSCxhQUZEOztBQUlBLGlCQUFLM0MsU0FBTCxHQUFpQkMsY0FBakI7QUFDSDs7O3VDQUVjO0FBQ1gsaUJBQUtELFNBQUwsQ0FBZTZDLE1BQWY7O0FBRUEsaUJBQUtsQyxRQUFMLENBQWM7QUFDVnRCLDBCQUFVLEVBQUNDLE9BQU8sRUFBUjtBQURBLGFBQWQ7QUFHSDs7O3NDQUVhO0FBQ1YsZ0JBQUksQ0FBQyxLQUFLSixLQUFMLENBQVdLLFFBQWhCLEVBQTBCO0FBQ3RCLHFCQUFLUyxTQUFMLENBQWU4QyxLQUFmO0FBQ0EscUJBQUtuQyxRQUFMLENBQWM7QUFDVnBCLDhCQUFVLElBREE7QUFFVkMsaUNBQWE7QUFGSCxpQkFBZDtBQUlILGFBTkQsTUFNTztBQUNILHFCQUFLUSxTQUFMLENBQWU0QixNQUFmO0FBQ0EscUJBQUtqQixRQUFMLENBQWM7QUFDVnBCLDhCQUFVLEtBREE7QUFFVkMsaUNBQWE7QUFGSCxpQkFBZDtBQUlIO0FBQ0o7OztzQ0FFYTtBQUNWLGlCQUFLbUIsUUFBTCxDQUFjO0FBQ1ZwQiwwQkFBVTtBQURBLGFBQWQ7QUFHSDs7O3dDQUVlO0FBQ1osaUJBQUtvQixRQUFMLENBQWM7QUFDVmxCLDJCQUFXLENBQUMsS0FBS1AsS0FBTCxDQUFXTztBQURiLGFBQWQ7QUFHSDs7O2lDQUVRO0FBQUE7O0FBRUwsZ0JBQUlKLFdBQVcsSUFBZjs7QUFFQSxnQkFBSTBELFlBQVksSUFBaEI7QUFDQSxnQkFBSSxLQUFLOUQsS0FBTCxDQUFXOEQsU0FBZixFQUEwQjtBQUN0QkEsNEJBQVksS0FBSzlELEtBQUwsQ0FBVzhELFNBQXZCO0FBQ0g7O0FBRUQsZ0JBQUlDLGNBQWMsSUFBbEI7QUFDQSxnQkFBSSxLQUFLL0QsS0FBTCxDQUFXK0QsV0FBZixFQUE0QjtBQUN4QixvQkFBSSxPQUFPLEtBQUsvRCxLQUFMLENBQVcrRCxXQUFsQixLQUFpQyxRQUFqQyxJQUE2QyxPQUFPLEtBQUsvRCxLQUFMLENBQVcrRCxXQUFsQixLQUFpQyxTQUFsRixFQUE4RkEsY0FBYztBQUFBO0FBQUE7QUFDeEc7QUFBQTtBQUFBO0FBQ0Usc0NBQVUsS0FBSzlELEtBQUwsQ0FBV00sV0FEdkI7QUFFRSx1Q0FBVSxxQkFGWjtBQUdFLHFDQUFTLEtBQUtPLFdBSGhCO0FBRzhCLDZCQUFLZCxLQUFMLENBQVcrRCxXQUFYLElBQTBCO0FBSHhEO0FBRHdHLGlCQUFkLENBQTlGLEtBT0tBLGNBQWEsS0FBSy9ELEtBQUwsQ0FBVytELFdBQXhCO0FBQ1I7O0FBRUQsZ0JBQUlDLGVBQWUsSUFBbkI7QUFDQSxnQkFBSSxLQUFLaEUsS0FBTCxDQUFXZ0UsWUFBZixFQUE2QjtBQUN6QixvQkFBSSxPQUFPLEtBQUtoRSxLQUFMLENBQVdnRSxZQUFsQixLQUFvQyxRQUFwQyxJQUNBLE9BQU8sS0FBS2hFLEtBQUwsQ0FBV2dFLFlBQWxCLEtBQW9DLFNBRHhDLEVBQ21EQSxlQUFlO0FBQUE7QUFBQTtBQUM5RDtBQUFBO0FBQUE7QUFDRSxzQ0FBVSxDQUFDLEtBQUsvRCxLQUFMLENBQVdNLFdBRHhCO0FBRUUsdUNBQVUsc0JBRlo7QUFHRSxxQ0FBUyxLQUFLSyxZQUhoQjtBQUcrQiw2QkFBS1osS0FBTCxDQUFXZ0UsWUFBWCxJQUEyQjtBQUgxRDtBQUQ4RCxpQkFBZixDQURuRCxLQVFLQSxlQUFlLEtBQUtoRSxLQUFMLENBQVdnRSxZQUExQjtBQUNSOztBQUVELGdCQUFJQyxjQUFjLElBQWxCO0FBQ0EsZ0JBQUksS0FBS2pFLEtBQUwsQ0FBV2lFLFdBQWYsRUFBNEI7QUFDeEIsb0JBQUksT0FBTyxLQUFLakUsS0FBTCxDQUFXaUUsV0FBbEIsS0FBbUMsUUFBbkMsSUFDRyxPQUFPLEtBQUtqRSxLQUFMLENBQVdpRSxXQUFsQixLQUFtQyxTQUQxQyxFQUNxREEsY0FBYztBQUFBO0FBQUE7QUFDL0Q7QUFBQTtBQUFBO0FBQ0Usc0NBQVUsQ0FBQyxLQUFLaEUsS0FBTCxDQUFXTSxXQUR4QjtBQUVFLHVDQUFVLHFCQUZaO0FBR0UscUNBQVMsS0FBS00sV0FIaEI7QUFJRyw2QkFBS2IsS0FBTCxDQUFXaUUsV0FBWCxLQUNJLEtBQUtoRSxLQUFMLENBQVdLLFFBQVgsR0FBc0IsUUFBdEIsR0FBaUMsT0FEckM7QUFKSDtBQUQrRCxpQkFBZCxDQURyRCxLQVVLMkQsY0FBYyxLQUFLakUsS0FBTCxDQUFXaUUsV0FBekI7QUFDUjs7QUFFRCxnQkFBSUMsV0FBVyxTQUFYQSxRQUFXLEdBQU07QUFDakIsb0JBQUksT0FBS2pFLEtBQUwsQ0FBV1EsVUFBZixFQUEyQjtBQUN2QiwyQkFBTyxPQUFLVCxLQUFMLENBQVdtRSxhQUFsQjtBQUNILGlCQUZELE1BRU8sSUFBSSxPQUFLbEUsS0FBTCxDQUFXTyxTQUFYLElBQXdCLE9BQUtQLEtBQUwsQ0FBV00sV0FBdkMsRUFBb0Q7QUFDdkQsMkJBQU8sT0FBS1AsS0FBTCxDQUFXb0UsV0FBbEI7QUFDSCxpQkFGTSxNQUVBO0FBQ0gsMkJBQU8sT0FBS3BFLEtBQUwsQ0FBV3FFLFlBQWxCO0FBQ0g7QUFDSixhQVJEOztBQVVBLGdCQUFJQyxXQUFXLFNBQVhBLFFBQVcsR0FBTTtBQUNqQixvQkFBSSxPQUFLdEUsS0FBTCxDQUFXdUUsYUFBZixFQUE4QjtBQUM1QiwyQkFBTyxPQUFLdkUsS0FBTCxDQUFXd0UsWUFBbEI7QUFDRCxpQkFGRCxNQUVPLElBQUksT0FBS3ZFLEtBQUwsQ0FBV08sU0FBZixFQUEwQjtBQUMvQiwyQkFBTyxPQUFLUixLQUFMLENBQVd5RSxZQUFsQjtBQUNELGlCQUZNLE1BRUEsSUFBSSxPQUFLeEUsS0FBTCxDQUFXTSxXQUFmLEVBQTRCO0FBQ2pDLDJCQUFPLE9BQUtQLEtBQUwsQ0FBVzBFLGNBQWxCO0FBQ0QsaUJBRk0sTUFFQSxJQUFJLE9BQUt6RSxLQUFMLENBQVdRLFVBQWYsRUFBMkI7QUFDaEMsMkJBQU8sT0FBS1QsS0FBTCxDQUFXMkUsYUFBbEI7QUFDRCxpQkFGTSxNQUVBLElBQUksT0FBSzFFLEtBQUwsQ0FBV0ssUUFBZixFQUF5QjtBQUM5QiwyQkFBTyxPQUFLTixLQUFMLENBQVcyRSxhQUFsQjtBQUNELGlCQUZNLE1BRUE7QUFDTCwyQkFBTyxPQUFLM0UsS0FBTCxDQUFXNEUsU0FBbEI7QUFDRDtBQUNKLGFBZEQ7O0FBZ0JBLG1CQUNJO0FBQUE7QUFBQSxrQkFBSyxJQUFJLEtBQUs1RSxLQUFMLENBQVc2RSxFQUFwQixFQUF3QixXQUFXUCxVQUFuQyxFQUErQyxLQUFLO0FBQUEsK0JBQVEsT0FBS2pDLFFBQUwsR0FBZ0J5QyxJQUF4QjtBQUFBLHFCQUFwRDtBQUNJO0FBQUE7QUFBQTtBQUNPLCtCQUFPWixVQURkO0FBRU8sc0NBQWMsS0FBS3hELGFBRjFCO0FBR08sc0NBQWMsS0FBS0E7QUFIMUI7QUFLVSx5QkFBS1QsS0FBTCxDQUFXRSxhQUFYLElBQTRCLEVBQTVCLEdBQWlDMkQsU0FBakMsR0FBNkMsS0FBSzdELEtBQUwsQ0FBV0UsYUFMbEU7QUFNSTtBQUNJLDZCQUFLO0FBQUEsbUNBQU8sT0FBSytCLFFBQUwsR0FBZ0I0QyxJQUF2QjtBQUFBLHlCQURUO0FBRUksOEJBQUssTUFGVDtBQUdJLG1DQUFVLEtBSGQ7QUFJSSw4QkFBTSxLQUFLOUUsS0FBTCxDQUFXNkUsRUFBWCxHQUFnQixTQUoxQjtBQUtJLGdDQUFRLEtBQUs3RSxLQUFMLENBQVcrRSxVQUFYLElBQXlCLEdBTHJDO0FBTUksa0NBQVUsS0FBSy9FLEtBQUwsQ0FBV2dGLFlBQVgsSUFBMkIsS0FOekM7QUFPSSwrQkFBTyxFQUFDLFdBQVcsR0FBWjtBQUNDLHFDQUFTLFFBRFY7QUFFQyxzQ0FBVSxRQUZYO0FBR0Msd0NBQVksVUFIYjtBQUlDLHdDQUFZLFFBSmI7QUFLQyx1Q0FBVyxJQUxaO0FBUFg7QUFOSixpQkFESjtBQXNCSTtBQUFBO0FBQUEsc0JBQUssV0FBVSxVQUFmO0FBQ0ssK0JBQU87QUFDTEMscUNBQVMsS0FBS2hGLEtBQUwsQ0FBV0MsV0FBWCxLQUEyQixDQUEzQixHQUErQixNQUEvQixHQUF3QztBQUQ1Qyx5QkFEWjtBQUlJLDJEQUFLLFdBQVUsY0FBZjtBQUNLLCtCQUFPO0FBQ0xnRixtQ0FBTyxLQUFLakYsS0FBTCxDQUFXQyxXQUFYLEdBQXlCLEdBRDNCO0FBRUxpRixvQ0FBUTtBQUZILHlCQURaO0FBSkosaUJBdEJKO0FBZ0NLL0Usd0JBaENMO0FBaUNLMkQsMkJBakNMO0FBa0NLRSwyQkFsQ0w7QUFtQ0tEO0FBbkNMLGFBREo7QUF1Q0g7Ozs7RUE3UStCb0IsZ0I7O2tCQUFmckYsTTs7O0FBZ1JyQkEsT0FBT3NGLFNBQVAsR0FBbUI7QUFDZjs7O0FBR0E5RCxjQUFVK0QsaUJBQVVDLE1BSkw7O0FBTWY7OztBQUdBL0QsaUJBQWE4RCxpQkFBVUMsTUFUUjs7QUFXZjs7O0FBR0F6RCxlQUFXd0QsaUJBQVVDLE1BZE47O0FBZ0JmOzs7QUFHQXhELHlCQUFxQnVELGlCQUFVQyxNQW5CaEI7O0FBcUJmOzs7QUFHQXBFLGFBQVNtRSxpQkFBVUUsTUF4Qko7O0FBMEJmOzs7QUFHQVosZUFBV1UsaUJBQVVFLE1BN0JOOztBQStCZjs7O0FBR0FmLGtCQUFjYSxpQkFBVUUsTUFsQ1Q7O0FBb0NmOzs7QUFHQUMsbUJBQWVILGlCQUFVRSxNQXZDVjs7QUF5Q2Y7OztBQUdBRSxpQkFBYUosaUJBQVVFLE1BNUNSOztBQThDZjs7O0FBR0FiLG1CQUFlVyxpQkFBVUUsTUFqRFY7O0FBbURmOzs7QUFHQWQsb0JBQWdCWSxpQkFBVUUsTUF0RFg7O0FBd0RmOzs7QUFHQW5CLGtCQUFjaUIsaUJBQVVLLE1BM0RUOztBQTZEZjs7O0FBR0F2QixpQkFBYWtCLGlCQUFVSyxNQWhFUjs7QUFrRWhCOzs7QUFHQ3hCLG1CQUFlbUIsaUJBQVVLLE1BckVWOztBQXVFZjs7O0FBR0E3QixlQUFXd0IsaUJBQVVFLE1BMUVOOztBQTRFZjs7O0FBR0FuQyxzQkFBa0JpQyxpQkFBVUUsTUEvRWI7O0FBaUZmOzs7QUFHQXJDLGVBQVdtQyxpQkFBVU0sT0FBVixDQUFrQk4saUJBQVVFLE1BQTVCLENBcEZJOztBQXNGZjs7O0FBR0FsRSxlQUFXZ0UsaUJBQVVNLE9BQVYsQ0FBa0JOLGlCQUFVRSxNQUE1QixDQXpGSTs7QUEyRmY7OztBQUdBekIsaUJBQWF1QixpQkFBVU8sSUE5RlI7O0FBZ0dmOzs7QUFHQTVCLGlCQUFhcUIsaUJBQVVPLElBbkdSOztBQXFHZjs7O0FBR0E3QixrQkFBY3NCLGlCQUFVTyxJQXhHVDs7QUEwR2Y7OztBQUdBMUQsd0JBQW9CbUQsaUJBQVVPLElBN0dmOztBQStHZjs7O0FBR0F6QyxjQUFVa0MsaUJBQVVRLElBbEhMOztBQW9IZjs7O0FBR0FqQixRQUFJUyxpQkFBVUU7O0FBdkhDLENBQW5COztBQTJIQXpGLE9BQU9nRyxZQUFQLEdBQXNCO0FBQ2xCeEUsY0FBVSxDQURRO0FBRWxCQyxpQkFBYSxPQUFPLElBQVAsR0FBYyxFQUZUO0FBR2xCTSxlQUFXLE9BQU8sSUFIQTtBQUlsQmtFLHlCQUFxQixDQUpIO0FBS2xCN0UsYUFBUyxTQUxTO0FBTWxCeUQsZUFBVyxtQkFOTztBQU9sQkgsa0JBQWMsbUJBUEk7QUFRbEJFLG1CQUFlLG9CQVJHO0FBU2xCYyxtQkFBZSxvQkFURztBQVVsQkMsaUJBQWEsa0JBVks7QUFXbEJoQixvQkFBZ0IscUJBWEU7QUFZbEJMLGtCQUFjLEVBWkk7QUFhbEJELGlCQUFhLEVBYks7QUFjbEJELG1CQUFlLEVBZEc7QUFlbEJMLGVBQVcsNkJBZk87QUFnQmxCVCxzQkFBa0IsWUFoQkE7QUFpQmxCRixlQUFXLEVBakJPO0FBa0JsQjdCLGVBQVcyRSxTQWxCTztBQW1CbEJsQyxpQkFBYSxJQW5CSztBQW9CbEJFLGlCQUFhLElBcEJLO0FBcUJsQkQsa0JBQWMsSUFyQkk7QUFzQmxCN0Isd0JBQW9CLEtBdEJGO0FBdUJsQjBDLFFBQUk7QUF2QmMsQ0FBdEIiLCJmaWxlIjoiLi9zcmMvbGliL2NvbXBvbmVudHMvVXBsb2FkLnJlYWN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZXN1bWFibGVqcyBmcm9tICdyZXN1bWFibGVqcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXI6IDAsXG4gICAgICAgICAgICBtZXNzYWdlU3RhdHVzOiAnJyxcbiAgICAgICAgICAgIGZpbGVMaXN0OiB7ZmlsZXM6IFtdfSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVXBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSG92ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvZ2dsZUhvdmVyZWQgPSB0aGlzLnRvZ2dsZUhvdmVyZWQuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmNhbmNlbFVwbG9hZCA9IHRoaXMuY2FuY2VsVXBsb2FkLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5wYXVzZVVwbG9hZCA9IHRoaXMucGF1c2VVcGxvYWQuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnN0YXJ0VXBsb2FkID0gdGhpcy5zdGFydFVwbG9hZC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMucmVzdW1hYmxlID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcblxuICAgICAgICBjb25zdCBSZXN1bWFibGVGaWVsZCA9IG5ldyBSZXN1bWFibGVqcyh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMucHJvcHMuc2VydmljZSxcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIGZpbGVUeXBlOiB0aGlzLnByb3BzLmZpbGV0eXBlcyxcbiAgICAgICAgICAgIG1heEZpbGVzOiB0aGlzLnByb3BzLm1heEZpbGVzLFxuICAgICAgICAgICAgbWF4RmlsZVNpemU6IHRoaXMucHJvcHMubWF4RmlsZVNpemUsXG4gICAgICAgICAgICBmaWxlVHlwZUVycm9yQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogJ0ludmFsaWQgZmlsZSB0eXBlISdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXN0TWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICB0ZXN0Q2h1bmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgY2h1bmtTaXplOiB0aGlzLnByb3BzLmNodW5rU2l6ZSxcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1VwbG9hZHM6IHRoaXMucHJvcHMuc2ltdWx0YW5lb3VzVXBsb2FkcyxcbiAgICAgICAgICAgIGZvcmNlQ2h1bmtTaXplOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBSZXN1bWFibGVGaWVsZC5hc3NpZ25Ccm93c2UodGhpcy51cGxvYWRlcik7XG5cbiAgICAgICAgLy9FbmFibGUgb3IgRGlzYWJsZSBEcmFnQW5kIERyb3BcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZURyYWdBbmREcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgUmVzdW1hYmxlRmllbGQuYXNzaWduRHJvcCh0aGlzLmRyb3Bab25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlc3VtYWJsZUZpZWxkLm9uKCdmaWxlQWRkZWQnLCAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0YXR1czogdGhpcy5wcm9wcy5maWxlQWRkZWRNZXNzYWdlIHx8ICcgU3RhcnRpbmcgdXBsb2FkISBvZiAnICsgZmlsZS5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25GaWxlQWRkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbGVBZGRlZChmaWxlLCB0aGlzLnJlc3VtYWJsZSk7XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgUmVzdW1hYmxlRmllbGQudXBsb2FkKCk7XG4gICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBSZXN1bWFibGVGaWVsZC5vbignZmlsZVN1Y2Nlc3MnLCAoZmlsZSwgZmlsZVNlcnZlcikgPT4ge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5maWxlTmFtZVNlcnZlcikge1xuICAgICAgICAgICAgICAgIGxldCBvYmplY3RTZXJ2ZXIgPSBKU09OLnBhcnNlKGZpbGVTZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIGZpbGUuZmlsZU5hbWUgPSBvYmplY3RTZXJ2ZXJbdGhpcy5wcm9wcy5maWxlTmFtZVNlcnZlcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGUuZmlsZU5hbWUgPSBmaWxlU2VydmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxlcyA9IHRoaXMuc3RhdGUuZmlsZUxpc3QuZmlsZXM7XG4gICAgICAgICAgICBjdXJyZW50RmlsZXMucHVzaChmaWxlKTtcblxuICAgICAgICAgICAgbGV0IGZpbGVOYW1lcyA9IHRoaXMucHJvcHMuZmlsZU5hbWVzXG4gICAgICAgICAgICBmaWxlTmFtZXMucHVzaChmaWxlLmZpbGVOYW1lKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2V0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZXM6IGZpbGVOYW1lc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZmlsZUxpc3Q6IHtmaWxlczogY3VycmVudEZpbGVzfSxcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdGF0dXM6IHRoaXMucHJvcHMuY29tcGxldGVkTWVzc2FnZSArIGZpbGUuZmlsZU5hbWUgfHwgZmlsZVNlcnZlclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkZpbGVTdWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25GaWxlU3VjY2VzcyhmaWxlLCBmaWxlU2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUmVzdW1hYmxlRmllbGQub24oJ3Byb2dyZXNzJywgKCkgPT4ge1xuXG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGlzVXBsb2FkaW5nOiBSZXN1bWFibGVGaWVsZC5pc1VwbG9hZGluZygpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKChSZXN1bWFibGVGaWVsZC5wcm9ncmVzcygpICogMTAwKSA8IDEwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlU3RhdHVzOiBwYXJzZUludChSZXN1bWFibGVGaWVsZC5wcm9ncmVzcygpICogMTAwLCAxMCkgKyAnJScsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyOiBSZXN1bWFibGVGaWVsZC5wcm9ncmVzcygpICogMTAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgUmVzdW1hYmxlRmllbGQub24oJ2ZpbGVFcnJvcicsIChmaWxlLCBlcnJvckNvdW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVXBsb2FkRXJyb3JDYWxsYmFjayhmaWxlLCBlcnJvckNvdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXN1bWFibGUgPSBSZXN1bWFibGVGaWVsZDtcbiAgICB9XG5cbiAgICBjYW5jZWxVcGxvYWQoKSB7XG4gICAgICAgIHRoaXMucmVzdW1hYmxlLmNhbmNlbCgpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmlsZUxpc3Q6IHtmaWxlczogW119XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBhdXNlVXBsb2FkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1hYmxlLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1VwbG9hZGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtYWJsZS51cGxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1VwbG9hZGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFVwbG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlSG92ZXJlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpc0hvdmVyZWQ6ICF0aGlzLnN0YXRlLmlzSG92ZXJlZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICBsZXQgZmlsZUxpc3QgPSBudWxsO1xuXG4gICAgICAgIGxldCB0ZXh0TGFiZWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy50ZXh0TGFiZWwpIHtcbiAgICAgICAgICAgIHRleHRMYWJlbCA9IHRoaXMucHJvcHMudGV4dExhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0QnV0dG9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc3RhcnRCdXR0b24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5zdGFydEJ1dHRvbiA9PT0nc3RyaW5nJyB8fCB0eXBlb2YgdGhpcy5wcm9wcy5zdGFydEJ1dHRvbiA9PT0nYm9vbGVhbicgKSBzdGFydEJ1dHRvbiA9IDxsYWJlbD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5zdGF0ZS5pc1VwbG9hZGluZ31cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlc3VtYWJsZS1idG4tc3RhcnRcIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdGFydFVwbG9hZH0+e3RoaXMucHJvcHMuc3RhcnRCdXR0b24gJiYgJ3VwbG9hZCd9XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2xhYmVsPjtcbiAgICAgICAgICAgIGVsc2Ugc3RhcnRCdXR0b24gPXRoaXMucHJvcHMuc3RhcnRCdXR0b25cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW5jZWxCdXR0b24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jYW5jZWxCdXR0b24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5jYW5jZWxCdXR0b24gPT09ICAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnByb3BzLmNhbmNlbEJ1dHRvbiA9PT0gICdib29sZWFuJykgY2FuY2VsQnV0dG9uID0gPGxhYmVsPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5pc1VwbG9hZGluZ31cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlc3VtYWJsZS1idG4tY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuY2FuY2VsVXBsb2FkfT57dGhpcy5wcm9wcy5jYW5jZWxCdXR0b24gJiYgJ2NhbmNlbCd9XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2xhYmVsPjtcbiAgICAgICAgICAgIGVsc2UgY2FuY2VsQnV0dG9uID0gdGhpcy5wcm9wcy5jYW5jZWxCdXR0b25cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXVzZUJ1dHRvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnBhdXNlQnV0dG9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMucGF1c2VCdXR0b24gPT09ICAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIHx8IHR5cGVvZiB0aGlzLnByb3BzLnBhdXNlQnV0dG9uID09PSAgJ2Jvb2xlYW4nKSBwYXVzZUJ1dHRvbiA9IDxsYWJlbD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXRoaXMuc3RhdGUuaXNVcGxvYWRpbmd9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyZXN1bWFibGUtYnRuLXBhdXNlXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucGF1c2VVcGxvYWR9PlxuICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMucGF1c2VCdXR0b25cbiAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5zdGF0ZS5pc1BhdXNlZCA/ICdyZXN1bWUnIDogJ3BhdXNlJyl9XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2xhYmVsPjtcbiAgICAgICAgICAgIGVsc2UgcGF1c2VCdXR0b24gPSB0aGlzLnByb3BzLnBhdXNlQnV0dG9uXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZ2V0U3R5bGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tcGxldGVTdHlsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0hvdmVyZWQgfHwgdGhpcy5zdGF0ZS5pc1VwbG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFjdGl2ZVN0eWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kZWZhdWx0U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZ2V0Q2xhc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZElucHV0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRpc2FibGVDbGFzcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0hvdmVyZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaG92ZXJlZENsYXNzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzVXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnVwbG9hZGluZ0NsYXNzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY29tcGxldGVDbGFzcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb21wbGV0ZUNsYXNzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5wcm9wcy5pZH0gY2xhc3NOYW1lPXtnZXRDbGFzcygpfSByZWY9e25vZGUgPT4gdGhpcy5kcm9wWm9uZSA9IG5vZGV9ID5cbiAgICAgICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e2dldFN0eWxlKCl9XG4gICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy50b2dnbGVIb3ZlcmVkfVxuICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMudG9nZ2xlSG92ZXJlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLm1lc3NhZ2VTdGF0dXMgPT0gJycgPyB0ZXh0TGFiZWwgOiB0aGlzLnN0YXRlLm1lc3NhZ2VTdGF0dXN9XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtub2RlPT4gdGhpcy51cGxvYWRlciA9IG5vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2J0bidcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e3RoaXMucHJvcHMuaWQgKyAnLXVwbG9hZCd9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuZmlsZUFjY2VwdCB8fCAnKid9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17dGhpcy5wcm9wcy5kaXNhYmxlSW5wdXQgfHwgZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eydvcGFjaXR5JzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiAnMC4xcHglJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcwLjFweCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAnLTEnfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvZ3Jlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5zdGF0ZS5wcm9ncmVzc0JhciA9PT0gMCA/ICdub25lJyA6ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2dyZXNzLWJhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnN0YXRlLnByb2dyZXNzQmFyICsgJyUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICB9fT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAge2ZpbGVMaXN0fVxuICAgICAgICAgICAgICAgIHtzdGFydEJ1dHRvbn1cbiAgICAgICAgICAgICAgICB7cGF1c2VCdXR0b259XG4gICAgICAgICAgICAgICAge2NhbmNlbEJ1dHRvbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuVXBsb2FkLnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBmaWxlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCBpbiBvbmUgc2Vzc2lvblxuICAgICAqL1xuICAgIG1heEZpbGVzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzaXplIHBlciBmaWxlIGluIGJ5dGVzLlxuICAgICAqL1xuICAgIG1heEZpbGVTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBmaWxlIGNodW5rcyB0byBzZW5kIHRvIHNlcnZlci5cbiAgICAgKi9cbiAgICBjaHVua1NpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2Ygc2ltdWx0YW5lb3VzIHVwbG9hZHMgdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2ltdWx0YW5lb3VzVXBsb2FkczogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIHRvIHNlbmQgdGhlIGZpbGVzIHRvXG4gICAgICovXG4gICAgc2VydmljZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCBieSBkZWZhdWx0XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgdG8gYWRkIHRvIHRoZSB1cGxvYWQgY29tcG9uZW50IHdoZW4gaXQgaXMgaG92ZXJlZFxuICAgICAqL1xuICAgIGhvdmVyZWRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIGRpc2FibGVkXG4gICAgICovXG4gICAgZGlzYWJsZWRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudCB3aGVuIGl0IGlzIHBhdXNlZFxuICAgICAqL1xuICAgIHBhdXNlZENsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgdG8gYWRkIHRvIHRoZSB1cGxvYWQgY29tcG9uZW50IHdoZW4gaXQgaXMgY29tcGxldGVcbiAgICAgKi9cbiAgICBjb21wbGV0ZUNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgdG8gYWRkIHRvIHRoZSB1cGxvYWQgY29tcG9uZW50IHdoZW4gaXQgaXMgdXBsb2FkaW5nXG4gICAgICovXG4gICAgdXBsb2FkaW5nQ2xhc3M6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBTdHlsZSBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgdXBsb2FkIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGRlZmF1bHRTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAgIC8qKlxuICAgICAqIFN0eWxlIHdoZW4gdXBsb2FkIGNvbXBvbmVudCBpcyBob3ZlcmVkIG92ZXJcbiAgICAgKi9cbiAgICBhY3RpdmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAgLyoqXG4gICAgKiBTdHlsZSB3aGVuIHVwbG9hZCBpcyBjb21wbGV0ZWQgKHVwbG9hZCBmaW5pc2hlZClcbiAgICAqL1xuICAgIGNvbXBsZXRlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHRvIGRpc3BsYXkgaW4gdGhlIHVwbG9hZCBjb21wb25lbnRcbiAgICAgKi9cbiAgICB0ZXh0TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB1cGxvYWQgY29tcGxldGVkXG4gICAgICovXG4gICAgY29tcGxldGVkTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lcyBvZiB0aGUgZmlsZXMgdXBsb2FkZWRcbiAgICAgKi9cbiAgICBmaWxlTmFtZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGxvd2VkIGZpbGUgdHlwZXMsIGUuZy4gWydqcGcnLCAncG5nJ11cbiAgICAgKi9cbiAgICBmaWxldHlwZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gaGF2ZSBhIHN0YXJ0IGJ1dHRvblxuICAgICAqL1xuICAgIHN0YXJ0QnV0dG9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGhhdmUgYSBwYXVzZSBidXR0b25cbiAgICAgKi9cbiAgICBwYXVzZUJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBoYXZlIGEgY2FuY2VsIGJ1dHRvblxuICAgICAqL1xuICAgIGNhbmNlbEJ1dHRvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBhbGxvdyBmaWxlIGRyYWcgYW5kIGRyb3BcbiAgICAgKi9cbiAgICBkaXNhYmxlRHJhZ0FuZERyb3A6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogRGFzaC1zdXBwbGllZCBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgcHJvcHNcbiAgICAgKi9cbiAgICBzZXRQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHN1cHBsaWVkIGlkIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmdcblxufVxuXG5VcGxvYWQuZGVmYXVsdFByb3BzID0ge1xuICAgIG1heEZpbGVzOiAxLFxuICAgIG1heEZpbGVTaXplOiAxMDI0ICogMTAyNCAqIDEwLFxuICAgIGNodW5rU2l6ZTogMTAyNCAqIDEwMjQsXG4gICAgc2ltdWx0YW5ldW9zVXBsb2FkczogMSxcbiAgICBzZXJ2aWNlOiAnL3VwbG9hZCcsXG4gICAgY2xhc3NOYW1lOiAncmVzdW1hYmxlLWRlZmF1bHQnLFxuICAgIGhvdmVyZWRDbGFzczogJ3Jlc3VtYWJsZS1ob3ZlcmVkJyxcbiAgICBjb21wbGV0ZUNsYXNzOiAncmVzdW1hYmxlLWNvbXBsZXRlJyxcbiAgICBkaXNhYmxlZENsYXNzOiAncmVzdW1hYmxlLWRpc2FibGVkJyxcbiAgICBwYXVzZWRDbGFzczogJ3Jlc3VtYWJsZS1wYXVzZWQnLFxuICAgIHVwbG9hZGluZ0NsYXNzOiAncmVzdW1hYmxlLXVwbG9hZGluZycsXG4gICAgZGVmYXVsdFN0eWxlOiB7fSxcbiAgICBhY3RpdmVTdHlsZToge30sXG4gICAgY29tcGxldGVTdHlsZToge30sXG4gICAgdGV4dExhYmVsOiAnQ2xpY2sgSGVyZSB0byBTZWxlY3QgYSBGaWxlJyxcbiAgICBjb21wbGV0ZWRNZXNzYWdlOiAnQ29tcGxldGUhICcsXG4gICAgZmlsZU5hbWVzOiBbXSxcbiAgICBmaWxldHlwZXM6IHVuZGVmaW5lZCxcbiAgICBzdGFydEJ1dHRvbjogdHJ1ZSxcbiAgICBwYXVzZUJ1dHRvbjogdHJ1ZSxcbiAgICBjYW5jZWxCdXR0b246IHRydWUsXG4gICAgZGlzYWJsZURyYWdBbmREcm9wOiBmYWxzZSxcbiAgICBpZDogJ2RlZmF1bHQtdXBsb2FkZXItaWQnXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/components/Upload.react.js\n");

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Upload = undefined;\n\nvar _Upload = __webpack_require__(/*! ./components/Upload.react */ \"./src/lib/components/Upload.react.js\");\n\nvar _Upload2 = _interopRequireDefault(_Upload);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Upload = _Upload2.default; /* eslint-disable import/prefer-default-export *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZC8uL3NyYy9saWIvaW5kZXguanM/ZDc1YSJdLCJuYW1lcyI6WyJVcGxvYWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7Ozs7O1FBR0lBLE0sR0FBQUEsZ0IsRUFKSiIsImZpbGUiOiIuL3NyYy9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG5pbXBvcnQgVXBsb2FkIGZyb20gJy4vY29tcG9uZW50cy9VcGxvYWQucmVhY3QnO1xuXG5leHBvcnQge1xuICAgIFVwbG9hZFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/index.js\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"React\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX2xhcmdlX3VwbG9hZC9leHRlcm5hbCBcIlJlYWN0XCI/YzQ4MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLGtDQUFrQyxFQUFFIiwiZmlsZSI6InJlYWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcIlJlYWN0XCJdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });