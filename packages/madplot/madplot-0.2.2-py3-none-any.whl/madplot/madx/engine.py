import logging
import os
from pathlib import Path
import shutil
import subprocess
import tempfile
import time
from typing import Sequence, Union

from madplot.utils import Convert


logger = logging.getLogger(__name__)


class MADXEngine:
    """Main class for running MADX scripts.
    
    Example
    -------
    
    ```python
    engine = MADXEngine(['example.madx'])
    twiss, = engine.run(['example.twiss'])
    ```
    """

    def __init__(self,
                 templates : Sequence[Union[str, Path]],
                 madx : Union[str, Path] = None,
                 working_directory : Union[str, Path] = None):
        """Creates a new MADX engine.
        
        Parameters
        ----------
        templates: list or tuple
            List containing the file paths of all MADX scripts (or templates) that are required for
            running the main script. The main script is the first element of the template list.
            A template is a MADX scripts that contains substitution keys of the form `{key}`
            (following the Python formatting specification). This can be interpolated when running
            the scripts.
        madx: str, optional
            File path to the MADX executable. If not given, then an attempt to retrieve the path from
            the `MADX` environment variable is made. If this attempt fails then a `EnvironmentError`
            is raised.
        working_directory: str, optional
            If specified, the engine will run the script(s) in this directory (and hence place all
            required files there as well). If not specified, a temporary directory is created automatically.
            
        Raises
        ------
        EnvironmentError
            If no `madx` executable path is specified and the `MADX` environment variable is not set.
        """
        super().__init__()
        self.templates = list(map(Path, templates))
        self.entry_point = self.templates[0].name
        self.madx = madx or os.environ.get('MADX')
        if not self.madx:
            raise EnvironmentError(
                'Could not determine the path to MADX executable. Specify either by setting the '
                '`MADX` environment variable or via the `madx` argument'
            )
        self.working_directory = Path(working_directory or tempfile.mkdtemp())

    def run(self, results: list, configuration: dict = None, job_id: str = None, overwrite: bool = False):
        """Run the specified scripts (templates).
        
        Parameters
        ----------
        results : list or tuple
            List containing the file names of output files that should be retrieved. These output
            files need to be generated by the scripts that are run. The resulting TFS files will be
            read and converted to `pandas.DataFrame` objects.
            For fine-tuning of how an output should be handled it can alternatively be specified as
            a tuple of `(file_name, options)` where `options` is a dictionary containing additional
            keyword arguments for the conversion function (which is `madplot.utils.tfs_to_pd`).
        configuration : dict, optional
            A dictionary containing the configuration for one or more of the template scripts that
            have been specified during instantiation of that engine. The keys are file names (not
            file paths) of the template scripts and the values are dictionaries containing the
            substitution keys and values that occur with the particular scripts.
        job_id : str, optional
            If a `job_id` is specified it will be appended to the `working_directory` and the scripts
            will be run in the resulting sub-directory.
        overwrite : bool, optional, default = `False`
            If set to true, overwrites templates that are to be interpolated where the working directory
            is similar to the template directory. If false, raises a UserWarning when overwriting would
            be necessary.
            
        Returns
        -------
        results: list
            A list containing the data frames corresponding to the specified result names.
            If a result was specified as `(file_name, {'return_meta': True})` then the corresponding
            element is a tuple of `(data_frame, meta_data)` where `meta_data` is a dictionary
            containing the `@`-prefixed data of the corresponding output TFS file.
            
        Raises
        ------
        RuntimeError
            If the MADX executable did not finish with return code 0.
        UserWarning
            If a template would be overwritten by its interpolated version. This can happen if the
            `working_directory` is the same directory where the templates are placed. This behavior
            can be overridden by setting ``overwrite=True``.
        """
        if configuration is None:
            configuration = {}
        if job_id is not None:
            working_directory = self.working_directory / job_id
        else:
            working_directory = self.working_directory
        logger.debug(f'Working directory is {working_directory}')

        for template in self.templates:
            new_path = working_directory / template.name
            if new_path == template and template.name in configuration and not overwrite:
                raise UserWarning(f'Refusing to overwrite template by interpolation '
                                  f'(target path is identical with template path): {template}')
                continue
            if template.name in configuration:
                with open(template) as f1:
                    formatted = f1.read().format(**configuration[template.name])
                with open(new_path, 'w') as f2:
                    f2.write(formatted)
            elif new_path != template:
                shutil.copyfile(template, new_path)

        completed_process = subprocess.run(
            [self.madx, self.entry_point],
            cwd=working_directory,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout = completed_process.stdout.decode('utf-8')
        stderr = completed_process.stderr.decode('utf-8')
        f_out = working_directory / 'stdout'
        f_err = working_directory / 'stderr'
        with open(f_out, 'w') as f1, open(f_err, 'w') as f2:
            f1.write(stdout)
            f2.write(stderr)
        logger.debug(f'Simulation finished with return code {completed_process.returncode}')
        if completed_process.returncode != 0:
            raise RuntimeError(
                f'Simulation did not finish successfully (return code {completed_process.returncode}). '
                f'See {f_out} and {f_err} for the stdout and stderr respectively.'
            )
        results = map(lambda x: x if isinstance(x, (tuple, list)) else (x, {}), results)
        results = map(lambda x: (working_directory / x[0], x[1]), results)
        return list(map(lambda x: Convert.by_file_name(x[0], **x[1]), results))


class MADXSession:
    def __init__(self,
                 start_up_scripts: Sequence[str] = (),
                 madx : Union[str, Path] = None,
                 stderr = None, stdout = None):
        madx = madx or os.environ.get('MADX')
        if not madx:
            raise EnvironmentError(
                'Could not determine the path to MADX executable. Specify either by setting the '
                '`MADX` environment variable or via the `madx` argument'
            )
        self.process = subprocess.Popen(madx, stdin=subprocess.PIPE, stderr=stderr, stdout=stdout)
        if isinstance(start_up_scripts, str):
            start_up_scripts = (start_up_scripts,)
        for f_path in start_up_scripts:
            f_path = f_path if os.path.isabs(f_path) else os.path.join(os.getcwd(), f_path)
            logging.info('Call: %s', f_path)
            self.process.stdin.write(f'call, file = "{f_path}";\n'.encode('ascii'))
            self.process.stdin.flush()

    def run(self, commands: Sequence[str] = (), results: Sequence[str] = (), buffer_time=0.05):
        for command in commands:
            command = command.rstrip('\n').rstrip(';')
            self.process.stdin.write(f'{command};\n'.encode('ascii'))
            self.process.stdin.flush()
        time.sleep(buffer_time)  # Wait for process to finish writing files, etc.
        results = map(lambda x: x if isinstance(x, (tuple, list)) else (x, {}), results)
        results = map(lambda x: (os.path.join(os.getcwd(), x[0]), x[1]), results)
        return list(map(lambda x: Convert.by_file_name(x[0], **x[1]), results))
