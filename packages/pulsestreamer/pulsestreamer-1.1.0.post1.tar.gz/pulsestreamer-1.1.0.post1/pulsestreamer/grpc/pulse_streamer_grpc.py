#import grpc-package
from grpc import insecure_channel

#import class Sequence and OutoutState for advanced sequence building
from pulsestreamer.sequence import Sequence, OutputState

try:
    #import the python wrapper generated by the protocol buffer compiler (source: pulse_streamer.proto)
    from pulsestreamer.grpc.pulse_streamer_pb2 import VoidMessage, PulseMessage, SequenceMessage, ClockMessage, DrpClkSetMessage, GetSerialMessage, TriggerMessage, SetNetworkMessage, EnableStaticIPMessage, PulseStreamerStub
except Exception as e:
    print('Exception: '+ str(e))
    assert False, \
"""
Failed to import simple wrapper generated by the protobuf compiler (source: pulse_streamer.proto)
- Ensure pulse_streamer_pb2.py is in the search path.
Required packages: grpcio, protobuf
"""

from pulsestreamer.enums import ClockSource, TriggerStart, TriggerRearm, Serial

class PulseStreamer():
    """
    Simple python wrapper for a PulseStreamer 8/2
    that describes sequences in the form of sequence steps as (time, [0,1,3], 0.8, -0.4),
    where time is an integer in ns (clock ticks),
    [0,1,3] is a list numbering the channels that should be high
    the last two numbers specify the analog outputs in volt.
    For advanced sequence creation use the method createSequence() and the functionality of
    the class Sequence described in the documentation of the Pulse Streamer 8/2.
    """

    TIMEOUT = 200
    REPEAT_INFINITELY=-1
    
    def __init__(self, ip_hostname='pulsestreamer'):
        print("Connect to Pulse Streamer via google-RPC.")
        print("IP / Hostname:", ip_hostname)

        try:
            channel = insecure_channel(ip_hostname + ':50051')
            self.stub = PulseStreamerStub(channel)
            try:
                g = GetSerialMessage()
                g.serial = getattr(GetSerialMessage, Serial.MAC.name)
                self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT)
            except:
                try:
                    void = VoidMessage()
                    self.stub.isRunning(void, timeout=PulseStreamer.TIMEOUT)
                    assert False, "Pulse Streamer class not compatible with current firmware. Please update your firmware." \
                        "For detailed information visit https://www.swabianinstruments.com/pulse-streamer-8-2-firmware/ " \
                        "or contact support@swabianinstruments.com"
                except AssertionError:
                    raise
                except:
                    assert False, "No Pulse Streamer found at IP/Host-address: "+ip_hostname
        except AssertionError:
            raise
        except:
            assert False, "No Pulse Streamer found at IP/Host-address: "+ip_hostname
        
    def reset(self):
        void = VoidMessage()
        return self.stub.reset(void, timeout=PulseStreamer.TIMEOUT).value
        
    def constant(self, state=OutputState.ZERO()):
        if isinstance(state, OutputState):
            state=state.getData()
            sequence_step = PulseMessage(ticks=0, digi=state[0], ao0=state[1], ao1=state[2])
        else:
            if isinstance(state[0], list):
                sequence_step = self.convert_sequence_step((0, state[0], state[1], state[2]))
            else:
                chans, a0, a1 = state
                sequence_step = PulseMessage(ticks=0, digi=chans, ao0=a0, ao1=a1)
        self.stub.constant(sequence_step, timeout=PulseStreamer.TIMEOUT)

    def forceFinal(self):
        void = VoidMessage()
        return self.stub.forceFinal(void, timeout=PulseStreamer.TIMEOUT).value

    def createOutputState(self, digi, A0=0.0, A1=0.0):
        output=OutputState(digi=digi,A0=A0, A1=A1)
        return output

    def createSequence(self):
        seq = Sequence()
        return seq
        
    def stream(self, seq, n_runs=REPEAT_INFINITELY, final=OutputState.ZERO()):
        if isinstance(seq, Sequence):
            sequence=seq.getData()
        else:
            sequence= seq

        s = SequenceMessage()
        
        if type(sequence[0][1])== list:
            for i in range(len(sequence)):
                t, chans, a0, a1 = sequence[i]
                if t > 0xffffffff:
                    mod=t%0xffffffff
                    count=t//0xffffffff
                    for i in range(count):
                        t =0xffffffff
                        s.pulse.extend([self.convert_sequence_step((t, chans, a0, a1))])
                    else:
                        t=mod
                s.pulse.extend([self.convert_sequence_step((t, chans, a0, a1))])
        else:
            for i in range(len(sequence)):
                t, chans, a0, a1 = sequence[i]
                if t > 0xffffffff:
                    mod=t%0xffffffff
                    count=t//0xffffffff
                    for i in range(count):
                        t =0xffffffff
                        s.pulse.extend([PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)])
                    else:
                        t=mod
                s.pulse.extend([PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)])

        assert len(s.pulse)<=2e6, "The resulting sequence length exceeds the limit of two million sequnence steps"

        s.n_runs = n_runs

        if isinstance(final, OutputState):
            final=final.getData()
            conv_final = PulseMessage(ticks=0, digi=final[0],ao0=final[1], ao1=final[2])
        else:
            if isinstance(final[0], list):
                conv_final = self.convert_sequence_step((0,final[0], final[1], final[2]))
            else:
                chans, a0, a1 = final
                conv_final = PulseMessage(ticks=0, digi=chans, ao0=a0, ao1=a1)

        s.final.ticks = conv_final.ticks
        s.final.digi = conv_final.digi
        s.final.ao0 = conv_final.ao0
        s.final.ao1 = conv_final.ao1
  
        self.stub.stream(s, timeout=PulseStreamer.TIMEOUT)
            
    def isStreaming(self):
        void = VoidMessage()
        return self.stub.isStreaming(void, timeout=PulseStreamer.TIMEOUT).value

    def hasSequence(self):
        void = VoidMessage()
        return self.stub.hasSequence(void, timeout=PulseStreamer.TIMEOUT).value

    def hasFinished(self):
        void = VoidMessage()
        return self.stub.hasFinished(void, timeout=PulseStreamer.TIMEOUT).value

    def startNow(self):
        void = VoidMessage()
        return self.stub.startNow(void, timeout=PulseStreamer.TIMEOUT).value

    def selectClock(self, source):
        if not isinstance(source, ClockSource):
            raise TypeError("source must be an instance of ClockSource Enum")
        else:
            c = ClockMessage()
            c.clock_source = source.value
            return self.stub.selectClock(c, timeout=PulseStreamer.TIMEOUT).value

    def getFirmwareVersion(self):
        void = VoidMessage()
        return self.stub.getFirmwareVersion(void, timeout=PulseStreamer.TIMEOUT).string_value

    def flash_lic(self):
        void = VoidMessage()
        return self.stub.flash_lic(void, timeout=PulseStreamer.TIMEOUT).string_value

    def getSerial(self):
            g = GetSerialMessage()
            g.serial = getattr(GetSerialMessage, Serial.MAC.name)
            return self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT).string_value

    def getFPGAID(self):
            g = GetSerialMessage()
            g.serial = getattr(GetSerialMessage, Serial.ID.name)
            return self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT).string_value

    def setClkParam(self, value=0):
        assert value in range(58)
        v= DrpClkSetMessage()
        v.value = value
        return self.stub.setClkParam(v, timeout=PulseStreamer.TIMEOUT).value

    def setTrigger(self, start, rearm=TriggerRearm.AUTO):
        if not isinstance(start, TriggerStart):
            raise TypeError("start must be an instance of TriggerStart Enum")
        else:
            if not isinstance(rearm, TriggerRearm):
                raise TypeError("rearm must be an instance of TriggerRearm Enum")
            else:
                t = TriggerMessage()
                t.start = start.value
                t.mode = rearm.value
                return self.stub.setTrigger(t, timeout=PulseStreamer.TIMEOUT).value

    def rearm(self):
        void = VoidMessage()
        return self.stub.rearm(void, timeout=PulseStreamer.TIMEOUT).value
    
    def setNetworkConf(self, ip, netmask, gateway):
        n=SetNetworkMessage()
        n.ip=ip
        n.netmask=netmask
        n.gateway=gateway
        return self.stub.setNetworkConf(n, timeout=PulseStreamer.TIMEOUT).string_value

    def getNetworkConf(self):
        void = VoidMessage()
        return self.stub.getNetworkConf(void, timeout=PulseStreamer.TIMEOUT).string_value

    def testNetworkConf(self):
        void = VoidMessage()
        return self.stub.testNetworkConf(void, timeout=PulseStreamer.TIMEOUT).value

    def enableStaticIP(self, permanent=False):
        assert permanent in [True, False]
        e=EnableStaticIPMessage()
        e.permanent=permanent
        return self.stub.enableStaticIP(e, timeout=PulseStreamer.TIMEOUT).string_value

    def getUnderflow(self):
        void = VoidMessage()
        return self.stub.getUnderflow(void, timeout=PulseStreamer.TIMEOUT).value

    def getDebugRegister(self):
        void = VoidMessage()
        return self.stub.getDebugRegister(void, timeout=PulseStreamer.PulseStreamer.TIMEOUT).value
    
    def convert_sequence_step(self, sequence_step):
        t, chans, a0, a1 = sequence_step
        assert (abs(a0)<=1 and abs(a1)<=1), "Pulse Streamer 8/2 supports "\
                "analog voltage range of +/-1V" #check hardware
        assert t>=0
        return PulseMessage(ticks=t, digi=self.chans_to_mask(chans), ao0=int(round(0x7fff*a0)), ao1=int(round(0x7fff*a1)))

    def chans_to_mask(self, chans):
        mask = 0
        for chan in chans:
            assert chan in range(8),"Pulse Streamer 8/2 supports "\
            "up to eight digital channels"
            mask |= 1<<chan
        return mask

"""---------Test-Code-------------------------------"""

if __name__ == '__main__':
    pulser = PulseStreamer(ip_hostname='pulsestreamer')

    print("Serial number:", pulser.getSerial())
    print("Firmware Version:", pulser.getFirmwareVersion())

    