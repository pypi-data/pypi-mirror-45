import colorama
from colorama import Fore, init

init(convert=True)

def getStringDocs():
    print(Fore.LIGHTMAGENTA_EX +"\nSTRING METHODS - PYTHON:")
    print(Fore.LIGHTGREEN_EX + "\nstr.capitalize():")
    print(Fore.WHITE + "\tReturns a copy of the string with the first char capitalized\n")
    print(Fore.LIGHTGREEN_EX +"str.casefold():")
    print(Fore.WHITE + "\tReturns a casefolded copy of the string\n")
    print(Fore.LIGHTGREEN_EX +"str.center(width[,fillchar]):")
    print(Fore.WHITE + "\tReturns centered in a string of length width")
    print(Fore.WHITE + "\tpadding is done with fillchar\n")
    print(Fore.LIGHTGREEN_EX +"str.count(sub[,start[,end]]):")
    print(Fore.WHITE + "\tReturns the number of non-overlapping occurances of substring sub in the range [start,end]\n")
    print(Fore.LIGHTGREEN_EX +"str.encode(encoding=utf-8, errors=strict):")
    print(Fore.WHITE + "\tReturns an encoded version of the string as bytes object\n")
    print(Fore.LIGHTGREEN_EX +"str.endswith(suffix[,start[,end]]):")
    print(Fore.WHITE + "\tReturns True if the string ends with the specified suffix (start and end are optional)\n")
    print(Fore.LIGHTGREEN_EX +"str.expandtabs(tabsize=8):")
    print(Fore.WHITE + "\tReturns a copy of the string where all tab chars are replaced by one or more spaces\n")
    print(Fore.WHITE+"\tthis depends on the tab size and column")
    print(Fore.LIGHTGREEN_EX +"str.find(sub[,start[,end]]):")
    print(Fore.WHITE + "\tReturns the lowest index in the string where substring sub is found within the slice s[start:end]")
    print(Fore.WHITE + "\t-1 is returned if sub is not found\n")
    print(Fore.LIGHTGREEN_EX +"str.format(*args, **kwargs):")
    print(Fore.WHITE + "\tReturns a copy of the string where each replacement field is replaced with the string value of the corresponding arguement\n")
    print(Fore.LIGHTGREEN_EX +"str.format_map(mapping):")
    print(Fore.WHITE + "\tSimilar to str.format(**mapping), except that mapping is used directly and not copied into a dict\n")
    print(Fore.LIGHTGREEN_EX +"str.index(sub[,start[end]]):")
    print(Fore.WHITE + "\tLike find() but raises a ValueError when the substring is not found\n")
    print(Fore.LIGHTGREEN_EX +"str.isalnum():")
    print(Fore.WHITE + "\tReturns True if all characters in the string are alphanumeric, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isalpha():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are alphabetic, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isascii():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are ASCII, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isdecimal():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are decimal characters, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isdigit():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are digits, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isidentifier():")
    print(Fore.WHITE + "\tReturns True if the string is a valid identifier according to the language definition\n")
    print(Fore.LIGHTGREEN_EX +"str.islower():")
    print(Fore.WHITE + "\tReturns True if all cased characters in the string are lowercase, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isnumeric():")
    print(Fore.WHITE + "\tReturns True if all characters in the string are numeric characters, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isprintable():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are printable, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isspace():")
    print(Fore.WHITE + "\tReturns True if all the characters in the string are printable, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.istitle():")
    print(Fore.WHITE + "\tReturns True if the string is a titlecased string, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.isupper():")
    print(Fore.WHITE + "\tReturns True if all cased characters in the string are uppercase, False otherwise\n")
    print(Fore.LIGHTGREEN_EX +"str.join(iterable):")
    print(Fore.WHITE + "\tReturns a string which is a concatenation of the string in iterable\n")
    print(Fore.LIGHTGREEN_EX +"str.ljust(width[,fillchar]):")
    print(Fore.WHITE + "\tReturns the string left justified in a string of length width")
    print(Fore.WHITE+"\tpadding is done using fillchar\n")
    print(Fore.LIGHTGREEN_EX +"str.lower():")
    print(Fore.WHITE + "\tReturns a copy of the string with all the cased characters coverted to lowercase\n")
    print(Fore.LIGHTGREEN_EX +"str.lstrip([chars]):")
    print(Fore.WHITE + "\tReturn a copy of the string with leading characters removed\n")
    print(Fore.LIGHTGREEN_EX +"str.maketrans(x[,y[,z]]):")
    print(Fore.WHITE + "\tReturns a translation table usable for str.translate()\n")
    print(Fore.LIGHTGREEN_EX +"str.parition(sep):")
    print(Fore.WHITE + "\tSplits the string at the first occurance of sep")
    print(Fore.WHITE + "\ta 3-Tuple containing the part before sep, sep, and everything after is returned\n")
    print(Fore.LIGHTGREEN_EX +"str.replace(old,new[,count]):")
    print(Fore.WHITE + "\tReturns a copy of the string with all occurances of substring old replaced by new\n")
    print(Fore.LIGHTGREEN_EX +"str.rfind(sub,[,start[,end]]):")
    print(Fore.WHITE + "\tReturns the highest index in the string where substring sub is found (start and end are optional)\n")
    print(Fore.LIGHTGREEN_EX +"str.rindex(sub[,start[,end]]):")
    print(Fore.WHITE + "\tLike rfind() but raises a ValueError when the substring sub is not found\n")
    print(Fore.LIGHTGREEN_EX +"str.rjust(width,[,fillchar]]):")
    print(Fore.WHITE + "\tReturns the string right justified in a string of length width")
    print(Fore.WHITE+"\tpadding is done using fillchar\n")
    print(Fore.LIGHTGREEN_EX +"str.rpartition(sep):")
    print(Fore.WHITE + "\tLike partition() but splits the string at the last occurance of sep\n")
    print(Fore.LIGHTGREEN_EX +"str.rsplit(sep=None, maxsplit=-1):")
    print(Fore.WHITE + "\tReturns a list of the words in the string, using sep as the delimiter string")
    print(Fore.WHITE +"\tat most maxsplit splits are done, the rightmost ones\n")
    print(Fore.LIGHTGREEN_EX +"str.rstrip([chars]):")
    print(Fore.WHITE + "\tReturns a copy of the string with trailing characters removed")
    print(Fore.WHITE +"\t[chars] are the characters that need to be removed\n")
    print(Fore.LIGHTGREEN_EX +"str.split(sep=None, maxsplit=-1):")
    print(Fore.WHITE + "\tReturns a list of the words in the string, using sep as the delimiter string")
    print(Fore.WHITE +"\tat most maxsplit splits are done\n")
    print(Fore.LIGHTGREEN_EX +"str.splitlines([keepends]):")
    print(Fore.WHITE + "\tReturns a list of the lines in the string, breaking at line boundaries")
    print(Fore.WHITE +"\tlinebreaks are not included unless keepends is given and True\n")
    print(Fore.LIGHTGREEN_EX +"str.startswith(prefix[,start[,end]]):")
    print(Fore.WHITE + "\tReturns True if string starts with the prefix, False otherwise")
    print(Fore.WHITE+"\tstart and end are optional\n")
    print(Fore.LIGHTGREEN_EX +"str.strip([chars]):")
    print(Fore.WHITE + "\tReturns a copy of the string with leading and trailing characters removed")
    print(Fore.WHITE+"\t[chars] are the characters that need to be removed\n")
    print(Fore.LIGHTGREEN_EX +"str.swapcase():")
    print(Fore.WHITE + "\tReturns a copy of the string with uppercase chars converted to lowercase and vice versa\n")
    print(Fore.LIGHTGREEN_EX +"str.title():")
    print(Fore.WHITE + "\tReturns a titledcased version of the string\n")
    print(Fore.LIGHTGREEN_EX +"str.translate(table):")
    print(Fore.WHITE + "\tReturns a copy of the string in which each character has been mapped through the given translation table\n")
    print(Fore.LIGHTGREEN_EX +"str.upper():")
    print(Fore.WHITE + "\tReturns a copy of the string with all cased chars converted to uppercase\n")
    print(Fore.LIGHTGREEN_EX +"str.zfill(width):")
    print(Fore.WHITE +"\tReturns a copy of the string left filled with ASCII 0 digits to make a string of length width\n")

def getDictDocs():
    print(Fore.LIGHTMAGENTA_EX +"\nDICTIONARY METHODS - PYTHON:")
    print(Fore.LIGHTGREEN_EX +"\ndict.clear():")
    print(Fore.WHITE + "\tRemoves all items from the dictionary\n")
    print(Fore.LIGHTGREEN_EX +"dict.copy():")
    print(Fore.WHITE + "\tReturns a shallow copy of the dictionary\n")
    print(Fore.LIGHTGREEN_EX +"dict.get(key[,default]):")
    print(Fore.WHITE + "\tReturns the value of key in the dict else default")
    print(Fore.WHITE+"\tif no default is given None takes its place\n")
    print(Fore.LIGHTGREEN_EX +"dict.items():")
    print(Fore.WHITE + "\tReturns a new view of the dictionary's items ((key,value) pairs)\n")
    print(Fore.LIGHTGREEN_EX +"dict.keys():")
    print(Fore.WHITE + "\tReturns a new view of the dictionary's keys\n")
    print(Fore.LIGHTGREEN_EX +"dict.pop(key,[,default]):")
    print(Fore.WHITE + "\tIf a key is in the dict remove it and returns its value else default")
    print(Fore.WHITE+"\tif no default or key a KeyError is raised\n")
    print(Fore.LIGHTGREEN_EX +"dict.popitem():")
    print(Fore.WHITE + "\tRemove and return a (key,value) pair form the dict. LIFO\n")
    print(Fore.LIGHTGREEN_EX +"dict.setdefault(key[,default]):")
    print(Fore.WHITE + "\tIf a key is in the dict return its value")
    print(Fore.WHITE+"\tif not, insert key with a value of default and return default\n")
    print(Fore.LIGHTGREEN_EX +"dict.update([other]):")
    print(Fore.WHITE + "\tUpdate the dict with the key value pairs from other, overwriting existing items")
    print(Fore.WHITE+"\treturns None\n")
    print(Fore.LIGHTGREEN_EX +"dict.values():")
    print(Fore.WHITE + "\tReturns a new view of the dicts values\n")

def getListDocs():
    print(Fore.LIGHTMAGENTA_EX +"\nLIST METHODS - PYTHON:")
    print(Fore.LIGHTGREEN_EX +"\nlist.append(x):")
    print(Fore.WHITE + "\tAdds items to the end of the list\n")
    print(Fore.LIGHTGREEN_EX +"list.clear():")
    print(Fore.WHITE + "\tRemoves all items from the list\n")
    print(Fore.LIGHTGREEN_EX +"list.copy():")
    print(Fore.WHITE + "\tReturns a shallow copy of the list\n")
    print(Fore.LIGHTGREEN_EX +"list.count(x):")
    print(Fore.WHITE + "\tReturns the number of times x appears in the list\n")
    print(Fore.LIGHTGREEN_EX +"list.extend(iterable):")
    print(Fore.WHITE + "\tExtends the list by appending all of the items from iterable\n")
    print(Fore.LIGHTGREEN_EX +"list.index(x[,start[,end]]):")
    print(Fore.WHITE + "\tReturn zero-based index in the list of the first item whose value is x")
    print(Fore.WHITE +"\traises a ValueError if no such item\n")
    print(Fore.LIGHTGREEN_EX +"list.insert(i,x):")
    print(Fore.WHITE + "\tInserts an item at the given position\n")
    print(Fore.LIGHTGREEN_EX +"list.pop([i]):")
    print(Fore.WHITE + "\tRemoves the item at the given position and returns it\n")
    print(Fore.LIGHTGREEN_EX +"list.remove(x):")
    print(Fore.WHITE + "\tRemoves the first item from the list whose value is x")
    print(Fore.WHITE +"\traises a ValueError if no such item\n")
    print(Fore.LIGHTGREEN_EX +"list.reverse():")
    print(Fore.WHITE + "\tReverses the elements of the list in place\n")
    print(Fore.LIGHTGREEN_EX +"list.sort(key=None, reverse=False)")
    print(Fore.WHITE + "\tSorts the items of the list in place\n")

def getSetDocs():
    print(Fore.LIGHTMAGENTA_EX +"\nSET METHODS - PYTHON:")
    print(Fore.LIGHTGREEN_EX +"\nset.add(element):")
    print(Fore.WHITE + "\tAdd element to the set\n")
    print(Fore.LIGHTGREEN_EX +"set.clear():")
    print(Fore.WHITE + "\tRemoves all the elements from the set\n")
    print(Fore.LIGHTGREEN_EX +"set.copy(element):")
    print(Fore.WHITE + "\tReturns a shallow copy of the set\n")
    print(Fore.LIGHTGREEN_EX +"set.difference(*others):")
    print(Fore.WHITE + "\tReturns a new set with elements in the set that are not in the others\n")
    print(Fore.LIGHTGREEN_EX +"set.difference_update(*others):")
    print(Fore.WHITE + "\tUpdate the set, removing elements found in others\n")
    print(Fore.LIGHTGREEN_EX +"set.discard(element):")
    print(Fore.WHITE + "\tRemove the element from the set if it present\n")
    print(Fore.LIGHTGREEN_EX +"set.intersection(*others):")
    print(Fore.WHITE + "\tReturns a new set with the elements common to the set and all others\n")
    print(Fore.LIGHTGREEN_EX +"set.intersection_update(*others):")
    print(Fore.WHITE + "\tUpdate the set, keeping only elements found in others\n")
    print(Fore.LIGHTGREEN_EX +"set.isdisjoint(other):")
    print(Fore.WHITE + "\tReturns True if the set has no elements in common with other\n")
    print(Fore.LIGHTGREEN_EX +"set.issubset(other):")
    print(Fore.WHITE + "\tTests whether every element in the set is in other\n")
    print(Fore.LIGHTGREEN_EX +"set.issuperset(other):")
    print(Fore.WHITE + "\tTests whether every element in other is in the set\n")
    print(Fore.LIGHTGREEN_EX +"set.pop():")
    print(Fore.WHITE + "\tRemoves and return an arbitrary element from the set")
    print(Fore.WHITE+"\traises KeyError if the set is empty\n")
    print(Fore.LIGHTGREEN_EX +"set.remove(element):")
    print(Fore.WHITE + "\tRemoves element from the set. Raises KeyError if the element is not in the set\n")
    print(Fore.LIGHTGREEN_EX +"set.symmetric_difference(other):")
    print(Fore.WHITE + "\tReturns a new set with elements in either the set or other but not both\n")
    print(Fore.LIGHTGREEN_EX +"set.symmetric_difference_update(others):")
    print(Fore.WHITE + "\tUpdate the set, keeping only elements found in either set, but not in both\n")
    print(Fore.LIGHTGREEN_EX +"set.union(*others):")
    print(Fore.WHITE + "\tReturns a new set with elements from the set and all others\n")
    print(Fore.LIGHTGREEN_EX +"set.update(*others):")
    print(Fore.WHITE + "\tUpdate the set, adding elements from all others\n")
