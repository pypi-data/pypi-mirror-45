Metadata-Version: 2.1
Name: mcresources
Version: 0.0.2
Summary: An automatic resource creation tool for Minecraft 1.13 Forge modding
Home-page: https://github.com/alcatrazEscapee/mcresources
Author: Alex O'Neill
Author-email: alex@molleroneill.com
License: GPL-3.0
Description: # Minecraft Resource Generator
        
        This is a python module aimed to enable simple generation of the many json files that are required for forge modding.
        
        Some examples from No Tree Punching 1.13 by AlcatrazEscapee:
        
        ```python
        from mcresources import ResourceManager
        rm = ResourceManager('notreepunching')
        
        for stone in ['stone', 'sandstone', 'andesite', 'granite', 'diorite']:
            # Block States
            rm.blockstate(('loose_rock', stone))
            # Block Models
            rm.block_model(('loose_rock', stone), 'minecraft:block/%s' % stone, 'notreepunching:block/loose_rock')
            # Item Models
            rm.item_model(('rock', stone))
            # Crafting Recipes
            result = ('cobblestone' if stone == 'stone' else stone)
            rm.crafting_shaped('%s_from_rocks' % result, ['##', '##'], 'notreepunching:rock/%s' % stone, 'minecraft:%s' % result)
        
        # Item Models
        for tool in ['pickaxe', 'shovel', 'axe', 'hoe', 'knife']:
            rm.item_model('flint_%s' % tool, parent='item/handheld')
            
        # Shaped Crafting
        for metal in ['iron', 'gold', 'diamond']:
            tool_metal = 'tag!forge:' + ('gems' if metal == 'diamond' else 'ingots') + '/' + metal
            metal_prefix = metal if metal != 'gold' else 'golden'
            rm.crafting_shaped('%s_knife' % metal, ['I', 'S'], {'I': tool_metal, 'S': 'tag!forge:rods/wooden'}, 'notreepunching:%s_knife' % metal_prefix)
        
        # More Crafting Recipes
        rm.crafting_shapeless('plant_string', ['notreepunching:plant_fiber'] * 3, 'notreepunching:plant_string')
        ```
        
        ---
        ### Usage
        
        mcresources can build many common files that are required for forge modding, and provide utilities to manage a larger project. The following is an outline of the various methods and how to use them in the most efficient manner.
        
        All files generated by mcresources will have a comment (`'__comment__'`) inserted to identify them. This also allows mcresources via the usage of `clean_generated_resources()` to delete all files that have been generated, allowing the user to see which ones are created manually, and/or manage updating older files to a newer configuration
        
        A few elements are common to multiple methods:
         - `name_parts`: This represents the resource location for a specific block or item. It can be specified as a string, i.e. `'block_ruby_ore'`, or as a list or tuple if the block uses directories as separators. This means that `('ore_blocks', 'ruby')` corresponds to the resource location `modid:ore_blocks/ruby`, and the resulting file `ruby.json` would be found in `modid/blockstates/ore_blocks/`
        
         - `conditions`: A single condition can either be specified as a fully specified dictionary (which will be inserted into the json verbatim), or as a string, which will be expanded to `{ 'type': string_condition }`
         
         - `item stacks`: An item stack can be specified as a fully specified dictionary (which will be inserted into the json verbatim), or as a string. As a string, it must represent an item resource location, i.e. `minecraft:golden_boots` will create the json `{ 'item': 'minecraft:golden_boots' }`. Additionally, you can prefix the string with `tag!` to specify that it represents a tag, i.e. `tag!forge:rods/wooden` will create the json `{ 'tag': 'forge:rods/wooden' }`
        
        ##### Blockstates
        ```python
        def blockstate(self, name_parts: str or list or tuple, model: str = None, variants: dict = None)
        ```
         - `name_parts` specifies the block resource location, as seen above
         - `model` specifies the model. If not present, it will default to `modid:block/name/parts`, meaning `blockstate('pink_grass')` will create the file `modid/blockstates/pink_grass.json`, which has a model of `modid:block/pink_grass`
         - `variants` specifies the variants as found in the json file. It should be a dictionary as per usual minecraft blockstate files. If it isn't present, it will default to an empty / single variant block: `'variants': { '': model }`
        
        ##### Block Models
        ```python
        def block_model(self, name_parts: str or list or tuple, textures: str or dict = None,
                            parent: str = 'cube_all')
        ```
         - `name_parts` specifies the block resource location, as seen above
         - `textures` specifies the textures for this specific model. If it is a string, it will create the json: `'textures': { 'texture': textures }`. If provided as a dictionary, it will insert `'textures': textures`
         - `parent` specifies the parent model file
        
        ##### Item Models
        ```python
        def item_model(self, name_parts: str or list or tuple, *textures: str or dict, parent: str = 'item/generated')
        ```
         - `name_parts` specifies the item resource location, as seen above
         - `textures` specifies the textures. If textures are supplied as strings, i.e. `'base_layer', 'middle_layer' ...`, it will assign them sequentially to layers, i.e. `{ 'layer0': 'base_layer', 'layer1': 'middle_layer' ... }`. If a dictionary is provided, it will insert those in the same way as the block model
         - `parent` specifies the parent model file
        
        ##### Shapeless Crafting Recipes
        ```python
        def crafting_shapeless(self, name_parts: str or list or tuple, ingredients: str or dict or list or tuple, result: str or dict, group: str = None, conditions: str or dict or list = None)
        ```
         - `name_parts` specifies the recipe resource location. Note crafting recipes are automatically added to `modid/data/recipes`
         - `inredients` specifies the ingredients. It must be either a list / tuple of item stacks, or a string or dictionary representing an item stack. See above for valid item stack specifications.
         - `result` specifies the recipe result or output. It must be a single item stack
         - `group` specifies the group the recipe belongs to
         - `conditions` specifies any conditions on the recipe being enabled. It must be a list / tuple of valid condition identifiers, or a string or dictionary representing an item stack
        
        ##### Shaped Crafting Recipes
        ```python
        def crafting_shaped(self, name_parts: str or list or tuple, pattern: list, ingredients: str or dict, result, group: str = None, conditions: str or dict or list = None)
        ```
         - `name_parts` specifies the recipe resource location. Note crafting recipes are automatically added to `modid/data/recipes`
         - `pattern` specifies the pattern. It must be a list of strings, i.e. `['XXX', ' S ', ' S ']` for a pickaxe pattern. The keys must be the same as used in the ingredients field.
         - `inredients` specifies the ingredients. It can be a dictionary of single character keys to item stacks, or it can be a single item stack (which will default to the first key found, and as such should only be used if there is only one unique input)
         - `result` specifies the recipe result or output. It must be a single item stack
         - `group` is as above
         - `conditions` is as above
        
        ##### Other Recipes
        ```python
        def recipe(self, name_parts: str or list or tuple, type_in: str, data_in: dict, group: str = None, conditions: str or dict or list = None)
        ```
        This is used to create modded recipes that are loaded via custom deserializers. As such, `name_parts` needs to include a subdirectory for the recipe type
         - `name_parts` specifies the recipe resource location.
         - `type_in` specifies the recipe type
         - `data_in` specifies the json data to be inserted into the recipe
         - `group` is as above
         - `conditions` is as above
        
        ##### Tags
        ```python
        def item_tag(self, name_parts: str or list or tuple, *values: str or list or tuple, replace: bool = False)
        def block_tag(self, name_parts: str or list or tuple, *values: str or list, replace: bool = False)
        ```
        These are used to create item and block tags respectively
         - `name_parts` specifies the tag resource location, as seen above
         - `values` specifies the values. It can be a single string for one value, or a list / tuple of strings for multiple values
         - `replace` specifies the replace field in the json, i.e. if the tag should replace a previous identical entry
        
        
Keywords: python,minecraft,resources,modding,forge
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
Classifier: Programming Language :: Python :: 3.7
Description-Content-Type: text/markdown
