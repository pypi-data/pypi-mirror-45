Metadata-Version: 2.1
Name: pandas-refract
Version: 1.2.5
Summary: Unofficial convenience functions that deal with fragmenting Pandas dataframes.
Home-page: https://gitlab.com/ittVannak/pandas-refract
Author: Nicholas Lawrence
Author-email: nickclawrence@gmail.com
License: MIT
Platform: UNKNOWN
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Dist: numpy (>=1.16.2)


==================================================================
``pandas-refract``: Convenient dataframe fragmentation functions
==================================================================

**pandas-refract** is an MIT licensed Python package with a simple function that allows users to divide their 
dataframes by the 'Truthy' and 'Falseyness' of a provided array.

Because this library deals with splitting dataframes by its values, it uses imagery of light - refract and disperse, like light entering a prism.
Eventually, the goal of this package is additional features to the Pandas library that allows users to .pop rows
from a dataframe where a condition is met, etc. As far as I can tell this is not possible like the below example.

Ideal case would be::

    target_df = df.pop(df['target_column'] == 'target_value')
    non_target_df = df

What is required now is::

    target_df = df[df['target_column'] == 'target_value'] 
    non_target_df = df[df['target_column'] != 'target_value']

With pandas-refract this becomes::

    target_df, non_target_df = refract(df, df['target_column'] == 'target_value']]


Obviously, this package is not providing anything not currently possible in the current Pandas library. It does,
however, add a layer of convenience for more complex slicing where you need to separate, not remove, rows by conditions.


Examples
========

Simplest example of current Pandas requires::

    df1 = df[df.column.notnull()].reset_index(drop=True)
    df2 = df[df.column.isnull()].reset_index(drop=True)

or::

    df1 = df[df.column == 'test_string'].reset_index(drop=True)
    df2 = df[df.column != 'test_string'].reset_index(drop=True)


With pandas-refract this becomes::

    df1, df2 = refract(df, df.column.notnull(), True]

and::

    df1, df2 = refract(df, df.column == test_string', True]   


But you don't have to pass it explicit boolean arrays::

    data = {'a': ['', 'truthy', '', 'truthy'],
            'b': [0, 1, 2, 3]
            }

    df = pd.DataFrame(data)

    truthy_df, falsey_df = refract(df, df.a)


More complex examples:
*(where 'a' is Falsey and 'b' is an odd number)*
::

    df1, df2 = refract(df, ((~df.a) & (df.b % 2 == 1)))



