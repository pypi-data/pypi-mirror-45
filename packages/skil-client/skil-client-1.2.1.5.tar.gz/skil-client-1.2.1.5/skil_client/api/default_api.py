# coding: utf-8

"""
    Endpoints

    Endpoints API for different services in SKIL  # noqa: E501

    OpenAPI spec version: 1.2.0-rc1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from skil_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accumulated_results(self, **kwargs):  # noqa: E501
        """Tells how many retraining examples have labels associated with them.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accumulated_results(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AccumulatedResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.accumulated_results_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accumulated_results_with_http_info(**kwargs)  # noqa: E501
            return data

    def accumulated_results_with_http_info(self, **kwargs):  # noqa: E501
        """Tells how many retraining examples have labels associated with them.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.accumulated_results_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AccumulatedResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accumulated_results" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/accumulatedresults', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccumulatedResults',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_credentials(self, add_credentials_request, **kwargs):  # noqa: E501
        """Adds credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_credentials(add_credentials_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddCredentialsRequest add_credentials_request: Add credentials request object (required)
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_credentials_with_http_info(add_credentials_request, **kwargs)  # noqa: E501
        else:
            (data) = self.add_credentials_with_http_info(add_credentials_request, **kwargs)  # noqa: E501
            return data

    def add_credentials_with_http_info(self, add_credentials_request, **kwargs):  # noqa: E501
        """Adds credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_credentials_with_http_info(add_credentials_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddCredentialsRequest add_credentials_request: Add credentials request object (required)
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['add_credentials_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_credentials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'add_credentials_request' is set
        if ('add_credentials_request' not in params or
                params['add_credentials_request'] is None):
            raise ValueError("Missing the required parameter `add_credentials_request` when calling `add_credentials`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_credentials_request' in params:
            body_params = params['add_credentials_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceCredentials',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_evaluation_result(self, model_history_server_id, evaluation_results_entity, **kwargs):  # noqa: E501
        """Adds an evaluation result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_evaluation_result(model_history_server_id, evaluation_results_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param EvaluationResultsEntity evaluation_results_entity: The evaluation result entity (required)
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_evaluation_result_with_http_info(model_history_server_id, evaluation_results_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.add_evaluation_result_with_http_info(model_history_server_id, evaluation_results_entity, **kwargs)  # noqa: E501
            return data

    def add_evaluation_result_with_http_info(self, model_history_server_id, evaluation_results_entity, **kwargs):  # noqa: E501
        """Adds an evaluation result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_evaluation_result_with_http_info(model_history_server_id, evaluation_results_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param EvaluationResultsEntity evaluation_results_entity: The evaluation result entity (required)
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'evaluation_results_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_evaluation_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_evaluation_result`")  # noqa: E501
        # verify the required parameter 'evaluation_results_entity' is set
        if ('evaluation_results_entity' not in params or
                params['evaluation_results_entity'] is None):
            raise ValueError("Missing the required parameter `evaluation_results_entity` when calling `add_evaluation_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'evaluation_results_entity' in params:
            body_params = params['evaluation_results_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions/evaluations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_example_for_batch(self, model_history_server_id, add_example_request, **kwargs):  # noqa: E501
        """Adds a number of examples to a minibatch ID given an AddExampleRequest.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_example_for_batch(model_history_server_id, add_example_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddExampleRequest add_example_request: The add example request, encapsulating minibatch details and examples batch size (required)
        :return: AddExampleRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_example_for_batch_with_http_info(model_history_server_id, add_example_request, **kwargs)  # noqa: E501
        else:
            (data) = self.add_example_for_batch_with_http_info(model_history_server_id, add_example_request, **kwargs)  # noqa: E501
            return data

    def add_example_for_batch_with_http_info(self, model_history_server_id, add_example_request, **kwargs):  # noqa: E501
        """Adds a number of examples to a minibatch ID given an AddExampleRequest.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_example_for_batch_with_http_info(model_history_server_id, add_example_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddExampleRequest add_example_request: The add example request, encapsulating minibatch details and examples batch size (required)
        :return: AddExampleRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'add_example_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_example_for_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_example_for_batch`")  # noqa: E501
        # verify the required parameter 'add_example_request' is set
        if ('add_example_request' not in params or
                params['add_example_request'] is None):
            raise ValueError("Missing the required parameter `add_example_request` when calling `add_example_for_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_example_request' in params:
            body_params = params['add_example_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/exampleForBatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddExampleRequest',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_example_to_minibatch(self, model_history_server_id, example_entity, **kwargs):  # noqa: E501
        """Adds an example to a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_example_to_minibatch(model_history_server_id, example_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExampleEntity example_entity: The example to add to the minibatch (required)
        :return: ExampleEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_example_to_minibatch_with_http_info(model_history_server_id, example_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.add_example_to_minibatch_with_http_info(model_history_server_id, example_entity, **kwargs)  # noqa: E501
            return data

    def add_example_to_minibatch_with_http_info(self, model_history_server_id, example_entity, **kwargs):  # noqa: E501
        """Adds an example to a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_example_to_minibatch_with_http_info(model_history_server_id, example_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExampleEntity example_entity: The example to add to the minibatch (required)
        :return: ExampleEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'example_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_example_to_minibatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_example_to_minibatch`")  # noqa: E501
        # verify the required parameter 'example_entity' is set
        if ('example_entity' not in params or
                params['example_entity'] is None):
            raise ValueError("Missing the required parameter `example_entity` when calling `add_example_to_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'example_entity' in params:
            body_params = params['example_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/example', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExampleEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_experiment(self, model_history_server_id, experiment_entity, **kwargs):  # noqa: E501
        """Add an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_experiment(model_history_server_id, experiment_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExperimentEntity experiment_entity: The experiment entity to add (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_experiment_with_http_info(model_history_server_id, experiment_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.add_experiment_with_http_info(model_history_server_id, experiment_entity, **kwargs)  # noqa: E501
            return data

    def add_experiment_with_http_info(self, model_history_server_id, experiment_entity, **kwargs):  # noqa: E501
        """Add an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_experiment_with_http_info(model_history_server_id, experiment_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExperimentEntity experiment_entity: The experiment entity to add (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'experiment_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_entity' is set
        if ('experiment_entity' not in params or
                params['experiment_entity'] is None):
            raise ValueError("Missing the required parameter `experiment_entity` when calling `add_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_entity' in params:
            body_params = params['experiment_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_feedback_binary(self, id, type, **kwargs):  # noqa: E501
        """add_feedback_binary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_feedback_binary(id, type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param str type: The type of the labels array. (required)
        :param file file: The labels file to upload.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_feedback_binary_with_http_info(id, type, **kwargs)  # noqa: E501
        else:
            (data) = self.add_feedback_binary_with_http_info(id, type, **kwargs)  # noqa: E501
            return data

    def add_feedback_binary_with_http_info(self, id, type, **kwargs):  # noqa: E501
        """add_feedback_binary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_feedback_binary_with_http_info(id, type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param str type: The type of the labels array. (required)
        :param file file: The labels file to upload.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'type', 'file']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_feedback_binary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_feedback_binary`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `add_feedback_binary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feedback/{id}/{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_feedback_json(self, id, **kwargs):  # noqa: E501
        """Gets the retraining feedback for the given batch ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_feedback_json(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param list[list[float]] labels: The associated labels (one-hot vectors) with the batch for retraining.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_feedback_json_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_feedback_json_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def add_feedback_json_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the retraining feedback for the given batch ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_feedback_json_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param list[list[float]] labels: The associated labels (one-hot vectors) with the batch for retraining.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'labels']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_feedback_json" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_feedback_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'labels' in params:
            body_params = params['labels']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feedback/{id}/json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_minibatch(self, model_history_server_id, minibatch_entity, **kwargs):  # noqa: E501
        """Adds a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_minibatch(model_history_server_id, minibatch_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param MinibatchEntity minibatch_entity: The minibatch entity to add (required)
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_minibatch_with_http_info(model_history_server_id, minibatch_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.add_minibatch_with_http_info(model_history_server_id, minibatch_entity, **kwargs)  # noqa: E501
            return data

    def add_minibatch_with_http_info(self, model_history_server_id, minibatch_entity, **kwargs):  # noqa: E501
        """Adds a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_minibatch_with_http_info(model_history_server_id, minibatch_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param MinibatchEntity minibatch_entity: The minibatch entity to add (required)
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'minibatch_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_minibatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_entity' is set
        if ('minibatch_entity' not in params or
                params['minibatch_entity'] is None):
            raise ValueError("Missing the required parameter `minibatch_entity` when calling `add_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'minibatch_entity' in params:
            body_params = params['minibatch_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/minibatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibatchEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_feedback(self, model_history_server_id, model_feed_back_request, **kwargs):  # noqa: E501
        """Adds an evaluation feedback to the model against a given minibatch id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_feedback(model_history_server_id, model_feed_back_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelFeedBackRequest model_feed_back_request: The model feedback request object (required)
        :return: ModelFeedBackRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_model_feedback_with_http_info(model_history_server_id, model_feed_back_request, **kwargs)  # noqa: E501
        else:
            (data) = self.add_model_feedback_with_http_info(model_history_server_id, model_feed_back_request, **kwargs)  # noqa: E501
            return data

    def add_model_feedback_with_http_info(self, model_history_server_id, model_feed_back_request, **kwargs):  # noqa: E501
        """Adds an evaluation feedback to the model against a given minibatch id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_feedback_with_http_info(model_history_server_id, model_feed_back_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelFeedBackRequest model_feed_back_request: The model feedback request object (required)
        :return: ModelFeedBackRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_feed_back_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_feedback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_model_feedback`")  # noqa: E501
        # verify the required parameter 'model_feed_back_request' is set
        if ('model_feed_back_request' not in params or
                params['model_feed_back_request'] is None):
            raise ValueError("Missing the required parameter `model_feed_back_request` when calling `add_model_feedback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_feed_back_request' in params:
            body_params = params['model_feed_back_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/feedback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelFeedBackRequest',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_history(self, model_history_server_id, add_model_history_request, **kwargs):  # noqa: E501
        """Add a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_history(model_history_server_id, add_model_history_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddModelHistoryRequest add_model_history_request: The model history request object (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_model_history_with_http_info(model_history_server_id, add_model_history_request, **kwargs)  # noqa: E501
        else:
            (data) = self.add_model_history_with_http_info(model_history_server_id, add_model_history_request, **kwargs)  # noqa: E501
            return data

    def add_model_history_with_http_info(self, model_history_server_id, add_model_history_request, **kwargs):  # noqa: E501
        """Add a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_history_with_http_info(model_history_server_id, add_model_history_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddModelHistoryRequest add_model_history_request: The model history request object (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'add_model_history_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_model_history`")  # noqa: E501
        # verify the required parameter 'add_model_history_request' is set
        if ('add_model_history_request' not in params or
                params['add_model_history_request'] is None):
            raise ValueError("Missing the required parameter `add_model_history_request` when calling `add_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_model_history_request' in params:
            body_params = params['add_model_history_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_instance(self, model_history_server_id, model_instance_entity, **kwargs):  # noqa: E501
        """Adds a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_instance(model_history_server_id, model_instance_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelInstanceEntity model_instance_entity: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_model_instance_with_http_info(model_history_server_id, model_instance_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.add_model_instance_with_http_info(model_history_server_id, model_instance_entity, **kwargs)  # noqa: E501
            return data

    def add_model_instance_with_http_info(self, model_history_server_id, model_instance_entity, **kwargs):  # noqa: E501
        """Adds a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_model_instance_with_http_info(model_history_server_id, model_instance_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelInstanceEntity model_instance_entity: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_instance_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `add_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_entity' is set
        if ('model_instance_entity' not in params or
                params['model_instance_entity'] is None):
            raise ValueError("Missing the required parameter `model_instance_entity` when calling `add_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_instance_entity' in params:
            body_params = params['model_instance_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource(self, add_resource_request, **kwargs):  # noqa: E501
        """Adds a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource(add_resource_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddResourceRequest add_resource_request: The Add resource request object (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_resource_with_http_info(add_resource_request, **kwargs)  # noqa: E501
        else:
            (data) = self.add_resource_with_http_info(add_resource_request, **kwargs)  # noqa: E501
            return data

    def add_resource_with_http_info(self, add_resource_request, **kwargs):  # noqa: E501
        """Adds a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource_with_http_info(add_resource_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddResourceRequest add_resource_request: The Add resource request object (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['add_resource_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'add_resource_request' is set
        if ('add_resource_request' not in params or
                params['add_resource_request'] is None):
            raise ValueError("Missing the required parameter `add_resource_request` when calling `add_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_resource_request' in params:
            body_params = params['add_resource_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource_group(self, group_name, **kwargs):  # noqa: E501
        """Adds a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource_group(group_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group_name: Name of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_resource_group_with_http_info(group_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_resource_group_with_http_info(group_name, **kwargs)  # noqa: E501
            return data

    def add_resource_group_with_http_info(self, group_name, **kwargs):  # noqa: E501
        """Adds a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource_group_with_http_info(group_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group_name: Name of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_name' is set
        if ('group_name' not in params or
                params['group_name'] is None):
            raise ValueError("Missing the required parameter `group_name` when calling `add_resource_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_name' in params:
            body_params = params['group_name']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/group', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource_to_group(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Adds a resource to a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource_to_group(resource_group_id, resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_resource_to_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_resource_to_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501
            return data

    def add_resource_to_group_with_http_info(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Adds a resource to a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_resource_to_group_with_http_info(resource_group_id, resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_group_id', 'resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource_to_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in params or
                params['resource_group_id'] is None):
            raise ValueError("Missing the required parameter `resource_group_id` when calling `add_resource_to_group`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `add_resource_to_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in params:
            path_params['resourceGroupId'] = params['resource_group_id']  # noqa: E501
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/resourcetogroup/{resourceGroupId}/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def aggregate_model_results(self, model_history_server_id, aggregate_prediction, **kwargs):  # noqa: E501
        """Aggregates the evaluaition results of a model instance, based on the evaluation type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.aggregate_model_results(model_history_server_id, aggregate_prediction, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AggregatePrediction aggregate_prediction: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.aggregate_model_results_with_http_info(model_history_server_id, aggregate_prediction, **kwargs)  # noqa: E501
        else:
            (data) = self.aggregate_model_results_with_http_info(model_history_server_id, aggregate_prediction, **kwargs)  # noqa: E501
            return data

    def aggregate_model_results_with_http_info(self, model_history_server_id, aggregate_prediction, **kwargs):  # noqa: E501
        """Aggregates the evaluaition results of a model instance, based on the evaluation type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.aggregate_model_results_with_http_info(model_history_server_id, aggregate_prediction, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AggregatePrediction aggregate_prediction: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'aggregate_prediction']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregate_model_results" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `aggregate_model_results`")  # noqa: E501
        # verify the required parameter 'aggregate_prediction' is set
        if ('aggregate_prediction' not in params or
                params['aggregate_prediction'] is None):
            raise ValueError("Missing the required parameter `aggregate_prediction` when calling `aggregate_model_results`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregate_prediction' in params:
            body_params = params['aggregate_prediction']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/aggregateresults', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_user_password(self, user_id, change_password_request, **kwargs):  # noqa: E501
        """Change user&#39;s password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.change_user_password(user_id, change_password_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :param ChangePasswordRequest change_password_request: Password details. (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.change_user_password_with_http_info(user_id, change_password_request, **kwargs)  # noqa: E501
        else:
            (data) = self.change_user_password_with_http_info(user_id, change_password_request, **kwargs)  # noqa: E501
            return data

    def change_user_password_with_http_info(self, user_id, change_password_request, **kwargs):  # noqa: E501
        """Change user&#39;s password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.change_user_password_with_http_info(user_id, change_password_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :param ChangePasswordRequest change_password_request: Password details. (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'change_password_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_user_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `change_user_password`")  # noqa: E501
        # verify the required parameter 'change_password_request' is set
        if ('change_password_request' not in params or
                params['change_password_request'] is None):
            raise ValueError("Missing the required parameter `change_password_request` when calling `change_user_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_request' in params:
            body_params = params['change_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/{userId}/password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classify(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classify(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.classify_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.classify_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def classify_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classify_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `classify`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `classify`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `classify`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `classify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classifyarray(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Same as /classify but returns the output as Base64NDArrayBody  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classifyarray(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.classifyarray_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.classifyarray_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def classifyarray_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Same as /classify but returns the output as Base64NDArrayBody  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classifyarray_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classifyarray" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `classifyarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classifyimage(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classifyimage(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.classifyimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.classifyimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def classifyimage_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.classifyimage_with_http_info(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name', 'image']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classifyimage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `classifyimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `classifyimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `classifyimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_state(self, **kwargs):  # noqa: E501
        """Clears the accumulated data for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.clear_state(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.clear_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.clear_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def clear_state_with_http_info(self, **kwargs):  # noqa: E501
        """Clears the accumulated data for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.clear_state_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/clear', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_job(self, job_id_or_type, create_job_request, **kwargs):  # noqa: E501
        """Create a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_job(job_id_or_type, create_job_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str job_id_or_type: Job Type (required)
        :param CreateJobRequest create_job_request: Create job request object (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_job_with_http_info(job_id_or_type, create_job_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_job_with_http_info(job_id_or_type, create_job_request, **kwargs)  # noqa: E501
            return data

    def create_job_with_http_info(self, job_id_or_type, create_job_request, **kwargs):  # noqa: E501
        """Create a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_job_with_http_info(job_id_or_type, create_job_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str job_id_or_type: Job Type (required)
        :param CreateJobRequest create_job_request: Create job request object (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id_or_type', 'create_job_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in params or
                params['job_id_or_type'] is None):
            raise ValueError("Missing the required parameter `job_id_or_type` when calling `create_job`")  # noqa: E501
        # verify the required parameter 'create_job_request' is set
        if ('create_job_request' not in params or
                params['create_job_request'] is None):
            raise ValueError("Missing the required parameter `create_job_request` when calling `create_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in params:
            path_params['jobIdOrType'] = params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_job_request' in params:
            body_params = params['create_job_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_model_history(self, model_history_server_id, model_history_entity, **kwargs):  # noqa: E501
        """Creates model History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_model_history(model_history_server_id, model_history_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelHistoryEntity model_history_entity: The model history entity (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_model_history_with_http_info(model_history_server_id, model_history_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.create_model_history_with_http_info(model_history_server_id, model_history_entity, **kwargs)  # noqa: E501
            return data

    def create_model_history_with_http_info(self, model_history_server_id, model_history_entity, **kwargs):  # noqa: E501
        """Creates model History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_model_history_with_http_info(model_history_server_id, model_history_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelHistoryEntity model_history_entity: The model history entity (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_history_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `create_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_entity' is set
        if ('model_history_entity' not in params or
                params['model_history_entity'] is None):
            raise ValueError("Missing the required parameter `model_history_entity` when calling `create_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_history_entity' in params:
            body_params = params['model_history_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_credentials_by_id(self, credential_id, **kwargs):  # noqa: E501
        """Delete credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_credentials_by_id(credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int credential_id: Credentials ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501
            return data

    def delete_credentials_by_id_with_http_info(self, credential_id, **kwargs):  # noqa: E501
        """Delete credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_credentials_by_id_with_http_info(credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int credential_id: Credentials ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['credential_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_credentials_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in params or
                params['credential_id'] is None):
            raise ValueError("Missing the required parameter `credential_id` when calling `delete_credentials_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credential_id' in params:
            path_params['credentialId'] = params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials/{credentialId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Deletes an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_experiment(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to delete (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
            return data

    def delete_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Deletes an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_experiment_with_http_info(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to delete (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `delete_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `delete_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in params:
            path_params['experimentID'] = params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job_by_id(self, job_id_or_type, **kwargs):  # noqa: E501
        """Deletes a job given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_job_by_id(job_id_or_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id_or_type: Job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501
            return data

    def delete_job_by_id_with_http_info(self, job_id_or_type, **kwargs):  # noqa: E501
        """Deletes a job given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_job_by_id_with_http_info(job_id_or_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id_or_type: Job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id_or_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in params or
                params['job_id_or_type'] is None):
            raise ValueError("Missing the required parameter `job_id_or_type` when calling `delete_job_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in params:
            path_params['jobIdOrType'] = params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Delete a model by deployment and model id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model(deployment_id, model_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_model_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501
            return data

    def delete_model_with_http_info(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Delete a model by deployment and model id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model_with_http_info(deployment_id, model_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id', 'model_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `delete_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `delete_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Deletes a model history / workspace, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model_history(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to delete (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
            return data

    def delete_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Deletes a model history / workspace, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model_history_with_http_info(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to delete (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `delete_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in params or
                params['model_history_id'] is None):
            raise ValueError("Missing the required parameter `model_history_id` when calling `delete_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in params:
            path_params['modelHistoryID'] = params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_instance(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Deletes a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model_instance(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
            return data

    def delete_model_instance_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Deletes a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_model_instance_with_http_info(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `delete_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in params or
                params['model_instance_id'] is None):
            raise ValueError("Missing the required parameter `model_instance_id` when calling `delete_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in params:
            path_params['modelInstanceID'] = params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/{modelInstanceID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Delete the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_by_id(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def delete_resource_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Delete the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_by_id_with_http_info(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `delete_resource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/resource/{resourceId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_from_group(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Removes a resource from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_from_group(resource_group_id, resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_resource_from_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_resource_from_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501
            return data

    def delete_resource_from_group_with_http_info(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Removes a resource from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_from_group_with_http_info(resource_group_id, resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_group_id', 'resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_from_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in params or
                params['resource_group_id'] is None):
            raise ValueError("Missing the required parameter `resource_group_id` when calling `delete_resource_from_group`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `delete_resource_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in params:
            path_params['resourceGroupId'] = params['resource_group_id']  # noqa: E501
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/resourcefromgroup/{resourceGroupId}/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_group_by_id(self, resource_group_id, **kwargs):  # noqa: E501
        """Delete the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_group_by_id(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501
            return data

    def delete_resource_group_by_id_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Delete the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_resource_group_by_id_with_http_info(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in params or
                params['resource_group_id'] is None):
            raise ValueError("Missing the required parameter `resource_group_id` when calling `delete_resource_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in params:
            path_params['resourceGroupId'] = params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/group/{resourceGroupId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_model(self, deployment_id, body, **kwargs):  # noqa: E501
        """Deploy a model in a deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deploy_model(deployment_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param ImportModelRequest body: the model import request (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deploy_model_with_http_info(deployment_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.deploy_model_with_http_info(deployment_id, body, **kwargs)  # noqa: E501
            return data

    def deploy_model_with_http_info(self, deployment_id, body, **kwargs):  # noqa: E501
        """Deploy a model in a deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deploy_model_with_http_info(deployment_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param ImportModelRequest body: the model import request (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `deploy_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `deploy_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_create(self, body, **kwargs):  # noqa: E501
        """Create a new deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_create(body, async=True)
        >>> result = thread.get()

        :param async bool
        :param CreateDeploymentRequest body: the deployment request (required)
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deployment_create_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.deployment_create_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def deployment_create_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_create_with_http_info(body, async=True)
        >>> result = thread.get()

        :param async bool
        :param CreateDeploymentRequest body: the deployment request (required)
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `deployment_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_delete(self, deployment_id, **kwargs):  # noqa: E501
        """Delete a deployment by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_delete(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: Id of the deployment group (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deployment_delete_with_http_info(deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deployment_delete_with_http_info(deployment_id, **kwargs)  # noqa: E501
            return data

    def deployment_delete_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Delete a deployment by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_delete_with_http_info(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: Id of the deployment group (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `deployment_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_get(self, deployment_id, **kwargs):  # noqa: E501
        """Get a deployment details by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_get(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: Id of the deployment group (required)
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deployment_get_with_http_info(deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deployment_get_with_http_info(deployment_id, **kwargs)  # noqa: E501
            return data

    def deployment_get_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Get a deployment details by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployment_get_with_http_info(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: Id of the deployment group (required)
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `deployment_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployments(self, **kwargs):  # noqa: E501
        """Get a list of deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployments(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[DeploymentResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deployments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.deployments_with_http_info(**kwargs)  # noqa: E501
            return data

    def deployments_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deployments_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[DeploymentResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployments" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeploymentResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detectobjects(self, id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Detect the objects, given a (input) prediction request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.detectobjects(id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: the GUID for mapping the results in the detections (required)
        :param bool needs_preprocessing: (true) if the image needs preprocessing (required)
        :param float threshold: A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. (required)
        :param file file: the image file to detect objects from (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: DetectionResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.detectobjects_with_http_info(id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.detectobjects_with_http_info(id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def detectobjects_with_http_info(self, id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Detect the objects, given a (input) prediction request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.detectobjects_with_http_info(id, needs_preprocessing, threshold, file, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: the GUID for mapping the results in the detections (required)
        :param bool needs_preprocessing: (true) if the image needs preprocessing (required)
        :param float threshold: A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. (required)
        :param file file: the image file to detect objects from (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: DetectionResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'needs_preprocessing', 'threshold', 'file', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detectobjects" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'needs_preprocessing' is set
        if ('needs_preprocessing' not in params or
                params['needs_preprocessing'] is None):
            raise ValueError("Missing the required parameter `needs_preprocessing` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'threshold' is set
        if ('threshold' not in params or
                params['threshold'] is None):
            raise ValueError("Missing the required parameter `threshold` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `detectobjects`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'needs_preprocessing' in params:
            form_params.append(('needsPreprocessing', params['needs_preprocessing']))  # noqa: E501
        if 'threshold' in params:
            form_params.append(('threshold', params['threshold']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetectionResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_job_output_file(self, job_id, download_output_file_request, **kwargs):  # noqa: E501
        """Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.download_job_output_file(job_id, download_output_file_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :param DownloadOutputFileRequest download_output_file_request: Download output file request object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.download_job_output_file_with_http_info(job_id, download_output_file_request, **kwargs)  # noqa: E501
        else:
            (data) = self.download_job_output_file_with_http_info(job_id, download_output_file_request, **kwargs)  # noqa: E501
            return data

    def download_job_output_file_with_http_info(self, job_id, download_output_file_request, **kwargs):  # noqa: E501
        """Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.download_job_output_file_with_http_info(job_id, download_output_file_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :param DownloadOutputFileRequest download_output_file_request: Download output file request object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id', 'download_output_file_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_job_output_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `download_job_output_file`")  # noqa: E501
        # verify the required parameter 'download_output_file_request' is set
        if ('download_output_file_request' not in params or
                params['download_output_file_request'] is None):
            raise ValueError("Missing the required parameter `download_output_file_request` when calling `download_job_output_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'download_output_file_request' in params:
            body_params = params['download_output_file_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/outputfile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_auth_token(self, token_generate_request, **kwargs):  # noqa: E501
        """Generate new auth token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_auth_token(token_generate_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param TokenGenerateRequest token_generate_request: Auth token details. (required)
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.generate_auth_token_with_http_info(token_generate_request, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_auth_token_with_http_info(token_generate_request, **kwargs)  # noqa: E501
            return data

    def generate_auth_token_with_http_info(self, token_generate_request, **kwargs):  # noqa: E501
        """Generate new auth token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_auth_token_with_http_info(token_generate_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param TokenGenerateRequest token_generate_request: Auth token details. (required)
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token_generate_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_auth_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token_generate_request' is set
        if ('token_generate_request' not in params or
                params['token_generate_request'] is None):
            raise ValueError("Missing the required parameter `token_generate_request` when calling `generate_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'token_generate_request' in params:
            body_params = params['token_generate_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Token',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_jobs(self, **kwargs):  # noqa: E501
        """Get a list of all available jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_jobs(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[JobEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_all_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all available jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_jobs_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[JobEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[JobEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array(self, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array based on the array type.  # noqa: E501

        The array is specified through a file path, in the configuration object, during model server deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array(accept, array_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str accept: (required)
        :param str array_type: The format in which the memory mapped array is returned. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_array_with_http_info(accept, array_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_array_with_http_info(accept, array_type, **kwargs)  # noqa: E501
            return data

    def get_array_with_http_info(self, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array based on the array type.  # noqa: E501

        The array is specified through a file path, in the configuration object, during model server deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array_with_http_info(accept, array_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str accept: (required)
        :param str array_type: The format in which the memory mapped array is returned. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['accept', 'array_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'accept' is set
        if ('accept' not in params or
                params['accept'] is None):
            raise ValueError("Missing the required parameter `accept` when calling `get_array`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in params or
                params['array_type'] is None):
            raise ValueError("Missing the required parameter `array_type` when calling `get_array`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in params:
            path_params['arrayType'] = params['array_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept' in params:
            header_params['accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array_indices(self, content_type, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array indices based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array_indices(content_type, accept, array_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param str input: Input indices array
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_array_indices_with_http_info(content_type, accept, array_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_array_indices_with_http_info(content_type, accept, array_type, **kwargs)  # noqa: E501
            return data

    def get_array_indices_with_http_info(self, content_type, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array indices based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array_indices_with_http_info(content_type, accept, array_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param str input: Input indices array
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'accept', 'array_type', 'input']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array_indices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `get_array_indices`")  # noqa: E501
        # verify the required parameter 'accept' is set
        if ('accept' not in params or
                params['accept'] is None):
            raise ValueError("Missing the required parameter `accept` when calling `get_array_indices`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in params or
                params['array_type'] is None):
            raise ValueError("Missing the required parameter `array_type` when calling `get_array_indices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in params:
            path_params['arrayType'] = params['array_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501
        if 'accept' in params:
            header_params['accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input' in params:
            body_params = params['input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/indices/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array_range(self, accept, array_type, _from, to, **kwargs):  # noqa: E501
        """Get the memory mapped array within a range based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array_range(accept, array_type, _from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param int _from: (required)
        :param int to: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_array_range_with_http_info(accept, array_type, _from, to, **kwargs)  # noqa: E501
        else:
            (data) = self.get_array_range_with_http_info(accept, array_type, _from, to, **kwargs)  # noqa: E501
            return data

    def get_array_range_with_http_info(self, accept, array_type, _from, to, **kwargs):  # noqa: E501
        """Get the memory mapped array within a range based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_array_range_with_http_info(accept, array_type, _from, to, async=True)
        >>> result = thread.get()

        :param async bool
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param int _from: (required)
        :param int to: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['accept', 'array_type', '_from', 'to']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'accept' is set
        if ('accept' not in params or
                params['accept'] is None):
            raise ValueError("Missing the required parameter `accept` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in params or
                params['array_type'] is None):
            raise ValueError("Missing the required parameter `array_type` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter '_from' is set
        if ('_from' not in params or
                params['_from'] is None):
            raise ValueError("Missing the required parameter `_from` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in params or
                params['to'] is None):
            raise ValueError("Missing the required parameter `to` when calling `get_array_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in params:
            path_params['arrayType'] = params['array_type']  # noqa: E501
        if '_from' in params:
            path_params['from'] = params['_from']  # noqa: E501
        if 'to' in params:
            path_params['to'] = params['to']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept' in params:
            header_params['accept'] = params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/range/{from}/{to}/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_auth_policy(self, **kwargs):  # noqa: E501
        """Get auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_auth_policy(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_auth_policy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_auth_policy_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_auth_policy_with_http_info(self, **kwargs):  # noqa: E501
        """Get auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_auth_policy_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_auth_policy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_best_model_among_model_ids(self, model_history_server_id, best_model, **kwargs):  # noqa: E501
        """Gets the best model among the given model instance IDs, based on the evaluation type and column metric  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_best_model_among_model_ids(model_history_server_id, best_model, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param BestModel best_model: Object encapsulating the model ids, eval type and column metric name (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_best_model_among_model_ids_with_http_info(model_history_server_id, best_model, **kwargs)  # noqa: E501
        else:
            (data) = self.get_best_model_among_model_ids_with_http_info(model_history_server_id, best_model, **kwargs)  # noqa: E501
            return data

    def get_best_model_among_model_ids_with_http_info(self, model_history_server_id, best_model, **kwargs):  # noqa: E501
        """Gets the best model among the given model instance IDs, based on the evaluation type and column metric  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_best_model_among_model_ids_with_http_info(model_history_server_id, best_model, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param BestModel best_model: Object encapsulating the model ids, eval type and column metric name (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'best_model']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_best_model_among_model_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_best_model_among_model_ids`")  # noqa: E501
        # verify the required parameter 'best_model' is set
        if ('best_model' not in params or
                params['best_model'] is None):
            raise ValueError("Missing the required parameter `best_model` when calling `get_best_model_among_model_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'best_model' in params:
            body_params = params['best_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/best', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credentials_by_id(self, credential_id, **kwargs):  # noqa: E501
        """Get credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_credentials_by_id(credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int credential_id: Credentials ID (required)
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501
            return data

    def get_credentials_by_id_with_http_info(self, credential_id, **kwargs):  # noqa: E501
        """Get credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_credentials_by_id_with_http_info(credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int credential_id: Credentials ID (required)
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['credential_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credentials_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in params or
                params['credential_id'] is None):
            raise ValueError("Missing the required parameter `credential_id` when calling `get_credentials_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credential_id' in params:
            path_params['credentialId'] = params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials/{credentialId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceCredentials',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_model(self, **kwargs):  # noqa: E501
        """Returns the current model being used for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_model(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_current_model_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_current_model_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_current_model_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the current model being used for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_model_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_model" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/model', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluation_for_model_id(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets the list of evaluation results entity, given a model instance ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_evaluation_for_model_id(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get evaluation results for. (required)
        :return: list[EvaluationResultsEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_evaluation_for_model_id_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_evaluation_for_model_id_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
            return data

    def get_evaluation_for_model_id_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets the list of evaluation results entity, given a model instance ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_evaluation_for_model_id_with_http_info(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get evaluation results for. (required)
        :return: list[EvaluationResultsEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluation_for_model_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_evaluation_for_model_id`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in params or
                params['model_instance_id'] is None):
            raise ValueError("Missing the required parameter `model_instance_id` when calling `get_evaluation_for_model_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in params:
            path_params['modelInstanceID'] = params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EvaluationResultsEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_examples_for_minibatch(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets all the examples for a minibatch ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_examples_for_minibatch(model_history_server_id, minibatch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :return: list[ExampleEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_examples_for_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_examples_for_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501
            return data

    def get_examples_for_minibatch_with_http_info(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets all the examples for a minibatch ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_examples_for_minibatch_with_http_info(model_history_server_id, minibatch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :return: list[ExampleEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'minibatch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_examples_for_minibatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_examples_for_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_id' is set
        if ('minibatch_id' not in params or
                params['minibatch_id'] is None):
            raise ValueError("Missing the required parameter `minibatch_id` when calling `get_examples_for_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'minibatch_id' in params:
            path_params['minibatchId'] = params['minibatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/example/{minibatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExampleEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain an experiment&#39;s details, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_experiment(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to obtain (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
            return data

    def get_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain an experiment&#39;s details, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_experiment_with_http_info(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to obtain (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in params:
            path_params['experimentID'] = params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_experiments_for_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Obtain all experiments for a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_experiments_for_model_history(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace (required)
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_experiments_for_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_experiments_for_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
            return data

    def get_experiments_for_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Obtain all experiments for a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_experiments_for_model_history_with_http_info(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace (required)
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiments_for_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_experiments_for_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in params or
                params['model_history_id'] is None):
            raise ValueError("Missing the required parameter `model_history_id` when calling `get_experiments_for_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in params:
            path_params['modelHistoryID'] = params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExperimentEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_by_id(self, job_id_or_type, **kwargs):  # noqa: E501
        """Get a job by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_job_by_id(job_id_or_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id_or_type: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501
            return data

    def get_job_by_id_with_http_info(self, job_id_or_type, **kwargs):  # noqa: E501
        """Get a job by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_job_by_id_with_http_info(job_id_or_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id_or_type: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id_or_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in params or
                params['job_id_or_type'] is None):
            raise ValueError("Missing the required parameter `job_id_or_type` when calling `get_job_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in params:
            path_params['jobIdOrType'] = params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_last_evaluation(self, **kwargs):  # noqa: E501
        """Get the last evaluation specifications from the current model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_evaluation(async=True)
        >>> result = thread.get()

        :param async bool
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_last_evaluation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_last_evaluation_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_last_evaluation_with_http_info(self, **kwargs):  # noqa: E501
        """Get the last evaluation specifications from the current model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_last_evaluation_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_last_evaluation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lastevaluation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_minibatch(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets a minibatch for the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_minibatch(model_history_server_id, minibatch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501
            return data

    def get_minibatch_with_http_info(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets a minibatch for the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_minibatch_with_http_info(model_history_server_id, minibatch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'minibatch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_minibatch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_id' is set
        if ('minibatch_id' not in params or
                params['minibatch_id'] is None):
            raise ValueError("Missing the required parameter `minibatch_id` when calling `get_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'minibatch_id' in params:
            path_params['minibatchId'] = params['minibatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibatchEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_details(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Get model details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_details(deployment_id, model_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_model_details_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_details_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501
            return data

    def get_model_details_with_http_info(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Get model details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_details_with_http_info(deployment_id, model_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id', 'model_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `get_model_details`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Gets a model history, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_history(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: GUID of the model history to get information of. (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501
            return data

    def get_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Gets a model history, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_history_with_http_info(model_history_server_id, model_history_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: GUID of the model history to get information of. (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in params or
                params['model_history_id'] is None):
            raise ValueError("Missing the required parameter `model_history_id` when calling `get_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in params:
            path_params['modelHistoryID'] = params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_instance(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_instance(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get information of. (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501
            return data

    def get_model_instance_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_model_instance_with_http_info(model_history_server_id, model_instance_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get information of. (required)
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in params or
                params['model_instance_id'] is None):
            raise ValueError("Missing the required parameter `model_instance_id` when calling `get_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in params:
            path_params['modelInstanceID'] = params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/{modelInstanceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models_for_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain a list of all the models for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_models_for_experiment(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment (required)
        :return: list[ModelInstanceEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_models_for_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_models_for_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501
            return data

    def get_models_for_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain a list of all the models for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_models_for_experiment_with_http_info(model_history_server_id, experiment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment (required)
        :return: list[ModelInstanceEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models_for_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `get_models_for_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_models_for_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in params:
            path_params['experimentID'] = params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModelInstanceEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_id(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def get_resource_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_id_with_http_info(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `get_resource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resource/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_sub_type(self, resource_sub_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource subtype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_sub_type(resource_sub_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str resource_sub_type: Subtype of the resource (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_by_sub_type_with_http_info(resource_sub_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_by_sub_type_with_http_info(resource_sub_type, **kwargs)  # noqa: E501
            return data

    def get_resource_by_sub_type_with_http_info(self, resource_sub_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource subtype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_sub_type_with_http_info(resource_sub_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str resource_sub_type: Subtype of the resource (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_sub_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_sub_type' is set
        if ('resource_sub_type' not in params or
                params['resource_sub_type'] is None):
            raise ValueError("Missing the required parameter `resource_sub_type` when calling `get_resource_by_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_sub_type' in params:
            path_params['resourceSubType'] = params['resource_sub_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources/subtype/{resourceSubType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_type(self, resource_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_type(resource_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str resource_type: Type of the resource (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_by_type_with_http_info(resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_by_type_with_http_info(resource_type, **kwargs)  # noqa: E501
            return data

    def get_resource_by_type_with_http_info(self, resource_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_by_type_with_http_info(resource_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str resource_type: Type of the resource (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `get_resource_by_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources/type/{resourceType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_details_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource details with the specified resource ID  # noqa: E501

        Get the details for the resource, for the given ID. Note that a 'ResourceDetails' object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the 'Resource' object contains only general information (name, id, type, subtype).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_details_by_id(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_details_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_details_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501
            return data

    def get_resource_details_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource details with the specified resource ID  # noqa: E501

        Get the details for the resource, for the given ID. Note that a 'ResourceDetails' object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the 'Resource' object contains only general information (name, id, type, subtype).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_details_by_id_with_http_info(resource_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the resource (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_details_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `get_resource_details_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['resourceId'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/details/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_group_by_id(self, resource_group_id, **kwargs):  # noqa: E501
        """Get the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_group_by_id(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501
            return data

    def get_resource_group_by_id_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Get the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_group_by_id_with_http_info(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in params or
                params['resource_group_id'] is None):
            raise ValueError("Missing the required parameter `resource_group_id` when calling `get_resource_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in params:
            path_params['resourceGroupId'] = params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/group/{resourceGroupId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_groups(self, **kwargs):  # noqa: E501
        """Get a list of all the resource groups  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_groups(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[ResourceGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resource_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_resource_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all the resource groups  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resource_groups_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[ResourceGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resources(self, **kwargs):  # noqa: E501
        """A list of all known/registered resources, of all types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resources(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resources_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_resources_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_resources_with_http_info(self, **kwargs):  # noqa: E501
        """A list of all known/registered resources, of all types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resources_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resources" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resources_from_group(self, resource_group_id, **kwargs):  # noqa: E501
        """Get all resources from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resources_from_group(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_resources_from_group_with_http_info(resource_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resources_from_group_with_http_info(resource_group_id, **kwargs)  # noqa: E501
            return data

    def get_resources_from_group_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Get all resources from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_resources_from_group_with_http_info(resource_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_group_id: ID of the resource group (required)
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resources_from_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in params or
                params['resource_group_id'] is None):
            raise ValueError("Missing the required parameter `resource_group_id` when calling `get_resources_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in params:
            path_params['resourceGroupId'] = params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/group/{resourceGroupId}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_roles(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_roles(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_roles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_roles_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_roles_with_http_info(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_roles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_roles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/security/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Role]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Get a user by user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a user by user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_auth_tokens(self, user_id, **kwargs):  # noqa: E501
        """Get auth tokens for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_auth_tokens(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :param bool only_valid: True if you only want the valid tokens.
        :return: list[Token]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_user_auth_tokens_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_auth_tokens_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_auth_tokens_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get auth tokens for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_user_auth_tokens_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str user_id: User's ID (required)
        :param bool only_valid: True if you only want the valid tokens.
        :return: list[Token]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'only_valid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_auth_tokens" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_auth_tokens`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'only_valid' in params:
            query_params.append(('onlyValid', params['only_valid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/{userId}/tokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Token]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """Get all users.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get all users.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_users_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/security/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_training(self, **kwargs):  # noqa: E501
        """Get the retraining status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.is_training(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RetrainingStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.is_training_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.is_training_with_http_info(**kwargs)  # noqa: E501
            return data

    def is_training_with_http_info(self, **kwargs):  # noqa: E501
        """Get the retraining status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.is_training_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RetrainingStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_training" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/istraining', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RetrainingStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jsonarray(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jsonarray(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.jsonarray_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.jsonarray_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def jsonarray_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.jsonarray_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jsonarray" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `jsonarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def knn(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Runs knn on the given index with the given k  # noqa: E501

        Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.knn(deployment_name, version_name, knn_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param NearestNeighborRequest body: (required)
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.knn_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.knn_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501
            return data

    def knn_with_http_info(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Runs knn on the given index with the given k  # noqa: E501

        Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.knn_with_http_info(deployment_name, version_name, knn_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param NearestNeighborRequest body: (required)
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'knn_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method knn" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'knn_name' is set
        if ('knn_name' not in params or
                params['knn_name'] is None):
            raise ValueError("Missing the required parameter `knn_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `knn`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'knn_name' in params:
            path_params['knnName'] = params['knn_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NearestNeighborsResults',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def knnnew(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Run a k nearest neighbors search on a NEW data point  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.knnnew(deployment_name, version_name, knn_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param Base64NDArrayBodyKNN body: The input NDArray (required)
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.knnnew_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.knnnew_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501
            return data

    def knnnew_with_http_info(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Run a k nearest neighbors search on a NEW data point  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.knnnew_with_http_info(deployment_name, version_name, knn_name, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param Base64NDArrayBodyKNN body: The input NDArray (required)
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'knn_name', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method knnnew" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'knn_name' is set
        if ('knn_name' not in params or
                params['knn_name'] is None):
            raise ValueError("Missing the required parameter `knn_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `knnnew`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'knn_name' in params:
            path_params['knnName'] = params['knn_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NearestNeighborsResults',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_experiments(self, model_history_server_id, **kwargs):  # noqa: E501
        """List all of the experiments in every model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_all_experiments(model_history_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_all_experiments_with_http_info(model_history_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_all_experiments_with_http_info(model_history_server_id, **kwargs)  # noqa: E501
            return data

    def list_all_experiments_with_http_info(self, model_history_server_id, **kwargs):  # noqa: E501
        """List all of the experiments in every model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_all_experiments_with_http_info(model_history_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_experiments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `list_all_experiments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExperimentEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logfilepath(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get logs file path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logfilepath(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.logfilepath_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.logfilepath_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def logfilepath_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get logs file path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logfilepath_with_http_info(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logfilepath" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `logfilepath`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `logfilepath`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `logfilepath`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login(self, login_request, **kwargs):  # noqa: E501
        """Post JSON credentials and obtain a JWT authorization token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.login(login_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param LoginRequest login_request: Login credentials. (required)
        :return: LoginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.login_with_http_info(login_request, **kwargs)  # noqa: E501
        else:
            (data) = self.login_with_http_info(login_request, **kwargs)  # noqa: E501
            return data

    def login_with_http_info(self, login_request, **kwargs):  # noqa: E501
        """Post JSON credentials and obtain a JWT authorization token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.login_with_http_info(login_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param LoginRequest login_request: Login credentials. (required)
        :return: LoginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['login_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'login_request' is set
        if ('login_request' not in params or
                params['login_request'] is None):
            raise ValueError("Missing the required parameter `login_request` when calling `login`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'login_request' in params:
            body_params = params['login_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logs(self, deployment_name, version_name, model_name, log_request, **kwargs):  # noqa: E501
        """Get logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logs(deployment_name, version_name, model_name, log_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param LogRequest log_request: The log object (required)
        :return: LogBatch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.logs_with_http_info(deployment_name, version_name, model_name, log_request, **kwargs)  # noqa: E501
        else:
            (data) = self.logs_with_http_info(deployment_name, version_name, model_name, log_request, **kwargs)  # noqa: E501
            return data

    def logs_with_http_info(self, deployment_name, version_name, model_name, log_request, **kwargs):  # noqa: E501
        """Get logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.logs_with_http_info(deployment_name, version_name, model_name, log_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param LogRequest log_request: The log object (required)
        :return: LogBatch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name', 'log_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'log_request' is set
        if ('log_request' not in params or
                params['log_request'] is None):
            raise ValueError("Missing the required parameter `log_request` when calling `logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_request' in params:
            body_params = params['log_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogBatch',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meta_get(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """this method can be used to get the meta data for the current model which set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.meta_get(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.meta_get_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.meta_get_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def meta_get_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """this method can be used to get the meta data for the current model which set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.meta_get_with_http_info(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meta_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `meta_get`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `meta_get`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `meta_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetaData',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meta_post(self, content_type, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """This method can be used to set meta data for the current model which is set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.meta_post(content_type, body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json` (required)
        :param str body: the meta data object (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.meta_post_with_http_info(content_type, body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.meta_post_with_http_info(content_type, body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def meta_post_with_http_info(self, content_type, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """This method can be used to set meta data for the current model which is set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.meta_post_with_http_info(content_type, body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json` (required)
        :param str body: the meta data object (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meta_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `meta_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetaData',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def model_state_change(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Modify the state (start/stop) of a deployed model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.model_state_change(deployment_id, model_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param SetState body: the model state object (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.model_state_change_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.model_state_change_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501
            return data

    def model_state_change_with_http_info(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Modify the state (start/stop) of a deployed model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.model_state_change_with_http_info(deployment_id, model_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param SetState body: the model state object (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id', 'model_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_state_change" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `model_state_change`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `model_state_change`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `model_state_change`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}/state', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def models(self, deployment_id, **kwargs):  # noqa: E501
        """Retrieve a list of all the deployed models given a deployment id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.models(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :return: list[ModelEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.models_with_http_info(deployment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_with_http_info(deployment_id, **kwargs)  # noqa: E501
            return data

    def models_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Retrieve a list of all the deployed models given a deployment id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.models_with_http_info(deployment_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :return: list[ModelEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `models`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModelEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modelset(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Set the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modelset(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to upload (.pb file)
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.modelset_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.modelset_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def modelset_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Set the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modelset_with_http_info(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to upload (.pb file)
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name', 'file']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modelset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `modelset`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `modelset`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `modelset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modelupdate(self, file, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Update the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modelupdate(file, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The model file to update with (.pb file) (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.modelupdate_with_http_info(file, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.modelupdate_with_http_info(file, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def modelupdate_with_http_info(self, file, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Update the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modelupdate_with_http_info(file, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The model file to update with (.pb file) (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modelupdate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `modelupdate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multiclassify(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Represents all of the labels for a given classification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multiclassify(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiClassClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.multiclassify_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.multiclassify_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def multiclassify_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Represents all of the labels for a given classification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multiclassify_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiClassClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multiclassify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `multiclassify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiClassClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multipredict(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get the output from the network, based on the given INDArray[] input  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multipredict(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param MultiPredictRequest body: The multiple input arrays with mask inputs to run inferences on (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.multipredict_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.multipredict_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def multipredict_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get the output from the network, based on the given INDArray[] input  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multipredict_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param MultiPredictRequest body: The multiple input arrays with mask inputs to run inferences on (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multipredict" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `multipredict`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiPredictResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multipredictimage(self, file, id, needs_preprocessing, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get the output from the network using the given image file using the /multipredict endpoint&#39;s method  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multipredictimage(file, id, needs_preprocessing, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The image file to run the prediction on (required)
        :param str id: The id of the request (could be self generated) (required)
        :param bool needs_preprocessing: Whether or not the preprocessing is required (either 'true' or 'false') (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.multipredictimage_with_http_info(file, id, needs_preprocessing, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.multipredictimage_with_http_info(file, id, needs_preprocessing, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def multipredictimage_with_http_info(self, file, id, needs_preprocessing, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get the output from the network using the given image file using the /multipredict endpoint&#39;s method  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.multipredictimage_with_http_info(file, id, needs_preprocessing, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The image file to run the prediction on (required)
        :param str id: The id of the request (could be self generated) (required)
        :param bool needs_preprocessing: Whether or not the preprocessing is required (either 'true' or 'false') (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'id', 'needs_preprocessing', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multipredictimage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'needs_preprocessing' is set
        if ('needs_preprocessing' not in params or
                params['needs_preprocessing'] is None):
            raise ValueError("Missing the required parameter `needs_preprocessing` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `multipredictimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'id' in params:
            form_params.append(('id', params['id']))  # noqa: E501
        if 'needs_preprocessing' in params:
            form_params.append(('needs_preprocessing', params['needs_preprocessing']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiPredictResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def num_revisions(self, **kwargs):  # noqa: E501
        """Gets the number of retrained models written with retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.num_revisions(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RevisionsWritten
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.num_revisions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.num_revisions_with_http_info(**kwargs)  # noqa: E501
            return data

    def num_revisions_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the number of retrained models written with retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.num_revisions_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RevisionsWritten
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method num_revisions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/numrevisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionsWritten',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predict_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.predict_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def predict_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param Prediction body: The input NDArray (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `predict`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `predict`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `predict`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `predict`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_error(self, content_type, operation, input_type, **kwargs):  # noqa: E501
        """Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        These \"error\" endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_error(content_type, operation, input_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: Operation to perform on the input data. (required)
        :param str input_type: Type of the input data. (required)
        :param str input_data:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predict_error_with_http_info(content_type, operation, input_type, **kwargs)  # noqa: E501
        else:
            (data) = self.predict_error_with_http_info(content_type, operation, input_type, **kwargs)  # noqa: E501
            return data

    def predict_error_with_http_info(self, content_type, operation, input_type, **kwargs):  # noqa: E501
        """Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        These \"error\" endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_error_with_http_info(content_type, operation, input_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: Operation to perform on the input data. (required)
        :param str input_type: Type of the input data. (required)
        :param str input_data:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'operation', 'input_type', 'input_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_error" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `predict_error`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `predict_error`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `predict_error`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in params:
            path_params['operation'] = params['operation']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input_data' in params:
            body_params = params['input_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputType}/error', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_v2_file(self, operation, input_type_file, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_v2_file(operation, input_type_file, input_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_file: Type of the input data.  (required)
        :param file input_data: The input data to run inference on. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predict_v2_file_with_http_info(operation, input_type_file, input_data, **kwargs)  # noqa: E501
        else:
            (data) = self.predict_v2_file_with_http_info(operation, input_type_file, input_data, **kwargs)  # noqa: E501
            return data

    def predict_v2_file_with_http_info(self, operation, input_type_file, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_v2_file_with_http_info(operation, input_type_file, input_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_file: Type of the input data.  (required)
        :param file input_data: The input data to run inference on. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operation', 'input_type_file', 'input_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_v2_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `predict_v2_file`")  # noqa: E501
        # verify the required parameter 'input_type_file' is set
        if ('input_type_file' not in params or
                params['input_type_file'] is None):
            raise ValueError("Missing the required parameter `input_type_file` when calling `predict_v2_file`")  # noqa: E501
        # verify the required parameter 'input_data' is set
        if ('input_data' not in params or
                params['input_data'] is None):
            raise ValueError("Missing the required parameter `input_data` when calling `predict_v2_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in params:
            path_params['operation'] = params['operation']  # noqa: E501
        if 'input_type_file' in params:
            path_params['inputTypeFile'] = params['input_type_file']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'input_data' in params:
            local_var_files['inputData'] = params['input_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputTypeFile}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_v2_json(self, content_type, operation, input_type_json, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_v2_json(content_type, operation, input_type_json, input_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_json: Type of the input data.  (required)
        :param str input_data: The input data to run inference on. (Specify a JSON string here) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predict_v2_json_with_http_info(content_type, operation, input_type_json, input_data, **kwargs)  # noqa: E501
        else:
            (data) = self.predict_v2_json_with_http_info(content_type, operation, input_type_json, input_data, **kwargs)  # noqa: E501
            return data

    def predict_v2_json_with_http_info(self, content_type, operation, input_type_json, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predict_v2_json_with_http_info(content_type, operation, input_type_json, input_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_json: Type of the input data.  (required)
        :param str input_data: The input data to run inference on. (Specify a JSON string here) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'operation', 'input_type_json', 'input_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_v2_json" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'input_type_json' is set
        if ('input_type_json' not in params or
                params['input_type_json'] is None):
            raise ValueError("Missing the required parameter `input_type_json` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'input_data' is set
        if ('input_data' not in params or
                params['input_data'] is None):
            raise ValueError("Missing the required parameter `input_data` when calling `predict_v2_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in params:
            path_params['operation'] = params['operation']  # noqa: E501
        if 'input_type_json' in params:
            path_params['inputTypeJson'] = params['input_type_json']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input_data' in params:
            body_params = params['input_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputTypeJson}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictimage(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictimage(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predictimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.predictimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def predictimage_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictimage_with_http_info(deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'model_name', 'image']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictimage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `predictimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `predictimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `predictimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictwithpreprocess(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictwithpreprocess(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] body: The input array (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predictwithpreprocess_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.predictwithpreprocess_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def predictwithpreprocess_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictwithpreprocess_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] body: The input array (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictwithpreprocess" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `predictwithpreprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictwithpreprocessjson(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictwithpreprocessjson(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] body: The input array (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.predictwithpreprocessjson_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
        else:
            (data) = self.predictwithpreprocessjson_with_http_info(body, deployment_name, version_name, model_name, **kwargs)  # noqa: E501
            return data

    def predictwithpreprocessjson_with_http_info(self, body, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.predictwithpreprocessjson_with_http_info(body, deployment_name, version_name, model_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] body: The input array (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictwithpreprocessjson" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `predictwithpreprocessjson`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def raw_predict_binary(self, input_type, output_type, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.raw_predict_binary(input_type, output_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str input_type: Input data type. (required)
        :param str output_type: Binary output data type. (required)
        :param file input_data: The input file to upload.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.raw_predict_binary_with_http_info(input_type, output_type, **kwargs)  # noqa: E501
        else:
            (data) = self.raw_predict_binary_with_http_info(input_type, output_type, **kwargs)  # noqa: E501
            return data

    def raw_predict_binary_with_http_info(self, input_type, output_type, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.raw_predict_binary_with_http_info(input_type, output_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str input_type: Input data type. (required)
        :param str output_type: Binary output data type. (required)
        :param file input_data: The input file to upload.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['input_type', 'output_type', 'input_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method raw_predict_binary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `raw_predict_binary`")  # noqa: E501
        # verify the required parameter 'output_type' is set
        if ('output_type' not in params or
                params['output_type'] is None):
            raise ValueError("Missing the required parameter `output_type` when calling `raw_predict_binary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501
        if 'output_type' in params:
            path_params['outputType'] = params['output_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'input_data' in params:
            local_var_files['inputData'] = params['input_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/raw/{inputType}/{outputType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_job_status(self, job_id, **kwargs):  # noqa: E501
        """Refresh the remote job status. Can be used for monitoring.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.refresh_job_status(job_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.refresh_job_status_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.refresh_job_status_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def refresh_job_status_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Refresh the remote job status. Can be used for monitoring.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.refresh_job_status_with_http_info(job_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_job_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `refresh_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/refresh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_user(self, user, **kwargs):  # noqa: E501
        """Register a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.register_user(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: User details (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.register_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.register_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def register_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Register a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.register_user_with_http_info(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: User details (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `register_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reimport_model(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Reimport a model to a previous deployed model in a deployment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reimport_model(deployment_id, model_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param ImportModelRequest body: the deployment request (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.reimport_model_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.reimport_model_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501
            return data

    def reimport_model_with_http_info(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Reimport a model to a previous deployed model in a deployment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reimport_model_with_http_info(deployment_id, model_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param ImportModelRequest body: the deployment request (required)
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_id', 'model_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reimport_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in params or
                params['deployment_id'] is None):
            raise ValueError("Missing the required parameter `deployment_id` when calling `reimport_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `reimport_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `reimport_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in params:
            path_params['deploymentId'] = params['deployment_id']  # noqa: E501
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_user_token(self, token_id, **kwargs):  # noqa: E501
        """Revoke a user token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_user_token(token_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int token_id: Token ID (required)
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revoke_user_token_with_http_info(token_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_user_token_with_http_info(token_id, **kwargs)  # noqa: E501
            return data

    def revoke_user_token_with_http_info(self, token_id, **kwargs):  # noqa: E501
        """Revoke a user token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_user_token_with_http_info(token_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int token_id: Token ID (required)
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_user_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token_id' is set
        if ('token_id' not in params or
                params['token_id'] is None):
            raise ValueError("Missing the required parameter `token_id` when calling `revoke_user_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token_id' in params:
            path_params['tokenId'] = params['token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/token/{tokenId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Token',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rollback(self, index, **kwargs):  # noqa: E501
        """Rollback to a previous revision of the model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.rollback(index, async=True)
        >>> result = thread.get()

        :param async bool
        :param int index: Model revision index. (required)
        :return: RollbackStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.rollback_with_http_info(index, **kwargs)  # noqa: E501
        else:
            (data) = self.rollback_with_http_info(index, **kwargs)  # noqa: E501
            return data

    def rollback_with_http_info(self, index, **kwargs):  # noqa: E501
        """Rollback to a previous revision of the model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.rollback_with_http_info(index, async=True)
        >>> result = thread.get()

        :param async bool
        :param int index: Model revision index. (required)
        :return: RollbackStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['index']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rollback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'index' is set
        if ('index' not in params or
                params['index'] is None):
            raise ValueError("Missing the required parameter `index` when calling `rollback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'index' in params:
            path_params['index'] = params['index']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rollback/{index}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RollbackStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_a_job(self, job_id, **kwargs):  # noqa: E501
        """Start running an (already created) job on the remote resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.run_a_job(job_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.run_a_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.run_a_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def run_a_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Start running an (already created) job on the remote resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.run_a_job_with_http_info(job_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int job_id: Job ID (required)
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_a_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `run_a_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/run', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transform_csv(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord  # noqa: E501

        Takes a batch of SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transform_csv(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchCSVRecord batch_csv_record: The input batch of record arrays
        :return: BatchCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transform_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transform_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transform_csv_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord  # noqa: E501

        Takes a batch of SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transform_csv_with_http_info(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchCSVRecord batch_csv_record: The input batch of record arrays
        :return: BatchCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'transform_name', 'batch_csv_record']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transform_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transform_csv`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transform_csv`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transform_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_csv_record' in params:
            body_params = params['batch_csv_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchCSVRecord',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformarray(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a batch input arrays and transforms it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformarray(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchRecord batch_record: The input batch of record arrays
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transformarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transformarray_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a batch input arrays and transforms it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformarray_with_http_info(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchRecord batch_record: The input batch of record arrays
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'transform_name', 'batch_record']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformarray" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformarray`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transformarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_record' in params:
            body_params = params['batch_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformimage(self, deployment_name, version_name, image_transform_name, files, **kwargs):  # noqa: E501
        """Takes multiple multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformimage(deployment_name, version_name, image_transform_name, files, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param list[str] files: The image files to upload (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformimage_with_http_info(deployment_name, version_name, image_transform_name, files, **kwargs)  # noqa: E501
        else:
            (data) = self.transformimage_with_http_info(deployment_name, version_name, image_transform_name, files, **kwargs)  # noqa: E501
            return data

    def transformimage_with_http_info(self, deployment_name, version_name, image_transform_name, files, **kwargs):  # noqa: E501
        """Takes multiple multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformimage_with_http_info(deployment_name, version_name, image_transform_name, files, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param list[str] files: The image files to upload (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'image_transform_name', 'files']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformimage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'image_transform_name' is set
        if ('image_transform_name' not in params or
                params['image_transform_name'] is None):
            raise ValueError("Missing the required parameter `image_transform_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'files' is set
        if ('files' not in params or
                params['files'] is None):
            raise ValueError("Missing the required parameter `files` when calling `transformimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'image_transform_name' in params:
            path_params['imageTransformName'] = params['image_transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in params:
            form_params.append(('files', params['files']))  # noqa: E501
            collection_formats['files'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincremental_csv(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord  # noqa: E501

        Takes a SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincremental_csv(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleCSVRecord single_csv_record: The input record array
        :return: SingleCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformincremental_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transformincremental_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transformincremental_csv_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord  # noqa: E501

        Takes a SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincremental_csv_with_http_info(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleCSVRecord single_csv_record: The input record array
        :return: SingleCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'transform_name', 'single_csv_record']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincremental_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformincremental_csv`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformincremental_csv`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transformincremental_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'single_csv_record' in params:
            body_params = params['single_csv_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SingleCSVRecord',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincrementalarray(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Same as /transformincremental but returns Base64NDArrayBody.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincrementalarray(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleRecord single_record: The input record array
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformincrementalarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transformincrementalarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transformincrementalarray_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Same as /transformincremental but returns Base64NDArrayBody.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincrementalarray_with_http_info(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleRecord single_record: The input record array
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'transform_name', 'single_record']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincrementalarray" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformincrementalarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformincrementalarray`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transformincrementalarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'single_record' in params:
            body_params = params['single_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincrementalimage(self, deployment_name, version_name, image_transform_name, file, **kwargs):  # noqa: E501
        """Takes a single multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincrementalimage(deployment_name, version_name, image_transform_name, file, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param file file: The image file to upload (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformincrementalimage_with_http_info(deployment_name, version_name, image_transform_name, file, **kwargs)  # noqa: E501
        else:
            (data) = self.transformincrementalimage_with_http_info(deployment_name, version_name, image_transform_name, file, **kwargs)  # noqa: E501
            return data

    def transformincrementalimage_with_http_info(self, deployment_name, version_name, image_transform_name, file, **kwargs):  # noqa: E501
        """Takes a single multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformincrementalimage_with_http_info(deployment_name, version_name, image_transform_name, file, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param file file: The image file to upload (required)
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'image_transform_name', 'file']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincrementalimage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'image_transform_name' is set
        if ('image_transform_name' not in params or
                params['image_transform_name'] is None):
            raise ValueError("Missing the required parameter `image_transform_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `transformincrementalimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'image_transform_name' in params:
            path_params['imageTransformName'] = params['image_transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformprocess_get(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Gets the JSON string of the deployed transform process (CSV or Image)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformprocess_get(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformprocess_get_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transformprocess_get_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transformprocess_get_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Gets the JSON string of the deployed transform process (CSV or Image)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformprocess_get_with_http_info(deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_name', 'version_name', 'transform_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformprocess_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformprocess_get`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformprocess_get`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transformprocess_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformprocess_post(self, content_type, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Sets the deployed (CSV or Image) transform process through the provided JSON string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformprocess_post(content_type, deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should be `application/json`. (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param str transform_process: The transform process to set (Specify a JSON string here).
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transformprocess_post_with_http_info(content_type, deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
        else:
            (data) = self.transformprocess_post_with_http_info(content_type, deployment_name, version_name, transform_name, **kwargs)  # noqa: E501
            return data

    def transformprocess_post_with_http_info(self, content_type, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Sets the deployed (CSV or Image) transform process through the provided JSON string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transformprocess_post_with_http_info(content_type, deployment_name, version_name, transform_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str content_type: The `Content-Type` should be `application/json`. (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param str transform_process: The transform process to set (Specify a JSON string here).
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'deployment_name', 'version_name', 'transform_name', 'transform_process']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformprocess_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in params or
                params['deployment_name'] is None):
            raise ValueError("Missing the required parameter `deployment_name` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in params or
                params['version_name'] is None):
            raise ValueError("Missing the required parameter `version_name` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in params or
                params['transform_name'] is None):
            raise ValueError("Missing the required parameter `transform_name` when calling `transformprocess_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in params:
            path_params['deploymentName'] = params['deployment_name']  # noqa: E501
        if 'version_name' in params:
            path_params['versionName'] = params['version_name']  # noqa: E501
        if 'transform_name' in params:
            path_params['transformName'] = params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transform_process' in params:
            body_params = params['transform_process']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auth_policy(self, auth_policy, **kwargs):  # noqa: E501
        """Update auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auth_policy(auth_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param AuthPolicy auth_policy: Auth policy object (required)
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_auth_policy_with_http_info(auth_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.update_auth_policy_with_http_info(auth_policy, **kwargs)  # noqa: E501
            return data

    def update_auth_policy_with_http_info(self, auth_policy, **kwargs):  # noqa: E501
        """Update auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auth_policy_with_http_info(auth_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param AuthPolicy auth_policy: Auth policy object (required)
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['auth_policy']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auth_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'auth_policy' is set
        if ('auth_policy' not in params or
                params['auth_policy'] is None):
            raise ValueError("Missing the required parameter `auth_policy` when calling `update_auth_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auth_policy' in params:
            body_params = params['auth_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/policy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_best_model_for_experiment(self, model_history_server_id, update_best_model, **kwargs):  # noqa: E501
        """Updates the best model for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_best_model_for_experiment(model_history_server_id, update_best_model, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param UpdateBestModel update_best_model: Model encapsulating the experiment id to update and the best model id. (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_best_model_for_experiment_with_http_info(model_history_server_id, update_best_model, **kwargs)  # noqa: E501
        else:
            (data) = self.update_best_model_for_experiment_with_http_info(model_history_server_id, update_best_model, **kwargs)  # noqa: E501
            return data

    def update_best_model_for_experiment_with_http_info(self, model_history_server_id, update_best_model, **kwargs):  # noqa: E501
        """Updates the best model for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_best_model_for_experiment_with_http_info(model_history_server_id, update_best_model, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param UpdateBestModel update_best_model: Model encapsulating the experiment id to update and the best model id. (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'update_best_model']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_best_model_for_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `update_best_model_for_experiment`")  # noqa: E501
        # verify the required parameter 'update_best_model' is set
        if ('update_best_model' not in params or
                params['update_best_model'] is None):
            raise ValueError("Missing the required parameter `update_best_model` when calling `update_best_model_for_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_best_model' in params:
            body_params = params['update_best_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/best', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_experiment(self, model_history_server_id, experiment_id, experiment_entity, **kwargs):  # noqa: E501
        """Updates an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_experiment(model_history_server_id, experiment_id, experiment_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to update (required)
        :param ExperimentEntity experiment_entity: The experiment entity to update with (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_experiment_with_http_info(model_history_server_id, experiment_id, experiment_entity, **kwargs)  # noqa: E501
        else:
            (data) = self.update_experiment_with_http_info(model_history_server_id, experiment_id, experiment_entity, **kwargs)  # noqa: E501
            return data

    def update_experiment_with_http_info(self, model_history_server_id, experiment_id, experiment_entity, **kwargs):  # noqa: E501
        """Updates an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_experiment_with_http_info(model_history_server_id, experiment_id, experiment_entity, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to update (required)
        :param ExperimentEntity experiment_entity: The experiment entity to update with (required)
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'experiment_id', 'experiment_entity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `update_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `update_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_entity' is set
        if ('experiment_entity' not in params or
                params['experiment_entity'] is None):
            raise ValueError("Missing the required parameter `experiment_entity` when calling `update_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in params:
            path_params['experimentID'] = params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_entity' in params:
            body_params = params['experiment_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_history(self, model_history_server_id, model_history_id, update_model_history_request, **kwargs):  # noqa: E501
        """Update a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_model_history(model_history_server_id, model_history_id, update_model_history_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to update (required)
        :param AddModelHistoryRequest update_model_history_request: The model history request object (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_model_history_with_http_info(model_history_server_id, model_history_id, update_model_history_request, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_history_with_http_info(model_history_server_id, model_history_id, update_model_history_request, **kwargs)  # noqa: E501
            return data

    def update_model_history_with_http_info(self, model_history_server_id, model_history_id, update_model_history_request, **kwargs):  # noqa: E501
        """Update a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_model_history_with_http_info(model_history_server_id, model_history_id, update_model_history_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to update (required)
        :param AddModelHistoryRequest update_model_history_request: The model history request object (required)
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_history_server_id', 'model_history_id', 'update_model_history_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in params or
                params['model_history_server_id'] is None):
            raise ValueError("Missing the required parameter `model_history_server_id` when calling `update_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in params or
                params['model_history_id'] is None):
            raise ValueError("Missing the required parameter `model_history_id` when calling `update_model_history`")  # noqa: E501
        # verify the required parameter 'update_model_history_request' is set
        if ('update_model_history_request' not in params or
                params['update_model_history_request'] is None):
            raise ValueError("Missing the required parameter `update_model_history_request` when calling `update_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in params:
            path_params['modelHistoryServerId'] = params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in params:
            path_params['modelHistoryID'] = params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_model_history_request' in params:
            body_params = params['update_model_history_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user, **kwargs):  # noqa: E501
        """Update a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: User details (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Update a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_with_http_info(user, async=True)
        >>> result = thread.get()

        :param async bool
        :param User user: User details (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload(self, **kwargs):  # noqa: E501
        """Upload a model file to SKIL for import.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.upload(async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The file to upload.
        :return: FileUploadList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.upload_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upload_with_http_info(**kwargs)  # noqa: E501
            return data

    def upload_with_http_info(self, **kwargs):  # noqa: E501
        """Upload a model file to SKIL for import.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.upload_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param file file: The file to upload.
        :return: FileUploadList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/upload/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileUploadList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
