
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>elephant.spike_train_correlation &#8212; Elephant 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/elephant_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/elephant_logo_sidebar.png"></span>
          Elephant</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Pages <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Prerequisites / Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Function Reference by Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide.html">Developers&#8217; guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc_style_guidelines.html">Documentation and style guideline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors and contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for elephant.spike_train_correlation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This modules provides functions to calculate correlations between spike trains.</span>

<span class="sd">:copyright: Copyright 2015-2016 by the Elephant team, see AUTHORS.txt.</span>
<span class="sd">:license: Modified BSD, see LICENSE.txt for details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">neo</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>


<div class="viewcode-block" id="covariance"><a class="viewcode-back" href="../../source/elephant.spike_train_correlation.html#elephant.spike_train_correlation.covariance">[docs]</a><span class="k">def</span> <span class="nf">covariance</span><span class="p">(</span><span class="n">binned_sts</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculate the NxN matrix of pairwise covariances between all combinations</span>
<span class="sd">    of N binned spike trains.</span>

<span class="sd">    For each pair of spike trains :math:`(i,j)`, the covariance :math:`C[i,j]`</span>
<span class="sd">    is obtained by binning :math:`i` and :math:`j` at the desired bin size. Let</span>
<span class="sd">    :math:`b_i` and :math:`b_j` denote the binary vectors and :math:`m_i` and</span>
<span class="sd">    :math:`m_j` their respective averages. Then</span>

<span class="sd">    .. math::</span>
<span class="sd">         C[i,j] = &lt;b_i-m_i, b_j-m_j&gt; / (l-1)</span>

<span class="sd">    where &lt;..,.&gt; is the scalar product of two vectors.</span>

<span class="sd">    For an input of n spike trains, a n x n matrix is returned containing the</span>
<span class="sd">    covariances for each combination of input spike trains.</span>

<span class="sd">    If binary is True, the binned spike trains are clipped to 0 or 1 before</span>
<span class="sd">    computing the covariance, so that the binned vectors :math:`b_i` and</span>
<span class="sd">    :math:`b_j` are binary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binned_sts : elephant.conversion.BinnedSpikeTrain</span>
<span class="sd">        A binned spike train containing the spike trains to be evaluated.</span>
<span class="sd">    binary : bool, optional</span>
<span class="sd">        If True, two spikes of a particular spike train falling in the same bin</span>
<span class="sd">        are counted as 1, resulting in binary binned vectors :math:`b_i`. If</span>
<span class="sd">        False, the binned vectors :math:`b_i` contain the spike counts per bin.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : ndarrray</span>
<span class="sd">        The square matrix of covariances. The element :math:`C[i,j]=C[j,i]` is</span>
<span class="sd">        the covariance between binned_sts[i] and binned_sts[j].</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate two Poisson spike trains</span>

<span class="sd">    &gt;&gt;&gt; from elephant.spike_train_generation import homogeneous_poisson_process</span>
<span class="sd">    &gt;&gt;&gt; st1 = homogeneous_poisson_process(</span>
<span class="sd">            rate=10.0*Hz, t_start=0.0*s, t_stop=10.0*s)</span>
<span class="sd">    &gt;&gt;&gt; st2 = homogeneous_poisson_process(</span>
<span class="sd">            rate=10.0*Hz, t_start=0.0*s, t_stop=10.0*s)</span>

<span class="sd">    Calculate the covariance matrix.</span>

<span class="sd">    &gt;&gt;&gt; from elephant.conversion import BinnedSpikeTrain</span>
<span class="sd">    &gt;&gt;&gt; cov_matrix = covariance(BinnedSpikeTrain([st1, st2], binsize=5*ms))</span>

<span class="sd">    The covariance between the spike trains is stored in cc_matrix[0,1] (or</span>
<span class="sd">    cov_matrix[1,0]).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The spike trains in the binned structure are assumed to all cover the</span>
<span class="sd">      complete time span of binned_sts [t_start,t_stop).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">__calculate_correlation_or_covariance</span><span class="p">(</span>
        <span class="n">binned_sts</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">corrcoef_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="corrcoef"><a class="viewcode-back" href="../../source/elephant.spike_train_correlation.html#elephant.spike_train_correlation.corrcoef">[docs]</a><span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">binned_sts</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculate the NxN matrix of pairwise Pearson&#39;s correlation coefficients</span>
<span class="sd">    between all combinations of N binned spike trains.</span>

<span class="sd">    For each pair of spike trains :math:`(i,j)`, the correlation coefficient</span>
<span class="sd">    :math:`C[i,j]` is obtained by binning :math:`i` and :math:`j` at the</span>
<span class="sd">    desired bin size. Let :math:`b_i` and :math:`b_j` denote the binary vectors</span>
<span class="sd">    and :math:`m_i` and :math:`m_j` their respective averages. Then</span>

<span class="sd">    .. math::</span>
<span class="sd">         C[i,j] = &lt;b_i-m_i, b_j-m_j&gt; /</span>
<span class="sd">                      \sqrt{&lt;b_i-m_i, b_i-m_i&gt;*&lt;b_j-m_j,b_j-m_j&gt;}</span>

<span class="sd">    where &lt;..,.&gt; is the scalar product of two vectors.</span>

<span class="sd">    For an input of n spike trains, a n x n matrix is returned.</span>
<span class="sd">    Each entry in the matrix is a real number ranging between -1 (perfectly</span>
<span class="sd">    anti-correlated spike trains) and +1 (perfectly correlated spike trains).</span>

<span class="sd">    If binary is True, the binned spike trains are clipped to 0 or 1 before</span>
<span class="sd">    computing the correlation coefficients, so that the binned vectors</span>
<span class="sd">    :math:`b_i` and :math:`b_j` are binary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binned_sts : elephant.conversion.BinnedSpikeTrain</span>
<span class="sd">        A binned spike train containing the spike trains to be evaluated.</span>
<span class="sd">    binary : bool, optional</span>
<span class="sd">        If True, two spikes of a particular spike train falling in the same bin</span>
<span class="sd">        are counted as 1, resulting in binary binned vectors :math:`b_i`. If</span>
<span class="sd">        False, the binned vectors :math:`b_i` contain the spike counts per bin.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : ndarrray</span>
<span class="sd">        The square matrix of correlation coefficients. The element</span>
<span class="sd">        :math:`C[i,j]=C[j,i]` is the Pearson&#39;s correlation coefficient between</span>
<span class="sd">        binned_sts[i] and binned_sts[j]. If binned_sts contains only one</span>
<span class="sd">        SpikeTrain, C=1.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate two Poisson spike trains</span>

<span class="sd">    &gt;&gt;&gt; from elephant.spike_train_generation import homogeneous_poisson_process</span>
<span class="sd">    &gt;&gt;&gt; st1 = homogeneous_poisson_process(</span>
<span class="sd">            rate=10.0*Hz, t_start=0.0*s, t_stop=10.0*s)</span>
<span class="sd">    &gt;&gt;&gt; st2 = homogeneous_poisson_process(</span>
<span class="sd">            rate=10.0*Hz, t_start=0.0*s, t_stop=10.0*s)</span>

<span class="sd">    Calculate the correlation matrix.</span>

<span class="sd">    &gt;&gt;&gt; from elephant.conversion import BinnedSpikeTrain</span>
<span class="sd">    &gt;&gt;&gt; cc_matrix = corrcoef(BinnedSpikeTrain([st1, st2], binsize=5*ms))</span>

<span class="sd">    The correlation coefficient between the spike trains is stored in</span>
<span class="sd">    cc_matrix[0,1] (or cc_matrix[1,0]).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The spike trains in the binned structure are assumed to all cover the</span>
<span class="sd">      complete time span of binned_sts [t_start,t_stop).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">__calculate_correlation_or_covariance</span><span class="p">(</span>
        <span class="n">binned_sts</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">corrcoef_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">__calculate_correlation_or_covariance</span><span class="p">(</span><span class="n">binned_sts</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">corrcoef_norm</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Helper function for covariance() and corrcoef() that performs the complete</span>
<span class="sd">    calculation for either the covariance (corrcoef_norm=False) or correlation</span>
<span class="sd">    coefficient (corrcoef_norm=True). Both calculations differ only by the</span>
<span class="sd">    denominator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binned_sts : elephant.conversion.BinnedSpikeTrain</span>
<span class="sd">        See covariance() or corrcoef(), respectively.</span>
<span class="sd">    binary : bool</span>
<span class="sd">        See covariance() or corrcoef(), respectively.</span>
<span class="sd">    corrcoef_norm : bool</span>
<span class="sd">        Use normalization factor for the correlation coefficient rather than</span>
<span class="sd">        for the covariance.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">num_neurons</span> <span class="o">=</span> <span class="n">binned_sts</span><span class="o">.</span><span class="n">matrix_rows</span>

    <span class="c1"># Pre-allocate correlation matrix</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">))</span>

    <span class="c1"># Retrieve unclipped matrix</span>
    <span class="n">spmat</span> <span class="o">=</span> <span class="n">binned_sts</span><span class="o">.</span><span class="n">to_sparse_array</span><span class="p">()</span>

    <span class="c1"># For each row, extract the nonzero column indices and the corresponding</span>
    <span class="c1"># data in the matrix (for performance reasons)</span>
    <span class="n">bin_idx_unique</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bin_counts_unique</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spmat</span><span class="p">:</span>
            <span class="n">bin_idx_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spmat</span><span class="p">:</span>
            <span class="n">bin_counts_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># All combinations of spike trains</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">):</span>
            <span class="c1"># Enumerator:</span>
            <span class="c1"># $$ &lt;b_i-m_i, b_j-m_j&gt;</span>
            <span class="c1">#      = &lt;b_i, b_j&gt; + l*m_i*m_j - &lt;b_i, M_j&gt; - &lt;b_j, M_i&gt;</span>
            <span class="c1">#      =:    ij     + l*m_i*m_j - n_i * m_j  - n_j * m_i</span>
            <span class="c1">#      =     ij     - n_i*n_j/l                         $$</span>
            <span class="c1"># where $n_i$ is the spike count of spike train $i$,</span>
            <span class="c1"># $l$ is the number of bins used (i.e., length of $b_i$ or $b_j$),</span>
            <span class="c1"># and $M_i$ is a vector [m_i, m_i,..., m_i].</span>
            <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
                <span class="c1"># Intersect indices to identify number of coincident spikes in</span>
                <span class="c1"># i and j (more efficient than directly using the dot product)</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                    <span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                <span class="c1"># Number of spikes in i and j</span>
                <span class="n">n_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">n_j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate dot product b_i*b_j between unclipped matrices</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">spmat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">spmat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Number of spikes in i and j</span>
                <span class="n">n_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">n_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="n">enumerator</span> <span class="o">=</span> <span class="n">ij</span> <span class="o">-</span> <span class="n">n_i</span> <span class="o">*</span> <span class="n">n_j</span> <span class="o">/</span> <span class="n">binned_sts</span><span class="o">.</span><span class="n">num_bins</span>

            <span class="c1"># Denominator:</span>
            <span class="k">if</span> <span class="n">corrcoef_norm</span><span class="p">:</span>
                <span class="c1"># Correlation coefficient</span>

                <span class="c1"># Note:</span>
                <span class="c1"># $$ &lt;b_i-m_i, b_i-m_i&gt;</span>
                <span class="c1">#      = &lt;b_i, b_i&gt; + m_i^2 - 2 &lt;b_i, M_i&gt;</span>
                <span class="c1">#      =:    ii     + m_i^2 - 2 n_i * m_i</span>
                <span class="c1">#      =     ii     - n_i^2 /               $$</span>
                <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
                    <span class="c1"># Here, b_i*b_i is just the number of filled bins (since</span>
                    <span class="c1"># each filled bin of a clipped spike train has value equal</span>
                    <span class="c1"># to 1)</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_idx_unique</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># directly calculate the dot product based on the counts of</span>
                    <span class="c1"># all filled entries (more efficient than using the dot</span>
                    <span class="c1"># product of the rows of the sparse matrix)</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">bin_counts_unique</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">ii</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">binned_sts</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span> <span class="o">*</span>
                    <span class="p">(</span><span class="n">jj</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_j</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">binned_sts</span><span class="o">.</span><span class="n">num_bins</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Covariance</span>

                <span class="c1"># $$ l-1 $$</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">binned_sts</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Fill entry of correlation matrix</span>
            <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">enumerator</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>


<div class="viewcode-block" id="cross_correlation_histogram"><a class="viewcode-back" href="../../source/elephant.spike_train_correlation.html#elephant.spike_train_correlation.cross_correlation_histogram">[docs]</a><span class="k">def</span> <span class="nf">cross_correlation_histogram</span><span class="p">(</span>
        <span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">border_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="n">cross_corr_coef</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the cross-correlation histogram (CCH) between two binned spike</span>
<span class="sd">    trains binned_st1 and binned_st2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binned_st1, binned_st2 : BinnedSpikeTrain</span>
<span class="sd">        Binned spike trains to cross-correlate. The two spike trains must have</span>
<span class="sd">        same t_start and t_stop</span>
<span class="sd">    window : string or list (optional)</span>
<span class="sd">        ‘full’: This returns the crosscorrelation at each point of overlap,</span>
<span class="sd">        with an output shape of (N+M-1,). At the end-points of the</span>
<span class="sd">        cross-correlogram, the signals do not overlap completely, and</span>
<span class="sd">        boundary effects may be seen.</span>
<span class="sd">        ‘valid’: Mode valid returns output of length max(M, N) - min(M, N) + 1.</span>
<span class="sd">        The cross-correlation product is only given for points where the</span>
<span class="sd">        signals overlap completely.</span>
<span class="sd">        Values outside the signal boundary have no effect.</span>
<span class="sd">        Default: &#39;full&#39;</span>
<span class="sd">        list of integer of of quantities (window[0]=minimum, window[1]=maximum</span>
<span class="sd">        lag): The  entries of window can be integer (number of bins) or</span>
<span class="sd">        quantities (time units of the lag), in the second case they have to be</span>
<span class="sd">        a multiple of the binsize</span>
<span class="sd">        Default: &#39;Full&#39;</span>
<span class="sd">    border_correction : bool (optional)</span>
<span class="sd">        whether to correct for the border effect. If True, the value of the</span>
<span class="sd">        CCH at bin b (for b=-H,-H+1, ...,H, where H is the CCH half-length)</span>
<span class="sd">        is multiplied by the correction factor:</span>
<span class="sd">                            (H+1)/(H+1-|b|),</span>
<span class="sd">        which linearly corrects for loss of bins at the edges.</span>
<span class="sd">        Default: False</span>
<span class="sd">    binary : bool (optional)</span>
<span class="sd">        whether to binary spikes from the same spike train falling in the</span>
<span class="sd">        same bin. If True, such spikes are considered as a single spike;</span>
<span class="sd">        otherwise they are considered as different spikes.</span>
<span class="sd">        Default: False.</span>
<span class="sd">    kernel : array or None (optional)</span>
<span class="sd">        A one dimensional array containing an optional smoothing kernel applied</span>
<span class="sd">        to the resulting CCH. The length N of the kernel indicates the</span>
<span class="sd">        smoothing window. The smoothing window cannot be larger than the</span>
<span class="sd">        maximum lag of the CCH. The kernel is normalized to unit area before</span>
<span class="sd">        being applied to the resulting CCH. Popular choices for the kernel are</span>
<span class="sd">          * normalized boxcar kernel: numpy.ones(N)</span>
<span class="sd">          * hamming: numpy.hamming(N)</span>
<span class="sd">          * hanning: numpy.hanning(N)</span>
<span class="sd">          * bartlett: numpy.bartlett(N)</span>
<span class="sd">        If None is specified, the CCH is not smoothed.</span>
<span class="sd">        Default: None</span>
<span class="sd">    method : string (optional)</span>
<span class="sd">        Defines the algorithm to use. &quot;speed&quot; uses numpy.correlate to calculate</span>
<span class="sd">        the correlation between two binned spike trains using a non-sparse data</span>
<span class="sd">        representation. Due to various optimizations, it is the fastest</span>
<span class="sd">        realization. In contrast, the option &quot;memory&quot; uses an own</span>
<span class="sd">        implementation to calculate the correlation based on sparse matrices,</span>
<span class="sd">        which is more memory efficient but slower than the &quot;speed&quot; option.</span>
<span class="sd">        Default: &quot;speed&quot;</span>
<span class="sd">    cross_corr_coef : bool (optional)</span>
<span class="sd">        Normalizes the CCH to obtain the cross-correlation  coefficient </span>
<span class="sd">        function ranging from -1 to 1 according to Equation (5.10) in </span>
<span class="sd">        &quot;Analysis of parallel spike trains&quot;, 2010, Gruen &amp; Rotter, Vol 7</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cch : AnalogSignal</span>
<span class="sd">        Containing the cross-correlation histogram between binned_st1 and binned_st2.</span>

<span class="sd">        The central bin of the histogram represents correlation at zero</span>
<span class="sd">        delay. Offset bins correspond to correlations at a delay equivalent</span>
<span class="sd">        to the difference between the spike times of binned_st1 and those of binned_st2: an</span>
<span class="sd">        entry at positive lags corresponds to a spike in binned_st2 following a</span>
<span class="sd">        spike in binned_st1 bins to the right, and an entry at negative lags</span>
<span class="sd">        corresponds to a spike in binned_st1 following a spike in binned_st2.</span>

<span class="sd">        To illustrate this definition, consider the two spike trains:</span>
<span class="sd">        binned_st1: 0 0 0 0 1 0 0 0 0 0 0</span>
<span class="sd">        binned_st2: 0 0 0 0 0 0 0 1 0 0 0</span>
<span class="sd">        Here, the CCH will have an entry of 1 at lag h=+3.</span>

<span class="sd">        Consistent with the definition of AnalogSignals, the time axis</span>
<span class="sd">        represents the left bin borders of each histogram bin. For example,</span>
<span class="sd">        the time axis might be:</span>
<span class="sd">        np.array([-2.5 -1.5 -0.5 0.5 1.5]) * ms</span>
<span class="sd">    bin_ids : ndarray of int</span>
<span class="sd">        Contains the IDs of the individual histogram bins, where the central</span>
<span class="sd">        bin has ID 0, bins the left have negative IDs and bins to the right</span>
<span class="sd">        have positive IDs, e.g.,:</span>
<span class="sd">        np.array([-3, -2, -1, 0, 1, 2, 3])</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        Plot the cross-correlation histogram between two Poisson spike trains</span>
<span class="sd">        &gt;&gt;&gt; import elephant</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; import quantities as pq</span>

<span class="sd">        &gt;&gt;&gt; binned_st1 = elephant.conversion.BinnedSpikeTrain(</span>
<span class="sd">                elephant.spike_train_generation.homogeneous_poisson_process(</span>
<span class="sd">                    10. * pq.Hz, t_start=0 * pq.ms, t_stop=5000 * pq.ms),</span>
<span class="sd">                binsize=5. * pq.ms)</span>
<span class="sd">        &gt;&gt;&gt; binned_st2 = elephant.conversion.BinnedSpikeTrain(</span>
<span class="sd">                elephant.spike_train_generation.homogeneous_poisson_process(</span>
<span class="sd">                    10. * pq.Hz, t_start=0 * pq.ms, t_stop=5000 * pq.ms),</span>
<span class="sd">                binsize=5. * pq.ms)</span>

<span class="sd">        &gt;&gt;&gt; cc_hist = elephant.spike_train_correlation.cross_correlation_histogram(</span>
<span class="sd">                binned_st1, binned_st2, window=[-30,30],</span>
<span class="sd">                border_correction=False,</span>
<span class="sd">                binary=False, kernel=None, method=&#39;memory&#39;)</span>

<span class="sd">        &gt;&gt;&gt; plt.bar(</span>
<span class="sd">                left=cc_hist[0].times.magnitude,</span>
<span class="sd">                height=cc_hist[0][:, 0].magnitude,</span>
<span class="sd">                width=cc_hist[0].sampling_period.magnitude)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;time (&#39; + str(cc_hist[0].times.units) + &#39;)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;cross-correlation histogram&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Alias</span>
<span class="sd">    -----</span>
<span class="sd">    cch</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="nf">_cross_corr_coef</span><span class="p">(</span><span class="n">cch_result</span><span class="p">,</span> <span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">):</span>
        <span class="c1"># Normalizes the CCH to obtain the cross-correlation </span>
        <span class="c1"># coefficient function ranging from -1 to 1</span>
        <span class="n">N</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">spike_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">spike_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">spmat</span> <span class="o">=</span> <span class="p">[</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">to_sparse_array</span><span class="p">(),</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">to_sparse_array</span><span class="p">()]</span>
        <span class="n">bin_counts_unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spmat</span><span class="p">:</span>
            <span class="n">bin_counts_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_counts_unique</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bin_counts_unique</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_counts_unique</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rho_xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">cch_result</span> <span class="o">-</span> <span class="n">Nx</span><span class="o">*</span><span class="n">Ny</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">ii</span><span class="o">-</span><span class="n">Nx</span><span class="o">**</span><span class="mf">2.</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">jj</span><span class="o">-</span><span class="n">Ny</span><span class="o">**</span><span class="mf">2.</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">rho_xy</span>
        
        
    <span class="k">def</span> <span class="nf">_border_correction</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">max_num_bins</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># Correct the values taking into account lacking contributes</span>
        <span class="c1"># at the edges</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">max_num_bins</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span> <span class="o">*</span> <span class="n">correction</span>

    <span class="k">def</span> <span class="nf">_kernel_smoothing</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># Define the kern for smoothing as an ndarray</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kern</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;The length of the kernel cannot be larger than the &#39;</span>
                    <span class="s1">&#39;length </span><span class="si">%d</span><span class="s1"> of the resulting CCH.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">kern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kern</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">kern</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">kern</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kern</span><span class="p">)</span>
        <span class="c1"># Check kern parameter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid smoothing kernel.&#39;</span><span class="p">)</span>

        <span class="c1"># Smooth the cross-correlation histogram with the kern</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cch_memory</span><span class="p">(</span><span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">border_corr</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">kern</span><span class="p">):</span>

        <span class="c1"># Retrieve unclipped matrix</span>
        <span class="n">st1_spmat</span> <span class="o">=</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">to_sparse_array</span><span class="p">()</span>
        <span class="n">st2_spmat</span> <span class="o">=</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">to_sparse_array</span><span class="p">()</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span>
        <span class="n">max_num_bins</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span>

        <span class="c1"># Set the time window in which is computed the cch</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Window parameter given in number of bins (integer)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Check the window parameter values</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">max_num_bins</span> \
                        <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_num_bins</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The window exceeds the length of the spike trains&quot;</span><span class="p">)</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Window parameter given in time units</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check the window parameter values</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">%</span> \
                    <span class="n">binsize</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
                        <span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">%</span> <span class="n">binsize</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The window has to be a multiple of the binsize&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">max_num_bins</span> <span class="o">*</span> <span class="n">binsize</span> \
                        <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_num_bins</span> <span class="o">*</span> <span class="n">binsize</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The window exceeds the length of the&quot;</span>
                                     <span class="s2">&quot; spike trains&quot;</span><span class="p">)</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span>
        <span class="c1"># Case without explicit window parameter</span>
        <span class="k">elif</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="c1"># cch computed for all the possible entries</span>
            <span class="c1"># Assign left and right edges of the cch</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">l</span> <span class="o">=</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># cch compute only for the entries that completely overlap</span>
        <span class="k">elif</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
            <span class="c1"># cch computed only for valid entries</span>
            <span class="c1"># Assign left and right edges of the cch</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Check the mode parameter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Invalid window parameter&quot;</span><span class="p">)</span>

        <span class="c1"># For each row, extract the nonzero column indices</span>
        <span class="c1"># and the corresponding # data in the matrix (for performance reasons)</span>
        <span class="n">st1_bin_idx_unique</span> <span class="o">=</span> <span class="n">st1_spmat</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">st2_bin_idx_unique</span> <span class="o">=</span> <span class="n">st2_spmat</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Case with binary entries</span>
        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="n">st1_bin_counts_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st1_spmat</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">st2_bin_counts_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st2_spmat</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Case with all values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st1_bin_counts_unique</span> <span class="o">=</span> <span class="n">st1_spmat</span><span class="o">.</span><span class="n">data</span>
            <span class="n">st2_bin_counts_unique</span> <span class="o">=</span> <span class="n">st2_spmat</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Initialize the counts to an array of zeroes,</span>
        <span class="c1"># and the bin IDs to integers</span>
        <span class="c1"># spanning the time axis</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute the CCH at lags in l,...,r only</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st1_bin_idx_unique</span><span class="p">):</span>
            <span class="n">il</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">st2_bin_idx_unique</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">st2_bin_idx_unique</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">timediff</span> <span class="o">=</span> <span class="n">st2_bin_idx_unique</span><span class="p">[</span><span class="n">il</span><span class="p">:</span><span class="n">ir</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">assert</span> <span class="p">((</span><span class="n">timediff</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timediff</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Not all the &#39;</span>
            <span class="s1">&#39;entries of cch lie in the window&#39;</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">timediff</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">st1_bin_counts_unique</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span>
                                             <span class="n">st2_bin_counts_unique</span><span class="p">[</span><span class="n">il</span><span class="p">:</span><span class="n">ir</span><span class="p">])</span>
            <span class="n">st2_bin_idx_unique</span> <span class="o">=</span> <span class="n">st2_bin_idx_unique</span><span class="p">[</span><span class="n">il</span><span class="p">:]</span>
            <span class="n">st2_bin_counts_unique</span> <span class="o">=</span> <span class="n">st2_bin_counts_unique</span><span class="p">[</span><span class="n">il</span><span class="p">:]</span>
        <span class="c1"># Border correction</span>
        <span class="k">if</span> <span class="n">border_corr</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">_border_correction</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">max_num_bins</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Smoothing</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">_kernel_smoothing</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="c1"># Transform the array count into an AnalogSignal</span>
        <span class="n">cch_result</span> <span class="o">=</span> <span class="n">neo</span><span class="o">.</span><span class="n">AnalogSignal</span><span class="p">(</span>
            <span class="n">signal</span><span class="o">=</span><span class="n">counts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">,</span>
            <span class="n">t_start</span><span class="o">=</span><span class="p">(</span><span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span><span class="p">,</span>
            <span class="n">sampling_period</span><span class="o">=</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span><span class="p">)</span>
        <span class="c1"># Return only the hist_bins bins and counts before and after the</span>
        <span class="c1"># central one</span>
        <span class="k">return</span> <span class="n">cch_result</span><span class="p">,</span> <span class="n">bin_ids</span>

    <span class="k">def</span> <span class="nf">_cch_speed</span><span class="p">(</span><span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">border_corr</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">kern</span><span class="p">):</span>

        <span class="c1"># Retrieve the array of the binne spik train</span>
        <span class="n">st1_arr</span> <span class="o">=</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">to_array</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">st2_arr</span> <span class="o">=</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">to_array</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">binsize</span> <span class="o">=</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span>

        <span class="c1"># Convert the to binary version</span>
        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="n">st1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st1_arr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">st2_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">st2_arr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">max_num_bins</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st1_arr</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">st2_arr</span><span class="p">))</span>

        <span class="c1"># Cross correlate the spiketrains</span>

        <span class="c1"># Case explicit temporal window</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Window parameter given in number of bins (integer)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Check the window parameter values</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">max_num_bins</span> \
                        <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_num_bins</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The window exceed the length of the spike trains&quot;</span><span class="p">)</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">win</span>
            <span class="c1"># Window parameter given in time units</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check the window parameter values</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">%</span> \
                    <span class="n">binsize</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
                        <span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">%</span> <span class="n">binsize</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The window has to be a multiple of the binsize&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">max_num_bins</span> <span class="o">*</span> <span class="n">binsize</span> \
                        <span class="ow">or</span> <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_num_bins</span> <span class="o">*</span> <span class="n">binsize</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The window exceed the length of the&quot;</span>
                                     <span class="s2">&quot; spike trains&quot;</span><span class="p">)</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span>

            <span class="c1"># Zero padding</span>
            <span class="n">st1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">st1_arr</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span>
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">cch_mode</span> <span class="o">=</span> <span class="s1">&#39;valid&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assign the edges of the cch for the different mode parameters</span>
            <span class="k">if</span> <span class="n">win</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">l</span> <span class="o">=</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># cch compute only for the entries that completely overlap</span>
            <span class="k">elif</span> <span class="n">win</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
                <span class="c1"># Assign left and right edges of the cch</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">-</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cch_mode</span> <span class="o">=</span> <span class="n">win</span>

        <span class="c1"># Cross correlate the spike trains</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">st2_arr</span><span class="p">,</span> <span class="n">st1_arr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">cch_mode</span><span class="p">)</span>
        <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Border correction</span>
        <span class="k">if</span> <span class="n">border_corr</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">_border_correction</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">max_num_bins</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Smoothing</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">_kernel_smoothing</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="c1"># Transform the array count into an AnalogSignal</span>
        <span class="n">cch_result</span> <span class="o">=</span> <span class="n">neo</span><span class="o">.</span><span class="n">AnalogSignal</span><span class="p">(</span>
            <span class="n">signal</span><span class="o">=</span><span class="n">counts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">units</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">,</span>
            <span class="n">t_start</span><span class="o">=</span><span class="p">(</span><span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span><span class="p">,</span>
            <span class="n">sampling_period</span><span class="o">=</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span><span class="p">)</span>
        <span class="c1"># Return only the hist_bins bins and counts before and after the</span>
        <span class="c1"># central one</span>
        <span class="k">return</span> <span class="n">cch_result</span><span class="p">,</span> <span class="n">bin_ids</span>

    <span class="c1"># Check that the spike trains are binned with the same temporal</span>
    <span class="c1"># resolution</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">matrix_rows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Spike train must be one dimensional&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">matrix_rows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Spike train must be one dimensional&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">binsize</span> <span class="o">==</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">binsize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Bin sizes must be equal&quot;</span><span class="p">)</span>

    <span class="c1"># Check t_start and t_stop identical (to drop once that the</span>
    <span class="c1"># pad functionality wil be available in the BinnedSpikeTrain classe)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">t_start</span> <span class="o">==</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">t_start</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Spike train must have same t start&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned_st1</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">==</span> <span class="n">binned_st2</span><span class="o">.</span><span class="n">t_stop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Spike train must have same t stop&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;memory&quot;</span><span class="p">:</span>
        <span class="n">cch_result</span><span class="p">,</span> <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">_cch_memory</span><span class="p">(</span>
            <span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">border_correction</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span>
            <span class="n">kernel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;speed&quot;</span><span class="p">:</span>

        <span class="n">cch_result</span><span class="p">,</span> <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">_cch_speed</span><span class="p">(</span>
            <span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">border_correction</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span>
            <span class="n">kernel</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cross_corr_coef</span><span class="p">:</span>
        <span class="n">cch_result</span> <span class="o">=</span> <span class="n">_cross_corr_coef</span><span class="p">(</span><span class="n">cch_result</span><span class="p">,</span> <span class="n">binned_st1</span><span class="p">,</span> <span class="n">binned_st2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cch_result</span><span class="p">,</span> <span class="n">bin_ids</span></div>

<span class="c1"># Alias for common abbreviation</span>
<span class="n">cch</span> <span class="o">=</span> <span class="n">cross_correlation_histogram</span>


<div class="viewcode-block" id="spike_time_tiling_coefficient"><a class="viewcode-back" href="../../source/elephant.spike_train_correlation.html#elephant.spike_train_correlation.spike_time_tiling_coefficient">[docs]</a><span class="k">def</span> <span class="nf">spike_time_tiling_coefficient</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">,</span> <span class="n">spiketrain_2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Spike Time Tiling Coefficient (STTC) as described in</span>
<span class="sd">    (Cutts &amp; Eglen, 2014) following Cutts&#39; implementation in C.</span>
<span class="sd">    The STTC is a pairwise measure of correlation between spike trains.</span>
<span class="sd">    It has been proposed as a replacement for the correlation index as it</span>
<span class="sd">    presents several advantages (e.g. it&#39;s not confounded by firing rate,</span>
<span class="sd">    appropriately distinguishes lack of correlation from anti-correlation,</span>
<span class="sd">    periods of silence don&#39;t add to the correlation and it&#39;s sensible to</span>
<span class="sd">    firing pattern).</span>

<span class="sd">    The STTC is calculated as follows:</span>

<span class="sd">    .. math::</span>
<span class="sd">        STTC = 1/2((PA - TB)/(1 - PA*TB) + (PB - TA)/(1 - PB*TA))</span>

<span class="sd">    Where `PA` is the proportion of spikes from train 1 that lie within</span>
<span class="sd">    `[-dt, +dt]` of any spike of train 2 divided by the total number of spikes</span>
<span class="sd">    in train 1, `PB` is the same proportion for the spikes in train 2;</span>
<span class="sd">    `TA` is the proportion of total recording time within `[-dt, +dt]` of any</span>
<span class="sd">    spike in train 1, TB is the same propotion for train 2.</span>

<span class="sd">    This is a Python implementation compatible with the elephant library of</span>
<span class="sd">    the original code by C. Cutts written in C and avaiable at:</span>
<span class="sd">    (https://github.com/CCutts/Detecting_pairwise_correlations_in_spike_trains/blob/master/spike_time_tiling_coefficient.c)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spiketrain_1, spiketrain_2: neo.Spiketrain objects to cross-correlate.</span>
<span class="sd">        Must have the same t_start and t_stop.</span>
<span class="sd">    dt: Python Quantity.</span>
<span class="sd">        The synchronicity window is used for both: the quantification of the</span>
<span class="sd">        propotion of total recording time that lies [-dt, +dt] of each spike</span>
<span class="sd">        in each train and the proportion of spikes in `spiketrain_1` that lies</span>
<span class="sd">        `[-dt, +dt]` of any spike in `spiketrain_2`.</span>
<span class="sd">        Default : 0.005 * pq.s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index:  float</span>
<span class="sd">        The spike time tiling coefficient (STTC). Returns np.nan if any spike</span>
<span class="sd">        train is empty.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Cutts, C. S., &amp; Eglen, S. J. (2014). Detecting Pairwise Correlations in</span>
<span class="sd">    Spike Trains: An Objective Comparison of Methods and Application to the</span>
<span class="sd">    Study of Retinal Waves. Journal of Neuroscience, 34(43), 14288–14303.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run_P</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">,</span> <span class="n">spiketrain_2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check every spike in train 1 to see if there&#39;s a spike in train 2</span>
<span class="sd">        within dt</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nab</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N2</span><span class="p">:</span>  <span class="c1"># don&#39;t need to search all j each iteration</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">spiketrain_2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">dt</span><span class="p">:</span>
                    <span class="n">Nab</span> <span class="o">=</span> <span class="n">Nab</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">spiketrain_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">spiketrain_1</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Nab</span>

    <span class="k">def</span> <span class="nf">run_T</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the proportion of the total recording time &#39;tiled&#39; by spikes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_A</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">dt</span>  <span class="c1"># maxium possible time</span>

        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># for just one spike in train</span>
            <span class="k">if</span> <span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_start</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">:</span>
                <span class="n">time_A</span> <span class="o">=</span> <span class="n">time_A</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_start</span>
            <span class="k">elif</span> <span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_stop</span><span class="p">:</span>
                <span class="n">time_A</span> <span class="o">=</span> <span class="n">time_A</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_stop</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if more than one spike in train</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">spiketrain</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">):</span>  <span class="c1"># subtract overlap</span>
                    <span class="n">time_A</span> <span class="o">=</span> <span class="n">time_A</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">diff</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># check if spikes are within dt of the start and/or end</span>
                <span class="c1"># if so just need to subract overlap of first and/or last spike</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">:</span>
                <span class="n">time_A</span> <span class="o">=</span> <span class="n">time_A</span> <span class="o">+</span> <span class="n">spiketrain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_start</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">spiketrain</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">:</span>
                <span class="n">time_A</span> <span class="o">=</span> <span class="n">time_A</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_stop</span>

        <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_A</span> <span class="o">/</span> <span class="p">(</span><span class="n">spiketrain</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">spiketrain</span><span class="o">.</span><span class="n">t_start</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">T</span>

    <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">)</span>
    <span class="n">N2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketrain_2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">N2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">TA</span> <span class="o">=</span> <span class="n">run_T</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">TB</span> <span class="o">=</span> <span class="n">run_T</span><span class="p">(</span><span class="n">spiketrain_2</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">PA</span> <span class="o">=</span> <span class="n">run_P</span><span class="p">(</span><span class="n">spiketrain_1</span><span class="p">,</span> <span class="n">spiketrain_2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">PA</span> <span class="o">=</span> <span class="n">PA</span> <span class="o">/</span> <span class="n">N1</span>
        <span class="n">PB</span> <span class="o">=</span> <span class="n">run_P</span><span class="p">(</span><span class="n">spiketrain_2</span><span class="p">,</span> <span class="n">spiketrain_1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">PB</span> <span class="o">=</span> <span class="n">PB</span> <span class="o">/</span> <span class="n">N2</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">PA</span> <span class="o">-</span> <span class="n">TB</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">PA</span> <span class="o">*</span> <span class="n">TB</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">PB</span> <span class="o">-</span> <span class="n">TA</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">PB</span> <span class="o">*</span> <span class="n">TA</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index</span></div>


<span class="n">sttc</span> <span class="o">=</span> <span class="n">spike_time_tiling_coefficient</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2018, Elephant authors and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>