
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>elephant.asset &#8212; Elephant 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/elephant_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/elephant_logo_sidebar.png"></span>
          Elephant</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Pages <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Prerequisites / Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Function Reference by Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide.html">Developers&#8217; guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc_style_guidelines.html">Documentation and style guideline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors and contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for elephant.asset</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ASSET is a statistical method [1] for the detection of repeating sequences</span>
<span class="sd">of synchronous spiking events in parallel spike trains.</span>
<span class="sd">Given a list `sts` of spike trains, the analysis comprises the following</span>
<span class="sd">steps:</span>

<span class="sd">1) Build the intersection matrix `imat` (optional) and the associated</span>
<span class="sd">   probability matrix `pmat` with the desired bin size:</span>

<span class="sd">       &gt;&gt;&gt; binsize = 5 * pq.ms</span>
<span class="sd">       &gt;&gt;&gt; dt = 1 * pq.s</span>
<span class="sd">       &gt;&gt;&gt; imat, xedges, yedges = intersection_matrix(sts, binsize, dt, norm=2)</span>
<span class="sd">       &gt;&gt;&gt; pmat, xedges, yedges = probability_matrix_analytical(</span>
<span class="sd">               sts, binsize, dt)</span>

<span class="sd">2) Compute the joint probability matrix jmat, using a suitable filter:</span>

<span class="sd">       &gt;&gt;&gt; filter_shape = (5,2)  # filter shape</span>
<span class="sd">       &gt;&gt;&gt; nr_neigh = 5  # nr of largest neighbors</span>
<span class="sd">       &gt;&gt;&gt; jmat = joint_probability_matrix(pmat, filter_shape, nr_neigh)</span>

<span class="sd">3) Create from pmat and jmat a masked version of the intersection matrix:</span>

<span class="sd">       &gt;&gt;&gt; alpha1 = 0.99</span>
<span class="sd">       &gt;&gt;&gt; alpha2 = 0.99999</span>
<span class="sd">       &gt;&gt;&gt; mask = mask_matrices([pmat, jmat], [alpha1, alpha2])</span>

<span class="sd">4) Cluster significant elements of imat into diagonal structures (&quot;DSs&quot;):</span>

<span class="sd">       &gt;&gt;&gt; epsilon = 10</span>
<span class="sd">       &gt;&gt;&gt; minsize = 2</span>
<span class="sd">       &gt;&gt;&gt; stretch = 5</span>
<span class="sd">       &gt;&gt;&gt; cmat = asset.cluster_matrix_entries(mask, epsilon, minsize, stretch)</span>

<span class="sd">5) Extract sequences of synchronous events associated to each worm</span>

<span class="sd">       &gt;&gt;&gt; extract_sse(sts, x_edges, y_edges, cmat)</span>

<span class="sd">References:</span>

<span class="sd">[1] Torre, Canova, Denker, Gerstein, Helias, Gruen (submitted)</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">neo</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">elephant.conversion</span> <span class="k">as</span> <span class="nn">conv</span>
<span class="kn">import</span> <span class="nn">elephant.spike_train_surrogates</span> <span class="k">as</span> <span class="nn">spike_train_surrogates</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">dbscan</span> <span class="k">as</span> <span class="n">dbscan</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Some Utility Functions to be dealt with in some way or another</span>
<span class="c1"># =============================================================================</span>


<span class="k">def</span> <span class="nf">_xrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function to use both in python 3 and python 2 to have a range</span>
<span class="sd">    function as a generator.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signals_same_tstart</span><span class="p">(</span><span class="n">signals</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Check whether a list of signals (AnalogSignals or SpikeTrains) have same</span>
<span class="sd">    attribute t_start. If so return that value. Otherwise raise a ValueError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signals : list</span>
<span class="sd">        a list of signals (e.g. AnalogSignals or SpikeTrains) having</span>
<span class="sd">        attribute `t_start`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t_start : Quantity</span>
<span class="sd">        The common attribute `t_start` of the list of signals.</span>
<span class="sd">        Raises a `ValueError` if the signals have a different `t_start`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">t_start</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t_start</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t_start</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">t_start</span> <span class="o">!=</span> <span class="n">t_start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;signals have different t_start values&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_start</span>


<span class="k">def</span> <span class="nf">_signals_same_tstop</span><span class="p">(</span><span class="n">signals</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Check whether a list of signals (AnalogSignals or SpikeTrains) have same</span>
<span class="sd">    attribute t_stop. If so return that value. Otherwise raise a ValueError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signals : list</span>
<span class="sd">        a list of signals (e.g. AnalogSignals or SpikeTrains) having</span>
<span class="sd">        attribute t_stop</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t_stop : Quantity</span>
<span class="sd">        The common attribute t_stop of the list of signals.</span>
<span class="sd">        If the signals have a different t_stop, a ValueError is raised.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">t_stop</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t_stop</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t_stop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">!=</span> <span class="n">t_stop</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;signals have different t_stop values&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_stop</span>


<span class="k">def</span> <span class="nf">_quantities_almost_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns True if two quantities are almost equal, i.e. if x-y is</span>
<span class="sd">    &quot;very close to 0&quot; (not larger than machine precision for floats).</span>

<span class="sd">    Note: not the same as numpy.testing.assert_allclose (which does not work</span>
<span class="sd">    with Quantities) and numpy.testing.assert_almost_equal (which works only</span>
<span class="sd">    with decimals)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : Quantity</span>
<span class="sd">        first Quantity to compare</span>
<span class="sd">    y : Quantity</span>
<span class="sd">        second Quantity to compare. Must have same unit type as x, but not</span>
<span class="sd">        necessarily the same shape. Any shapes of x and y for which x-y can</span>
<span class="sd">        be calculated are permitted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray of bool</span>
<span class="sd">        an array of bools, which is True at any position where x-y is almost</span>
<span class="sd">        zero</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">relative_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="n">eps</span> <span class="o">&lt;=</span> <span class="n">relative_diff</span><span class="p">,</span> <span class="n">relative_diff</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_transactions</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform parallel spike trains a into list of sublists, called</span>
<span class="sd">    transactions, each corresponding to a time bin and containing the list</span>
<span class="sd">    of spikes in spiketrains falling into that bin.</span>

<span class="sd">    To compute each transaction, the spike trains are binned (with adjacent</span>
<span class="sd">    exclusive binning) and clipped (i.e. spikes from the same train falling</span>
<span class="sd">    in the same bin are counted as one event). The list of spike ids within</span>
<span class="sd">    each bin form the corresponding transaction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spiketrains: list of neo.SpikeTrains</span>
<span class="sd">        list of neo.core.SpikeTrain objects, or list of pairs</span>
<span class="sd">        (Train_ID, SpikeTrain), where Train_ID can be any hashable object</span>
<span class="sd">    binsize: quantities.Quantity</span>
<span class="sd">        width of each time bin; time is binned to determine synchrony</span>
<span class="sd">    t_start: quantity.Quantity, optional</span>
<span class="sd">        starting time; only spikes occurring at times t &gt;= t_start are</span>
<span class="sd">        considered; the first transaction contains spikes falling into the</span>
<span class="sd">        time segment [t_start, t_start+binsize[.</span>
<span class="sd">        If None, takes the t_start value of the spike trains in spiketrains</span>
<span class="sd">        if the same for all of them, or returns an error.</span>
<span class="sd">        Default: None</span>
<span class="sd">    t_stop: quantities.Quantity, optional</span>
<span class="sd">        ending time; only spikes occurring at times t &lt; t_stop are</span>
<span class="sd">        considered.</span>
<span class="sd">        If None, takes the t_stop value of the spike trains in spiketrains</span>
<span class="sd">        if the same for all of them, or returns an error.</span>
<span class="sd">        Default: None</span>
<span class="sd">    ids : list or None, optional</span>
<span class="sd">        list of spike train IDs. If None, IDs 0 to N-1 are used, where N</span>
<span class="sd">        is the number of input spike trains</span>
<span class="sd">        Default: None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trans : list of lists</span>
<span class="sd">        a list of transactions; each transaction corresponds to a time bin</span>
<span class="sd">        and represents the list of spike trains ids having a spike in that</span>
<span class="sd">        time bin.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the spike trains and their IDs depending on the input arguments</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">neo</span><span class="o">.</span><span class="n">SpikeTrain</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]):</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]</span>
        <span class="n">trains</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="n">neo</span><span class="o">.</span><span class="n">SpikeTrain</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]):</span>
        <span class="n">trains</span> <span class="o">=</span> <span class="n">spiketrains</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;spiketrains must be either a list of &#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;SpikeTrains or a list of (id, SpikeTrain) pairs&#39;</span><span class="p">)</span>

    <span class="c1"># Take the minimum and maximum t_start and t_stop of all spike trains</span>
    <span class="c1"># TODO: the block below should be ageneral routine in elephant</span>
    <span class="n">tstarts</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="o">.</span><span class="n">t_start</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">trains</span><span class="p">]</span>
    <span class="n">tstops</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="o">.</span><span class="n">t_stop</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">trains</span><span class="p">]</span>
    <span class="n">max_tstart</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tstarts</span><span class="p">)</span>
    <span class="n">min_tstop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tstops</span><span class="p">)</span>

    <span class="c1"># Set starting time of binning</span>
    <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_signals_same_tstart</span><span class="p">(</span><span class="n">trains</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t_start</span> <span class="o">&lt;</span> <span class="n">max_tstart</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Some SpikeTrains have a larger t_start &#39;</span> <span class="o">+</span>
                         <span class="s1">&#39;than the specified t_start value&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">t_start</span>

    <span class="c1"># Set stopping time of binning</span>
    <span class="k">if</span> <span class="n">t_stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">_signals_same_tstop</span><span class="p">(</span><span class="n">trains</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t_stop</span> <span class="o">&gt;</span> <span class="n">min_tstop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Some SpikeTrains have a smaller t_stop &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;than the specified t_stop value&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">t_stop</span>

    <span class="c1"># Bin the spike trains and take for each of them the ids of filled bins</span>
    <span class="n">binned</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span>
        <span class="n">trains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
    <span class="n">Nbins</span> <span class="o">=</span> <span class="n">binned</span><span class="o">.</span><span class="n">num_bins</span>

    <span class="n">filled_bins</span> <span class="o">=</span> <span class="n">binned</span><span class="o">.</span><span class="n">spike_indices</span>

    <span class="c1"># Compute and return the transaction list</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">train_id</span> <span class="k">for</span> <span class="n">train_id</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">filled_bins</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bin_id</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">bin_id</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_analog_signal_step_interp</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the step-wise interpolation of a signal at desired times.</span>

<span class="sd">    Given a signal (e.g. an AnalogSignal) s taking value s(t0) and s(t1)</span>
<span class="sd">    at two consecutive time points t0 and t1 (t0 &lt; t1), the value of the</span>
<span class="sd">    step-wise interpolation at time t: t0 &lt;= t &lt; t1 is given by s(t)=s(t0).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : neo.AnalogSignal</span>
<span class="sd">        The analog signal containing the discretization of the function to</span>
<span class="sd">        interpolate</span>
<span class="sd">    times : quantities.Quantity (vector of time points)</span>
<span class="sd">        The time points at which the step interpolation is computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantities.Quantity object with same shape of `times`, and containing</span>
<span class="sd">    the values of the interpolated signal at the time points in `times`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sampling_period</span>

    <span class="c1"># Compute the ids of the signal times to the left of each time in times</span>
    <span class="n">time_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="p">((</span><span class="n">times</span> <span class="o">-</span> <span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
            <span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">magnitude</span><span class="p">[</span><span class="n">time_ids</span><span class="p">]</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sample_quantiles</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a sample of values extracted from a probability distribution,</span>
<span class="sd">    estimates the quantile(s) associated to p-value(s) p.</span>

<span class="sd">    Given a r.v. X with probability distribution P defined over a domain D,</span>
<span class="sd">    the quantile x associated to the p-value p (0 &lt;= p &lt;= 1) is defined by:</span>
<span class="sd">                q(p) = min{x \in D: P(X&gt;=x) &lt; p}</span>
<span class="sd">    Given a sample S = {x1, x2, ..., xn} of n realisations of X, an estimate</span>
<span class="sd">    of q(p) is given by:</span>
<span class="sd">            q = min{x \in S: (#{y \in S: y&gt;=x} / #{sample}) &lt; p}</span>

<span class="sd">    For instance, if p = 0.05, calculates the lowest value q in sample such</span>
<span class="sd">    that less than 5% other values in sample are higher than q.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample : ndarray</span>
<span class="sd">        an array of sample values, which are pooled to estimate the quantile(s)</span>
<span class="sd">    p : float or list or floats or array, all in the range [0, 1]</span>
<span class="sd">        p-value(s) for which to compute the quantile(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : float, or array of floats</span>
<span class="sd">        quantile(s) associated to the input p-value(s).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute the cumulative probabilities associated to the p-values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">])</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span>

    <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">probs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">quantiles</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">quantiles</span>


<span class="k">def</span> <span class="nf">_sample_pvalue</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimates the p-value of each value in x, given a sample of values</span>
<span class="sd">    extracted from a probability distribution.</span>

<span class="sd">    Given a r.v. X with probability distribution P, the p-value of X at</span>
<span class="sd">    the point x is defined as:</span>
<span class="sd">    ..math::</span>
<span class="sd">                    pv(x) := P(X &gt;= x) = 1 - cdf(x)</span>
<span class="sd">    The smaller pv(x), the less likely that x was extracted from the same</span>
<span class="sd">    probability distribution of X.</span>
<span class="sd">    Given a sample {x1, x2, ..., xn} of n realisations of X, an estimate of</span>
<span class="sd">    pv(x) is given by:</span>
<span class="sd">                    pv(x) ~ #{i: xi &gt; x} / n</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample : ndarray</span>
<span class="sd">        a sample of realisations from a probability distribution</span>
<span class="sd">    x : float or list or floats or array</span>
<span class="sd">        p-value(s) for which to compute the quantiles</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pv : same type and shape as x</span>
<span class="sd">        p-values associated to the input values x.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Convert x to an array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>

    <span class="c1"># Convert sample to a flattened array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span><span class="p">])</span>
    <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Compute and return the p-values associated to the elements of x</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">sample</span> <span class="o">&gt;=</span> <span class="n">xx</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_time_slice</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the time slice of an AnalogSignal between t_start and t_stop.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Check which elements of the signal are between t_start and t_stop.</span>
    <span class="c1"># Retain those and the corresponding times</span>
    <span class="n">elements_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
        <span class="p">[</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">times</span> <span class="o">&lt;</span> <span class="n">t_stop</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">elements_to_keep</span><span class="p">]</span>

    <span class="c1"># Put the retained values and times into a new AnalogSignal</span>
    <span class="n">sliced_signal</span> <span class="o">=</span> <span class="n">neo</span><span class="o">.</span><span class="n">AnalogSignal</span><span class="p">(</span>
        <span class="n">signal</span><span class="p">[</span><span class="n">elements_to_keep</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span> <span class="n">t_start</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">sampling_period</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sliced_signal</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># HERE ASSET STARTS</span>
<span class="c1"># =============================================================================</span>


<div class="viewcode-block" id="intersection_matrix"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.intersection_matrix">[docs]</a><span class="k">def</span> <span class="nf">intersection_matrix</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t_start_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the intersection matrix from a list of spike trains.</span>

<span class="sd">    Given a list of SpikeTrains, consider two binned versions of them</span>
<span class="sd">    differing for the starting time of the binning (t_start_x and t_start_y</span>
<span class="sd">    respectively; the two times can be identical). Then calculate the</span>
<span class="sd">    intersection matrix M of the two binned data, where M[i,j] is the overlap</span>
<span class="sd">    of bin i in the first binned data and bin j in the second binned data</span>
<span class="sd">    (i.e. the number of spike trains spiking both at bin i and at bin j).</span>
<span class="sd">    The matrix  entries can be normalized to values between 0 and 1 via</span>
<span class="sd">    different normalizations (see below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spiketrains : list of neo.SpikeTrains</span>
<span class="sd">        list of SpikeTrains from which to compute the intersection matrix</span>
<span class="sd">    binsize : quantities.Quantity</span>
<span class="sd">        size of the time bins used to define synchronous spikes in the given</span>
<span class="sd">        SpikeTrains.</span>
<span class="sd">    dt : quantities.Quantity</span>
<span class="sd">        time span for which to consider the given SpikeTrains</span>
<span class="sd">    t_start_x : quantities.Quantity, optional</span>
<span class="sd">        time start of the binning for the first axis of the intersection</span>
<span class="sd">        matrix, respectively.</span>
<span class="sd">        If None (default) the attribute t_start of the SpikeTrains is used</span>
<span class="sd">        (if the same for all spike trains).</span>
<span class="sd">        Default: None</span>
<span class="sd">    t_start_y : quantities.Quantity, optional</span>
<span class="sd">        time start of the binning for the second axis of the intersection</span>
<span class="sd">        matrix</span>
<span class="sd">    norm : int, optional</span>
<span class="sd">        type of normalization to be applied to each entry [i,j] of the</span>
<span class="sd">        intersection matrix. Given the sets s_i, s_j of neuron ids in the</span>
<span class="sd">        bins i, j respectively, the normalisation coefficient can be:</span>
<span class="sd">        </span>
<span class="sd">            * norm = 0 or None: no normalisation (row counts)</span>
<span class="sd">            * norm = 1: len(intersection(s_i, s_j))</span>
<span class="sd">            * norm = 2: sqrt(len(s_1) * len(s_2))</span>
<span class="sd">            * norm = 3: len(union(s_i, s_j))</span>
<span class="sd">            </span>
<span class="sd">        Default: None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    imat : numpy.ndarray of floats</span>
<span class="sd">        the intersection matrix of a list of spike trains. Has shape (n,n),</span>
<span class="sd">        where n is the number of bins time was discretized in.</span>
<span class="sd">    x_edges : numpy.ndarray</span>
<span class="sd">        edges of the bins used for the horizontal axis of imat. If imat is</span>
<span class="sd">        a matrix of shape (n, n), x_edges has length n+1</span>
<span class="sd">    y_edges : numpy.ndarray</span>
<span class="sd">        edges of the bins used for the vertical axis of imat. If imat is</span>
<span class="sd">        a matrix of shape (n, n), y_edges has length n+1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Setting the start and stop time for the x and y axes:</span>
    <span class="k">if</span> <span class="n">t_start_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_start_x</span> <span class="o">=</span> <span class="n">_signals_same_tstart</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t_start_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_start_y</span> <span class="o">=</span> <span class="n">_signals_same_tstart</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">)</span>

    <span class="n">t_stop_x</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">t_start_x</span>
    <span class="n">t_stop_y</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">t_start_y</span>

    <span class="c1"># Check that all SpikeTrains are defined until t_stop at least</span>
    <span class="n">t_stop_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_stop_x</span><span class="p">,</span> <span class="n">t_stop_y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">&gt;</span> <span class="n">t_stop_max</span> <span class="ow">or</span>
                <span class="n">_quantities_almost_equal</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_stop_max</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;SpikeTrain </span><span class="si">%d</span><span class="s1"> is shorter than the required time &#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="o">+</span> \
                <span class="s1">&#39;span: t_stop (</span><span class="si">%s</span><span class="s1">) &lt; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_stop_max</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># For both x and y axis, cut all SpikeTrains between t_start and t_stop</span>
    <span class="n">sts_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">st</span><span class="o">.</span><span class="n">time_slice</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_x</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]</span>
    <span class="n">sts_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">st</span><span class="o">.</span><span class="n">time_slice</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_y</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]</span>

    <span class="c1"># Compute imat either by matrix multiplication (~20x faster) or by</span>
    <span class="c1"># nested for loops (more memory efficient)</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># try the fast version</span>
        <span class="c1"># Compute the binned spike train matrices, along both time axes</span>
        <span class="n">bsts_x</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span>
            <span class="n">sts_x</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span>
            <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_x</span><span class="p">)</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">()</span>
        <span class="n">bsts_y</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span>
            <span class="n">sts_y</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span>
            <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_y</span><span class="p">)</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">()</span>

        <span class="c1"># Compute the number of spikes in each bin, for both time axes</span>
        <span class="n">spikes_per_bin_x</span> <span class="o">=</span> <span class="n">bsts_x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">spikes_per_bin_y</span> <span class="o">=</span> <span class="n">bsts_y</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Compute the intersection matrix imat</span>
        <span class="n">N_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes_per_bin_x</span><span class="p">)</span>
        <span class="n">imat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_bins</span><span class="p">,</span> <span class="n">N_bins</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1.</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">N_bins</span><span class="p">):</span>
            <span class="c1"># Compute the ii-th row of imat</span>
            <span class="n">bin_ii</span> <span class="o">=</span> <span class="n">bsts_x</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_ii</span> <span class="o">*</span> <span class="n">bsts_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Normalize the row according to the specified normalization</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bin_ii</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">norm_coef</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">norm_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                    <span class="n">spikes_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">spikes_per_bin_y</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">norm_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">spikes_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">spikes_per_bin_y</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">norm_coef</span> <span class="o">=</span> <span class="p">((</span><span class="n">bin_ii</span> <span class="o">+</span> <span class="n">bsts_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">norm_coef</span>

        <span class="c1"># If normalization required, for each j such that bsts_y[j] is</span>
        <span class="c1"># identically 0 the code above sets imat[:, j] to identically nan.</span>
        <span class="c1"># Substitute 0s instead. Then refill the main diagonal with 1s.</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">ybins_equal_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spikes_per_bin_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">y_id</span> <span class="ow">in</span> <span class="n">ybins_equal_0</span><span class="p">:</span>
                <span class="n">imat</span><span class="p">[:,</span> <span class="n">y_id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">imat</span><span class="p">[</span><span class="n">_xrange</span><span class="p">(</span><span class="n">N_bins</span><span class="p">),</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">N_bins</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>  <span class="c1"># use the memory-efficient version</span>
        <span class="c1"># Compute the list spiking neurons per bin, along both axes</span>
        <span class="n">ids_per_bin_x</span> <span class="o">=</span> <span class="n">_transactions</span><span class="p">(</span>
            <span class="n">sts_x</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_x</span><span class="p">)</span>
        <span class="n">ids_per_bin_y</span> <span class="o">=</span> <span class="n">_transactions</span><span class="p">(</span>
            <span class="n">sts_y</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_y</span><span class="p">)</span>

        <span class="c1"># Generate the intersection matrix</span>
        <span class="n">N_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_x</span><span class="p">)</span>
        <span class="n">imat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_bins</span><span class="p">,</span> <span class="n">N_bins</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">N_bins</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">N_bins</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_y</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ids_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">ids_per_bin_y</span><span class="p">[</span><span class="n">jj</span><span class="p">])))</span>
                    <span class="c1"># Normalise according to the desired normalisation type:</span>
                    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span>
                                                  <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_y</span><span class="p">[</span><span class="n">jj</span><span class="p">])))</span>
                    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_per_bin_y</span><span class="p">[</span><span class="n">jj</span><span class="p">])))</span>
                    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">imat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span>
                            <span class="n">ids_per_bin_x</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ids_per_bin_y</span><span class="p">[</span><span class="n">jj</span><span class="p">]))))</span>

    <span class="c1"># Compute the time edges corresponding to the binning employed</span>
    <span class="n">t_start_x_dl</span> <span class="o">=</span> <span class="n">t_start_x</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="n">t_start_y_dl</span> <span class="o">=</span> <span class="n">t_start_y</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="n">t_stop_x_dl</span> <span class="o">=</span> <span class="n">t_stop_x</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="n">t_stop_y_dl</span> <span class="o">=</span> <span class="n">t_stop_y</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">binsize</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_start_x_dl</span><span class="p">,</span> <span class="n">t_stop_x_dl</span><span class="p">,</span> <span class="n">N_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">binsize</span><span class="o">.</span><span class="n">units</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_start_y_dl</span><span class="p">,</span> <span class="n">t_stop_y_dl</span><span class="p">,</span> <span class="n">N_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">binsize</span><span class="o">.</span><span class="n">units</span>

    <span class="c1"># Return the intersection matrix and the edges of the bins used for the</span>
    <span class="c1"># x and y axes, respectively.</span>
    <span class="k">return</span> <span class="n">imat</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span></div>


<span class="k">def</span> <span class="nf">_reference_diagonal</span><span class="p">(</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two arrays of time bin edges :math:`x_edges = (X_1, X_2, ..., X_k)`</span>
<span class="sd">    and :math:`y_edges = (Y_1, Y_2, ..., Y_k)`, considers the matrix `M`</span>
<span class="sd">    such that :math:`M_{ij} = (X_i, Y_j)` and finds the reference diagonal of</span>
<span class="sd">    M, i.e. the diagonal of M whose elements are of the type `(a, a)`.</span>
<span class="sd">    Returns the index of such diagonal and its elements.</span>

<span class="sd">    For example, if :math:`x_edges = (0, 1, 2, 3) ms` and :math:`y_edges =</span>
<span class="sd">    (1, 2, 3, 4) ms`, then the index of the reference diagonal is -1</span>
<span class="sd">    (first off-diagonal below the main diagonal) and its elements are</span>
<span class="sd">    (-1, 0), (0, 1), (1, 2), (2, 3).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">diag_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">error_msg</span> <span class="o">=</span> \
        <span class="s1">&#39;the time axes (</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
        <span class="s1">&#39; overlap but the overlapping bin edges are not aligned&#39;</span> \
        <span class="s1">&#39;. Bad alignment of the time axes.&#39;</span>

    <span class="k">if</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">_quantities_almost_equal</span><span class="p">(</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="n">diag_id</span> <span class="o">=</span> <span class="o">-</span> <span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">bin_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_edges</span> <span class="o">==</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="n">diag_id</span> <span class="o">=</span> <span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">diag_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">diag_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">elif</span> <span class="n">diag_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_xrange</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">diag_id</span><span class="p">),</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">diag_id</span><span class="p">,</span> <span class="n">m</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_xrange</span><span class="p">(</span><span class="n">diag_id</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">diag_id</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">diag_id</span><span class="p">,</span> <span class="n">elements</span>


<div class="viewcode-block" id="mask_matrices"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.mask_matrices">[docs]</a><span class="k">def</span> <span class="nf">mask_matrices</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of matrices and a list of thresholds, return a boolean matrix</span>
<span class="sd">    B (&quot;mask&quot;) such that B[i,j] is True if each input matrix in the list</span>
<span class="sd">    strictly exceeds the corresponding threshold at that position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrices : list of numpy.ndarrays</span>
<span class="sd">        the matrices which are compared to the respective thresholds to</span>
<span class="sd">        build the mask. All matrices must have the same shape.</span>
<span class="sd">    thresholds : list of floats</span>
<span class="sd">        list of thresholds</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : numpy.ndarray of bools</span>
<span class="sd">        mask matrix with same shape of the input matrices.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Check that input lists have same length</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`matrices` and `thresholds` must have same length&#39;</span><span class="p">)</span>

    <span class="c1"># Compute mask matrix</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">mat</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>

    <span class="c1"># Replace nans, coming from False * np.inf, with 0s</span>
    <span class="c1"># (trick to find nans in masked: a number is nan if it&#39;s not &gt;= - np.inf)</span>
    <span class="n">mask</span><span class="p">[</span><span class="kc">True</span> <span class="o">-</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_stretched_metric_2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">stretch</span><span class="p">,</span> <span class="n">ref_angle</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of points on the real plane, identified by their absciss x</span>
<span class="sd">    and ordinate y, compute a stretched transformation of the Euclidean</span>
<span class="sd">    distance among each of them.</span>
<span class="sd">    The classical euclidean distance d between points (x1, y1) and (x2, y2),</span>
<span class="sd">    i.e. \sqrt((x1-x2)^2 + (y1-y2)^2), is multiplied by a factor</span>
<span class="sd">    .. math::</span>

<span class="sd">            1 + (stretch - 1.) * \abs(\sin(ref_angle - \theta)),</span>

<span class="sd">    where \\theta is the angle between the points and the 45deg direction</span>
<span class="sd">    (i.e. the line y=x).</span>
<span class="sd">    The stretching factor thus steadily varies between 1 (if the line</span>
<span class="sd">    connecting (x1, y1) and (x2, y2) has inclination ref_angle) and stretch</span>
<span class="sd">    (if that line has inclination 90 + ref_angle).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : numpy.ndarray</span>
<span class="sd">        array of abscissa of all points among which to compute the distance</span>
<span class="sd">    y : numpy.ndarray (same shape as x)</span>
<span class="sd">        array of ordinates of all points among which to compute the distance</span>
<span class="sd">    stretch : float</span>
<span class="sd">        maximum stretching factor, applied if the line connecting the points</span>
<span class="sd">        has inclination 90 + ref_angle</span>
<span class="sd">    ref_angle : float</span>
<span class="sd">        reference angle, i.e. inclination along which the stretching factor</span>
<span class="sd">        is 1.</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    D : numpy.ndarray</span>
<span class="sd">        square matrix of distances between all pairs of points. If x and y</span>
<span class="sd">        have shape (n, ) then D has shape (n, n).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ref_angle</span><span class="p">)</span>  <span class="c1"># reference angle in radians</span>

    <span class="c1"># Create the array of points (one per row) for which to compute the</span>
    <span class="c1"># stretched distance</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Compute the matrix D[i, j] of euclidean distances among points i and j</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

    <span class="c1"># Compute the angular coefficients of the line between each pair of points</span>
    <span class="n">x_array</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
    <span class="n">y_array</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">y</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">x_array</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">x_array</span>  <span class="c1"># dX[i,j]: x difference between points i and j</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">y_array</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">y_array</span>  <span class="c1"># dY[i,j]: y difference between points i and j</span>
    <span class="n">AngCoeff</span> <span class="o">=</span> <span class="n">dY</span> <span class="o">/</span> <span class="n">dX</span>

    <span class="c1"># Compute the matrix Theta of angles between each pair of points</span>
    <span class="n">Theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">AngCoeff</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Theta</span><span class="p">[</span><span class="n">_xrange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set angle to 0 if points identical</span>

    <span class="c1"># Compute the matrix of stretching factors for each pair of points</span>
    <span class="n">stretch_mat</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">stretch</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">Theta</span><span class="p">))))</span>

    <span class="c1"># Return the stretched distance matrix</span>
    <span class="k">return</span> <span class="n">D</span> <span class="o">*</span> <span class="n">stretch_mat</span>


<div class="viewcode-block" id="cluster_matrix_entries"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.cluster_matrix_entries">[docs]</a><span class="k">def</span> <span class="nf">cluster_matrix_entries</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a matrix mat, replaces its positive elements with integers</span>
<span class="sd">    representing different cluster ids. Each cluster comprises close-by</span>
<span class="sd">    elements.</span>

<span class="sd">    In ASSET analysis, mat is a thresholded (&quot;masked&quot;) version of an</span>
<span class="sd">    intersection matrix imat, whose values are those of imat only if</span>
<span class="sd">    considered statistically significant, and zero otherwise.</span>

<span class="sd">    A cluster is built by pooling elements according to their distance,</span>
<span class="sd">    via the DBSCAN algorithm (see sklearn.cluster.dbscan()). Elements form</span>
<span class="sd">    a neighbourhood if at least one of them has a distance not larger than</span>
<span class="sd">    eps from the others, and if they are at least min. Overlapping</span>
<span class="sd">    neighborhoods form a cluster.</span>
<span class="sd">    </span>
<span class="sd">        * Clusters are assigned integers from 1 to the total number k of</span>
<span class="sd">          clusters</span>
<span class="sd">        * Unclustered (&quot;isolated&quot;) positive elements of mat are</span>
<span class="sd">          assigned value -1</span>
<span class="sd">        * Non-positive elements are assigned the value 0.</span>

<span class="sd">    The distance between the positions of two positive elements in mat is</span>
<span class="sd">    given by an Euclidean metric which is stretched if the two positions are</span>
<span class="sd">    not aligned along the 45 degree direction (the main diagonal direction),</span>
<span class="sd">    as more, with maximal stretching along the anti-diagonal. Specifically,</span>
<span class="sd">    the Euclidean distance between positions (i1, j1) and (i2, j2) is</span>
<span class="sd">    stretched by a factor</span>

<span class="sd">    .. math::</span>
<span class="sd">             1 + (\mathtt{stretch} - 1.) *</span>
<span class="sd">             \\left|\\sin((\\pi / 4) - \\theta)\\right|,</span>

<span class="sd">    where :math:`\\theta` is the angle between the pixels and the 45deg</span>
<span class="sd">    direction. The stretching factor thus varies between 1 and stretch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : numpy.ndarray</span>
<span class="sd">        a matrix whose elements with positive values are to be clustered.</span>
<span class="sd">    eps : float &gt;=0, optional</span>
<span class="sd">        the maximum distance for two elements in mat to be part of the same</span>
<span class="sd">        neighbourhood in the DBSCAN algorithm</span>
<span class="sd">        Default: 10</span>
<span class="sd">    min : int, optional</span>
<span class="sd">        the minimum number of elements to form a neighbourhood.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    stretch : float &gt; 1, optional</span>
<span class="sd">        the stretching factor of the euclidean metric for elements aligned</span>
<span class="sd">        along the 135 degree direction (anti-diagonal). The actual stretching</span>
<span class="sd">        increases from 1 to stretch as the direction of the two elements</span>
<span class="sd">        moves from the 45 to the 135 degree direction.</span>
<span class="sd">        Default: 5</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cmat : numpy.ndarray of integers</span>
<span class="sd">        a matrix with the same shape of mat, each of whose elements is either</span>
<span class="sd">            * a positive int (cluster id) if the element is part of a cluster</span>
<span class="sd">            * 0 if the corresponding element in mat was non-positive</span>
<span class="sd">            * -1 if the element does not belong to any cluster</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Don&#39;t do anything if mat is identically zero</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mat</span>

    <span class="c1"># List the significant pixels of mat in a 2-columns array</span>
    <span class="n">xpos_sgnf</span><span class="p">,</span> <span class="n">ypos_sgnf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute the matrix D[i, j] of euclidean distances among pixels i and j</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">_stretched_metric_2d</span><span class="p">(</span>
        <span class="n">xpos_sgnf</span><span class="p">,</span> <span class="n">ypos_sgnf</span><span class="p">,</span> <span class="n">stretch</span><span class="o">=</span><span class="n">stretch</span><span class="p">,</span> <span class="n">ref_angle</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

    <span class="c1"># Cluster positions of significant pixels via dbscan</span>
    <span class="n">core_samples</span><span class="p">,</span> <span class="n">config</span> <span class="o">=</span> <span class="n">dbscan</span><span class="p">(</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">)</span>

    <span class="c1"># Construct the clustered matrix, where each element has value</span>
    <span class="c1"># * i = 1 to k if it belongs to a cluster i,</span>
    <span class="c1"># * 0 if it is not significant,</span>
    <span class="c1"># * -1 if it is significant but does not belong to any cluster</span>
    <span class="n">cluster_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">cluster_mat</span><span class="p">[</span><span class="n">xpos_sgnf</span><span class="p">,</span> <span class="n">ypos_sgnf</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">config</span> <span class="o">*</span> <span class="p">(</span><span class="n">config</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">config</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">config</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cluster_mat</span></div>


<div class="viewcode-block" id="probability_matrix_montecarlo"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.probability_matrix_montecarlo">[docs]</a><span class="k">def</span> <span class="nf">probability_matrix_montecarlo</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t_start_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">surr_method</span><span class="o">=</span><span class="s1">&#39;dither_spike_train&#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_surr</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of parallel spike trains, estimate the cumulative probability</span>
<span class="sd">     of each entry in their intersection matrix (see: intersection_matrix())</span>
<span class="sd">    by a Monte Carlo approach using surrogate data.</span>
<span class="sd">    Contrarily to the analytical version (see: probability_matrix_analytical())</span>
<span class="sd">    the Monte Carlo one does not incorporate the assumptions of Poissonianity</span>
<span class="sd">    in the null hypothesis.</span>

<span class="sd">    The method produces surrogate spike trains (using one of several methods</span>
<span class="sd">    at disposal, see below) and calculates their intersection matrix M.</span>
<span class="sd">    For each entry (i, j), the intersection cdf P[i, j] is then given by:</span>

<span class="sd">    .. centered::  P[i, j] = #(spike_train_surrogates such that M[i, j] &lt; I[i, j]) /</span>
<span class="sd">                        #(spike_train_surrogates)</span>

<span class="sd">    If P[i, j] is large (close to 1), I[i, j] is statistically significant:</span>
<span class="sd">    the probability to observe an overlap equal to or larger then I[i, j]</span>
<span class="sd">    under the null hypothesis is 1-P[i, j], very small.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sts : list of neo.SpikeTrains</span>
<span class="sd">        list of spike trains for which to compute the probability matrix</span>
<span class="sd">    binsize : quantities.Quantity</span>
<span class="sd">        width of the time bins used to compute the probability matrix</span>
<span class="sd">    dt : quantities.Quantity</span>
<span class="sd">        time span for which to consider the given SpikeTrains</span>
<span class="sd">    t_start_x, t_start_y : quantities.Quantity, optional</span>
<span class="sd">        time start of the binning for the first and second axes of the</span>
<span class="sd">        intersection matrix, respectively.</span>
<span class="sd">        If None (default) the attribute t_start of the SpikeTrains is used</span>
<span class="sd">        (if the same for all spike trains).</span>
<span class="sd">        Default: None</span>
<span class="sd">    surr_method : str, optional</span>
<span class="sd">        the method to use to generate surrogate spike trains. Can be one of:</span>

<span class="sd">            * &#39;dither_spike_train&#39;: see spike_train_surrogates.train_shifting() [dt needed]</span>
<span class="sd">            * &#39;spike_dithering&#39;: see spike_train_surrogates.spike_dithering() [dt needed]</span>
<span class="sd">            * &#39;spike_jittering&#39;: see spike_train_surrogates.spike_jittering() [dt needed]</span>
<span class="sd">            * &#39;spike_time_rand&#39;: see spike_train_surrogates.spike_time_rand()</span>
<span class="sd">            * &#39;isi_shuffling&#39;: see spike_train_surrogates.isi_shuffling()</span>

<span class="sd">        Default: &#39;dither_spike_train&#39;</span>
<span class="sd">    j : quantities.Quantity, optional</span>
<span class="sd">        For methods shifting spike times randomly around their original time</span>
<span class="sd">        (spike dithering, train shifting) or replacing them randomly within a</span>
<span class="sd">        certain window (spike jittering), j represents the size of that</span>
<span class="sd">        shift / window. For other methods, j is ignored.</span>
<span class="sd">        Default: None</span>
<span class="sd">    n_surr : int, optional</span>
<span class="sd">        number of spike_train_surrogates to generate for the bootstrap</span>
<span class="sd">        procedure. Default: 100</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pmat : ndarray</span>
<span class="sd">        the cumulative probability matrix. pmat[i, j] represents the</span>
<span class="sd">        estimated probability of having an overlap between bins i and j</span>
<span class="sd">        STRICTLY LOWER than the observed overlap, under the null hypothesis</span>
<span class="sd">        of independence of the input spike trains.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    probability_matrix_analytical() for analytical derivation of the matrix</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Compute the intersection matrix of the original data</span>
    <span class="n">imat</span><span class="p">,</span> <span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span> <span class="o">=</span> <span class="n">intersection_matrix</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_start_x</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span>
        <span class="n">t_start_y</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">)</span>

    <span class="c1"># Generate surrogate spike trains as a list surrs; for each spike train</span>
    <span class="c1"># i, surrs[i] is a list of length n_surr, containing the</span>
    <span class="c1"># spike_train_surrogates of i</span>
    <span class="n">surrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">spike_train_surrogates</span><span class="o">.</span><span class="n">surrogates</span><span class="p">(</span>
        <span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n_surr</span><span class="p">,</span> <span class="n">surr_method</span><span class="o">=</span><span class="n">surr_method</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">spiketrains</span><span class="p">]</span>

    <span class="c1"># Compute the p-value matrix pmat; pmat[i, j] counts the fraction of</span>
    <span class="c1"># surrogate data whose intersection value at (i, j) whose lower than or</span>
    <span class="c1"># equal to that of the original data</span>
    <span class="n">pmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">imat</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pmat_bootstrap(): begin of bootstrap...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">n_surr</span><span class="p">):</span>                      <span class="c1"># For each surrogate id i</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    surr </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">surrs_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">surrs</span><span class="p">]</span>         <span class="c1"># Take each i-th surrogate</span>
        <span class="n">imat_surr</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">intersection_matrix</span><span class="p">(</span>  <span class="c1"># compute the related imat</span>
            <span class="n">surrs_i</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
            <span class="n">t_start_x</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_start_y</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">)</span>
        <span class="n">pmat</span> <span class="o">+=</span> <span class="p">(</span><span class="n">imat_surr</span> <span class="o">&lt;=</span> <span class="n">imat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pmat</span> <span class="o">=</span> <span class="n">pmat</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_surr</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pmat_bootstrap(): done&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pmat</span><span class="p">,</span> <span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span></div>


<div class="viewcode-block" id="probability_matrix_analytical"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.probability_matrix_analytical">[docs]</a><span class="k">def</span> <span class="nf">probability_matrix_analytical</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t_start_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fir_rates</span><span class="o">=</span><span class="s1">&#39;estimate&#39;</span><span class="p">,</span> <span class="n">kernel_width</span><span class="o">=</span><span class="mi">100</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of spike trains, approximates the cumulative probability of</span>
<span class="sd">    each entry in their intersection matrix (see: intersection_matrix()).</span>

<span class="sd">    The approximation is analytical and works under the assumptions that the</span>
<span class="sd">    input spike trains are independent and Poisson. It works as follows:</span>
<span class="sd">    </span>
<span class="sd">        * Bin each spike train at the specified binsize: this yields a binary</span>
<span class="sd">          array of 1s (spike in bin) and 0s (no spike in bin) (clipping used)</span>
<span class="sd">        * If required, estimate the rate profile of each spike train by </span>
<span class="sd">          convolving the binned array with a boxcar kernel of user-defined </span>
<span class="sd">          length</span>
<span class="sd">        * For each neuron k and each pair of bins i and j, compute the</span>
<span class="sd">          probability p_ijk that neuron k fired in both bins i and j.</span>
<span class="sd">        * Approximate the probability distribution of the intersection value</span>
<span class="sd">          at (i, j) by a Poisson distribution with mean parameter</span>
<span class="sd">          l = \sum_k (p_ijk),</span>
<span class="sd">          justified by Le Cam&#39;s approximation of a sum of independent </span>
<span class="sd">          Bernouilli random variables with a Poisson distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spiketrains : list of neo.SpikeTrains</span>
<span class="sd">        list of spike trains for whose intersection matrix to compute the</span>
<span class="sd">        p-values</span>
<span class="sd">    binsize : quantities.Quantity</span>
<span class="sd">        width of the time bins used to compute the probability matrix</span>
<span class="sd">    dt : quantities.Quantity</span>
<span class="sd">        time span for which to consider the given SpikeTrains</span>
<span class="sd">    t_start_x, t_start_y : quantities.Quantity, optional</span>
<span class="sd">        time start of the binning for the first and second axes of the</span>
<span class="sd">        intersection matrix, respectively.</span>
<span class="sd">        If None (default) the attribute t_start of the SpikeTrains is used</span>
<span class="sd">        (if the same for all spike trains).</span>
<span class="sd">        Default: None</span>
<span class="sd">    fir_rates: list of neo.AnalogSignals or &#39;estimate&#39;, optional</span>
<span class="sd">        if a list, fir_rate[i] is the firing rate of the spike train</span>
<span class="sd">        spiketrains[i]. If &#39;estimate&#39;, firing rates are estimated by simple</span>
<span class="sd">        boxcar kernel convolution, with specified kernel width (see below)</span>
<span class="sd">        Default: &#39;estimate&#39;</span>
<span class="sd">    kernel_width : quantities.Quantity, optional</span>
<span class="sd">        total width of the kernel used to estimate the rate profiles when</span>
<span class="sd">        fir_rates=&#39;estimate&#39;.</span>
<span class="sd">        Default: 100 * pq.ms</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        whether to print messages during the computation.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pmat : numpy.ndarray</span>
<span class="sd">        the cumulative probability matrix. pmat[i, j] represents the</span>
<span class="sd">        estimated probability of having an overlap between bins i and j</span>
<span class="sd">        STRICTLY LOWER THAN the observed overlap, under the null hypothesis</span>
<span class="sd">        of independence of the input spike trains.</span>
<span class="sd">    x_edges : numpy.ndarray</span>
<span class="sd">        edges of the bins used for the horizontal axis of pmat. If pmat is</span>
<span class="sd">        a matrix of shape (n, n), x_edges has length n+1</span>
<span class="sd">    y_edges : numpy.ndarray</span>
<span class="sd">        edges of the bins used for the vertical axis of pmat. If pmat is</span>
<span class="sd">        a matrix of shape (n, n), y_edges has length n+1</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Bin the spike trains</span>
    <span class="n">t_stop_x</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start_x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">t_start_x</span> <span class="o">+</span> <span class="n">dt</span>
    <span class="n">t_stop_y</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">t_start_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">t_start_y</span> <span class="o">+</span> <span class="n">dt</span>
    <span class="n">bsts_x</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_x</span><span class="p">)</span>
    <span class="n">bsts_y</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_y</span><span class="p">)</span>

    <span class="n">bsts_x_matrix</span> <span class="o">=</span> <span class="n">bsts_x</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">()</span>
    <span class="n">bsts_y_matrix</span> <span class="o">=</span> <span class="n">bsts_y</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">()</span>

    <span class="c1"># Check that the duration and nr. neurons is identical between the two axes</span>
    <span class="k">if</span> <span class="n">bsts_x_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">bsts_y_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Different spike train durations along the x and y axis!&#39;</span><span class="p">)</span>

    <span class="c1"># Define the firing rate profiles</span>

    <span class="c1"># If rates are to be estimated, create the rate profiles as Quantity</span>
    <span class="c1"># objects obtained by boxcar-kernel convolution</span>
    <span class="k">if</span> <span class="n">fir_rates</span> <span class="o">==</span> <span class="s1">&#39;estimate&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;compute rates by boxcar-kernel convolution...&#39;</span><span class="p">)</span>

        <span class="c1"># Create the boxcar kernel and convolve it with the binned spike trains</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernel_width</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">))</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">k</span>
        <span class="n">fir_rate_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">bst</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">bst</span> <span class="ow">in</span> <span class="n">bsts_x_matrix</span><span class="p">])</span>
        <span class="n">fir_rate_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">bst</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">bst</span> <span class="ow">in</span> <span class="n">bsts_y_matrix</span><span class="p">])</span>

        <span class="c1"># The convolution results in an array decreasing at the borders due</span>
        <span class="c1"># to absence of spikes beyond the borders. Replace the first and last</span>
        <span class="c1"># (k//2) elements with the (k//2)-th / (n-k//2)-th ones, respectively</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">fir_rate_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">fir_rate_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fir_rate_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>
            <span class="n">fir_rate_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">k2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fir_rate_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">k2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">fir_rate_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fir_rate_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>
            <span class="n">fir_rate_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">k2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fir_rate_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">k2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Multiply the firing rates by the proper unit</span>
        <span class="n">fir_rate_x</span> <span class="o">=</span> <span class="n">fir_rate_x</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
        <span class="n">fir_rate_y</span> <span class="o">=</span> <span class="n">fir_rate_y</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>

    <span class="c1"># If rates provided as lists of AnalogSignals, create time slices for both</span>
    <span class="c1"># axes, interpolate in the time bins of interest and convert to Quantity</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fir_rates</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Reshape all rates to one-dimensional array object (e.g. AnalogSignal)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fir_rates</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fir_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;elements in fir_rates have too many dimensions&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;create time slices of the rates...&#39;</span><span class="p">)</span>

        <span class="c1"># Define the rate by time slices</span>
        <span class="n">fir_rate_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">_time_slice</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">bsts_x</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">bsts_x</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">fir_rates</span><span class="p">]</span>
        <span class="n">fir_rate_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">_time_slice</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">bsts_y</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">bsts_y</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">fir_rates</span><span class="p">]</span>
        <span class="c1"># Interpolate in the time bins and convert to Quantities</span>
        <span class="n">times_x</span> <span class="o">=</span> <span class="n">bsts_x</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">times_y</span> <span class="o">=</span> <span class="n">bsts_y</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fir_rate_x</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">Hz</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">_analog_signal_step_interp</span><span class="p">(</span>
            <span class="n">signal</span><span class="p">,</span> <span class="n">times_x</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">fir_rates</span><span class="p">])</span>
        <span class="n">fir_rate_y</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">Hz</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">_analog_signal_step_interp</span><span class="p">(</span>
            <span class="n">signal</span><span class="p">,</span> <span class="n">times_y</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">fir_rates</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fir_rates must be a list or the string &quot;estimate&quot;&#39;</span><span class="p">)</span>

    <span class="c1"># For each neuron, compute the prob. that that neuron spikes in any bin</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;compute the prob. that each neuron fires in each pair of bins...&#39;</span><span class="p">)</span>

    <span class="n">spike_probs_x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span> <span class="k">for</span> <span class="n">rate</span> <span class="ow">in</span> <span class="n">fir_rate_x</span><span class="p">]</span>
    <span class="n">spike_probs_y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span> <span class="k">for</span> <span class="n">rate</span> <span class="ow">in</span> <span class="n">fir_rate_y</span><span class="p">]</span>

    <span class="c1"># For each neuron k compute the matrix of probabilities p_ijk that neuron</span>
    <span class="c1"># k spikes in both bins i and j. (For i = j it&#39;s just spike_probs[k][i])</span>
    <span class="n">spike_prob_mats</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">probx</span><span class="p">,</span> <span class="n">proby</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">probx</span><span class="p">,</span> <span class="n">proby</span><span class="p">)</span> <span class="ow">in</span>
                       <span class="nb">zip</span><span class="p">(</span><span class="n">spike_probs_x</span><span class="p">,</span> <span class="n">spike_probs_y</span><span class="p">)]</span>

    <span class="c1"># Compute the matrix Mu[i, j] of parameters for the Poisson distributions</span>
    <span class="c1"># which describe, at each (i, j), the approximated overlap probability.</span>
    <span class="c1"># This matrix is just the sum of the probability matrices computed above</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compute the probability matrix by Le Cam&#39;s approximation...&quot;</span><span class="p">)</span>

    <span class="n">Mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spike_prob_mats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute the probability matrix obtained from imat using the Poisson pdfs</span>
    <span class="n">imat</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">intersection_matrix</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_start_x</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span>
        <span class="n">t_start_y</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">)</span>

    <span class="n">pmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">imat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">imat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">imat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">pmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">imat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Mu</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <span class="c1"># Substitute 0.5 to the elements along the main diagonal</span>
    <span class="n">diag_id</span><span class="p">,</span> <span class="n">elems</span> <span class="o">=</span> <span class="n">_reference_diagonal</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diag_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;substitute 0.5 to elements along the main diagonal...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
            <span class="n">pmat</span><span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="k">return</span> <span class="n">pmat</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span></div>


<span class="k">def</span> <span class="nf">_jsf_uniform_orderstat_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Considered n independent random variables X1, X2, ..., Xn all having</span>
<span class="sd">    uniform distribution in the interval (alpha, 1):</span>
<span class="sd">    </span>
<span class="sd">    .. centered::  Xi ~ Uniform(alpha, 1),</span>
<span class="sd">    </span>
<span class="sd">    with alpha \in [0, 1), and given a 3D matrix U = (u_ijk) where each U_ij</span>
<span class="sd">    is an array of length d: U_ij = [u0, u1, ..., u_{d-1}] of</span>
<span class="sd">    quantiles, with u1 &lt;= u2 &lt;= ... &lt;= un, computes the joint survival function</span>
<span class="sd">    (jsf) of the d highest order statistics (U_{n-d+1}, U_{n-d+2}, ..., U_n),</span>
<span class="sd">    where U_i := &quot;i-th highest X&#39;s&quot; at each u_ij, i.e.:</span>
<span class="sd">    </span>
<span class="sd">    .. centered::  jsf(u_ij) = Prob(U_{n-k} &gt;= u_ijk, k=0,1,..., d-1).</span>
<span class="sd">    </span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    u : numpy.ndarray of shape (A, B, d)</span>
<span class="sd">        3D matrix of floats between 0 and 1.</span>
<span class="sd">        Each vertical column u_ij is an array of length d, considered a set of</span>
<span class="sd">        `d` largest order statistics extracted from a sample of `n` random</span>
<span class="sd">        variables whose cdf is F(x)=x for each x.</span>
<span class="sd">        The routine computes the joint cumulative probability of the `d`</span>
<span class="sd">        values in u_ij, for each i and j.</span>
<span class="sd">    alpha : float in [0, 1)</span>
<span class="sd">        range where the values of `u` are assumed to vary.</span>
<span class="sd">        alpha is 0 in the standard ASSET analysis.</span>
<span class="sd">    n : int</span>
<span class="sd">        size of the sample where the d largest order statistics u_ij are</span>
<span class="sd">        assumed to have been sampled from</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : numpy.ndarray of shape (A, B)</span>
<span class="sd">        matrix of joint survival probabilities. s_ij is the joint survival</span>
<span class="sd">        probability of the values {u_ijk, k=0,...,d-1}.</span>
<span class="sd">        Note: the joint probability matrix computed for the ASSET analysis</span>
<span class="sd">        is 1-S.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Define ranges [1,...,n], [2,...,n], ..., [d,...,n] for the mute variables</span>
    <span class="c1"># used to compute the integral as a sum over several possibilities</span>
    <span class="n">lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">_xrange</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Compute the log of the integral&#39;s coefficient</span>
    <span class="n">logK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="c1"># Add to the 3D matrix u a bottom layer identically equal to alpha and a</span>
    <span class="c1"># top layer identically equal to 1. Then compute the difference dU along</span>
    <span class="c1"># the first dimension.</span>
    <span class="n">u_extended</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">d</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
    <span class="n">u_extended</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_extended</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span>
    <span class="k">for</span> <span class="n">layer_idx</span><span class="p">,</span> <span class="n">uu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="n">u_extended</span><span class="p">[</span><span class="n">layer_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">layer_idx</span><span class="p">]</span>
    <span class="n">dU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u_extended</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shape (d+1, A, B)</span>
    <span class="k">del</span> <span class="n">u_extended</span>

    <span class="c1"># Compute the probabilities at each (a, b), a=0,...,A-1, b=0,...,B-1</span>
    <span class="c1"># by matrix algebra, working along the third dimension (axis 0)</span>
    <span class="n">Ptot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>  <span class="c1"># initialize all A x B probabilities to 0</span>
    <span class="n">iter_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">):</span>
        <span class="n">iter_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">di</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">di</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">dI</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>  <span class="c1"># shape (d+1, A, B)</span>

            <span class="c1"># for each a=0,1,...,A-1 and b=0,1,...,B-1, replace dU_abk with 1</span>
            <span class="c1"># whenever dI_abk = 0, so that dU_abk ** dI_abk = 1 (this avoids</span>
            <span class="c1"># nans when both dU_abk and dI_abk are 0, and is mathematically</span>
            <span class="c1"># correct). dU2 still contains 0s, so that when below exp(log(U2))</span>
            <span class="c1"># is computed, warnings are arosen; they are no problem though.</span>
            <span class="n">dU2</span> <span class="o">=</span> <span class="n">dU</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dU2</span><span class="p">[</span><span class="n">dI</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Compute for each i=0,...,A-1 and j=0,...,B-1: log(I_ij !)</span>
            <span class="c1"># Creates a matrix log_dIfactorial of shape (A, B)</span>
            <span class="n">log_di_factorial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                       <span class="k">for</span> <span class="n">di_k</span> <span class="ow">in</span> <span class="n">di</span> <span class="k">if</span> <span class="n">di_k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Compute for each i,j the contribution to the total</span>
            <span class="c1"># probability given by this step, and add it to the total prob.</span>
            <span class="n">logP</span> <span class="o">=</span> <span class="p">(</span><span class="n">dI</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dU2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_di_factorial</span>
            <span class="n">Ptot</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logP</span> <span class="o">+</span> <span class="n">logK</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ptot</span>


<span class="k">def</span> <span class="nf">_pmat_neighbors</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">filter_shape</span><span class="p">,</span> <span class="n">nr_largest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Build the 3D matrix L of largest neighbors of elements in a 2D matrix mat.</span>

<span class="sd">    For each entry mat[i, j], collects the nr_largest elements with largest</span>
<span class="sd">    values around mat[i,j], say z_i, i=1,2,...,nr_largest, and assigns them</span>
<span class="sd">    to L[i, j, :].</span>
<span class="sd">    The zone around mat[i, j] where largest neighbors are collected from is</span>
<span class="sd">    a rectangular area (kernel) of shape (l, w) = filter_shape centered around</span>
<span class="sd">    mat[i, j] and aligned along the diagonal where mat[i, j] lies into</span>
<span class="sd">    (if diag=0, default) or along the anti-diagonal (is diag = 1)</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    mat : ndarray</span>
<span class="sd">        a square matrix of real-valued elements</span>

<span class="sd">    filter_shape : tuple</span>
<span class="sd">        a pair (l, w) of integers representing the kernel shape</span>

<span class="sd">    nr_largest : int, optional</span>
<span class="sd">        the number of largest neighbors to collect for each entry in mat</span>
<span class="sd">        If None (default) the filter length l is used</span>
<span class="sd">        Default: 0</span>

<span class="sd">    diag : int, optional</span>
<span class="sd">        which diagonal of mat[i, j] to align the kernel to in order to</span>
<span class="sd">        find its largest neighbors.</span>
<span class="sd">        * 0: main diagonal</span>
<span class="sd">        * 1: anti-diagonal</span>
<span class="sd">        Default: 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : ndarray</span>
<span class="sd">        a matrix of shape (nr_largest, l, w) containing along the first</span>
<span class="sd">        dimension lmat[:, i, j] the largest neighbors of mat[i, j]</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">filter_shape</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">l</span> <span class="k">if</span> <span class="n">nr_largest</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nr_largest</span>

    <span class="c1"># Check consistent arguments</span>
    <span class="k">assert</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;mat must be a square matrix&#39;</span>
    <span class="k">assert</span> <span class="n">diag</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">diag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> \
        <span class="s1">&#39;diag must be 0 (45 degree filtering) or 1 (135 degree filtering)&#39;</span>
    <span class="k">assert</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">,</span> <span class="s1">&#39;w must be lower than l&#39;</span>

    <span class="c1"># Construct the kernel</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="p">)</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">diag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

    <span class="c1"># Convert mat values to floats, and replaces np.infs with specified input</span>
    <span class="c1"># values</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">mat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Initialize the matrix of d-largest values as a matrix of zeroes</span>
    <span class="n">lmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># TODO: make this on a 3D matrix to parallelize...</span>
    <span class="n">N_bin</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_bin</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute fmat</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># try by stacking the different patches of each row of mat</span>
        <span class="n">flattened_filt</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bin_range</span><span class="p">:</span>
            <span class="c1"># creates a 2D matrix of shape (N_bin-l+1, l**2), where each row</span>
            <span class="c1"># is a flattened patch (length l**2) from the y-th row of mat</span>
            <span class="n">row_patches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_range</span><span class="p">),</span> <span class="n">l</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_range</span><span class="p">:</span>
                <span class="n">row_patches</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">l</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="c1"># take the l largest values in each row (patch) and assign them</span>
            <span class="c1"># to the corresponding row in lmat</span>
            <span class="n">largest_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">row_patches</span> <span class="o">*</span> <span class="n">flattened_filt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="o">-</span><span class="n">d</span><span class="p">:]</span>
            <span class="n">lmat</span><span class="p">[:,</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="p">(</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span> <span class="p">(</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">N_bin</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest_vals</span><span class="o">.</span><span class="n">T</span>

    <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>  <span class="c1"># if too large, do it serially by for loops</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bin_range</span><span class="p">:</span>  <span class="c1"># one step to the right;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_range</span><span class="p">:</span>  <span class="c1"># one step down</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span>
                <span class="n">mskd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">patch</span><span class="p">)</span>
                <span class="n">largest_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mskd</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[</span><span class="o">-</span><span class="n">d</span><span class="p">:]</span>
                <span class="n">lmat</span><span class="p">[:,</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">largest_vals</span>

    <span class="k">return</span> <span class="n">lmat</span>


<div class="viewcode-block" id="joint_probability_matrix"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.joint_probability_matrix">[docs]</a><span class="k">def</span> <span class="nf">joint_probability_matrix</span><span class="p">(</span>
        <span class="n">pmat</span><span class="p">,</span> <span class="n">filter_shape</span><span class="p">,</span> <span class="n">nr_largest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pvmin</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Map a probability matrix pmat to a joint probability matrix jmat, where</span>
<span class="sd">    jmat[i, j] is the joint p-value of the largest neighbors of pmat[i, j].</span>

<span class="sd">    The values of pmat are assumed to be uniformly distributed in the range</span>
<span class="sd">    [alpha, 1] (alpha=0 by default). Centered a rectangular kernel of shape</span>
<span class="sd">    filter_shape=(l, w) around each entry pmat[i, j], aligned along the</span>
<span class="sd">    diagonal where pmat[i, j] lies into, extracts the nr_largest highest values</span>
<span class="sd">    falling within the kernel and computes their joint p-value jmat[i, j]</span>
<span class="sd">    (see [1]).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pmat : ndarray</span>
<span class="sd">        a square matrix of cumulative probability values between alpha and 1.</span>
<span class="sd">        The values are assumed to be uniformly distibuted in the said range</span>
<span class="sd">    filter_shape : tuple</span>
<span class="sd">        a pair (l, w) of integers representing the kernel shape. The</span>
<span class="sd">    nr_largest : int, optional</span>
<span class="sd">        the number of largest neighbors to collect for each entry in mat</span>
<span class="sd">        If None (default) the filter length l is used</span>
<span class="sd">        Default: 0</span>
<span class="sd">    alpha : float in [0, 1), optional</span>
<span class="sd">        the left end of the range [alpha, 1]</span>
<span class="sd">        Default: 0</span>
<span class="sd">    pvmin : flaot in [0, 1), optional</span>
<span class="sd">        minimum p-value for individual entries in pmat. Each pmat[i, j] is</span>
<span class="sd">        set to min(pmat[i, j], 1-pvmin) to avoid that a single highly</span>
<span class="sd">        significant value in pmat (extreme case: pmat[i, j] = 1) yield</span>
<span class="sd">        joint significance of itself and its neighbors.</span>
<span class="sd">        Default: 1e-5</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jmat : numpy.ndarray</span>
<span class="sd">        joint probability matrix associated to pmat</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Torre et al (in prep) ...</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    # Assuming to have a list sts of parallel spike trains over 1s recording,</span>
<span class="sd">    # the following code computes the intersection/probability/joint-prob</span>
<span class="sd">    # matrices imat/pmat/jmat using a bin width of 5 ms</span>
<span class="sd">    &gt;&gt;&gt; T = 1 * pq.s</span>
<span class="sd">    &gt;&gt;&gt; binsize = 5 * pq.ms</span>
<span class="sd">    &gt;&gt;&gt; imat, xedges, yedges = intersection_matrix(sts, binsize=binsize, dt=T)</span>
<span class="sd">    &gt;&gt;&gt; pmat = probability_matrix_analytical(sts, binsize, dt=T)</span>
<span class="sd">    &gt;&gt;&gt; jmat = joint_probability_matrix(pmat, filter_shape=(fl, fw))</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Find for each P_ij in the probability matrix its neighbors and maximize</span>
    <span class="c1"># them by the maximum value 1-pvmin</span>
    <span class="n">pmat_neighb</span> <span class="o">=</span> <span class="n">_pmat_neighbors</span><span class="p">(</span>
        <span class="n">pmat</span><span class="p">,</span> <span class="n">filter_shape</span><span class="o">=</span><span class="n">filter_shape</span><span class="p">,</span> <span class="n">nr_largest</span><span class="o">=</span><span class="n">nr_largest</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pmat_neighb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pmat_neighb</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">pvmin</span><span class="p">)</span>

    <span class="c1"># Compute the joint p-value matrix jpvmat</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">filter_shape</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># number of entries covered by kernel</span>
    <span class="n">jpvmat</span> <span class="o">=</span> <span class="n">_jsf_uniform_orderstat_3d</span><span class="p">(</span><span class="n">pmat_neighb</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">jpvmat</span></div>


<div class="viewcode-block" id="extract_sse"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.extract_sse">[docs]</a><span class="k">def</span> <span class="nf">extract_sse</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">,</span> <span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">,</span> <span class="n">cmat</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of spike trains, two arrays of bin edges and a clustered</span>
<span class="sd">    intersection matrix obtained from those spike trains via worms analysis</span>
<span class="sd">    using the specified edges, extracts the sequences of synchronous events</span>
<span class="sd">    (SSEs) corresponding to clustered elements in the cluster matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spiketrains : list of neo.SpikeTrain</span>
<span class="sd">        the spike trains analyzed for repeated sequences of synchronous</span>
<span class="sd">        events.</span>
<span class="sd">    x_edges : quantities.Quantity</span>
<span class="sd">        the first array of time bins used to compute cmat</span>
<span class="sd">    y_edges : quantities.Quantity</span>
<span class="sd">        the second array of time bins used to compute cmat. Musr have the</span>
<span class="sd">        same length as x_array</span>
<span class="sd">    cmat: numpy.ndarray</span>
<span class="sd">        matrix of shape (n, n), where n is the length of x_edges and</span>
<span class="sd">        y_edges, representing the cluster matrix in worms analysis</span>
<span class="sd">        (see: cluster_matrix_entries())</span>
<span class="sd">    ids : list or None, optional</span>
<span class="sd">        a list of spike train IDs. If provided, ids[i] is the identity</span>
<span class="sd">        of spiketrains[i]. If None, the IDs 0,1,...,n-1 are used</span>
<span class="sd">        Default: None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sse : dict</span>
<span class="sd">        a dictionary D of SSEs, where each SSE is a sub-dictionary Dk,</span>
<span class="sd">        k=1,...,K, where K is the max positive integer in cmat (the</span>
<span class="sd">        total number of clusters in cmat):</span>

<span class="sd">        .. centered:: D = {1: D1, 2: D2, ..., K: DK}</span>

<span class="sd">        Each sub-dictionary Dk represents the k-th diagonal structure</span>
<span class="sd">        (i.e. the k-th cluster) in cmat, and is of the form</span>

<span class="sd">        .. centered:: Dk = {(i1, j1): S1, (i2, j2): S2, ..., (iL, jL): SL}.</span>

<span class="sd">        The keys (i, j) represent the positions (time bin ids) of all</span>
<span class="sd">        elements in cmat that compose the SSE, i.e. that take value l (and</span>
<span class="sd">        therefore belong to the same cluster), and the values Sk are sets of</span>
<span class="sd">        neuron ids representing a repeated synchronous event (i.e. spiking</span>
<span class="sd">        at time bins i and j).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">nr_worms</span> <span class="o">=</span> <span class="n">cmat</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># number of different clusters (&quot;worms&quot;) in cmat</span>
    <span class="k">if</span> <span class="n">nr_worms</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="c1"># Compute the transactions associated to the two binnings</span>
    <span class="n">binsize_x</span> <span class="o">=</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop_x</span> <span class="o">=</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tracts_x</span> <span class="o">=</span> <span class="n">_transactions</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize_x</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_x</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_x</span><span class="p">,</span>
        <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">binsize_y</span> <span class="o">=</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop_y</span> <span class="o">=</span> <span class="n">y_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tracts_y</span> <span class="o">=</span> <span class="n">_transactions</span><span class="p">(</span>
        <span class="n">spiketrains</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize_y</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start_y</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop_y</span><span class="p">,</span>
        <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">)</span>

    <span class="c1"># Find the reference diagonal, whose elements correspond to same time bins</span>
    <span class="n">diag_id</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_reference_diagonal</span><span class="p">(</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">)</span>

    <span class="c1"># Reconstruct each worm, link by link</span>
    <span class="n">sse_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr_worms</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># for each worm</span>
        <span class="n">worm_k</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># worm k is a list of links (each link will be 1 sublist)</span>
        <span class="n">pos_worm_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cmat</span> <span class="o">==</span> <span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># position of all links</span>
        <span class="c1"># if no link lies on the reference diagonal</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">diag_id</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pos_worm_k</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">bin_x</span><span class="p">,</span> <span class="n">bin_y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos_worm_k</span><span class="p">):</span>  <span class="c1"># for each link</span>
                <span class="n">link_l</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tracts_x</span><span class="p">[</span><span class="n">bin_x</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">tracts_y</span><span class="p">[</span><span class="n">bin_y</span><span class="p">])</span>  <span class="c1"># reconstruct the link</span>
                <span class="n">worm_k</span><span class="p">[(</span><span class="n">bin_x</span><span class="p">,</span> <span class="n">bin_y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">link_l</span>  <span class="c1"># and assign it to its pixel</span>
            <span class="n">sse_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">worm_k</span>

    <span class="k">return</span> <span class="n">sse_dict</span></div>


<div class="viewcode-block" id="sse_intersection"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_intersection">[docs]</a><span class="k">def</span> <span class="nf">sse_intersection</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">,</span> <span class="n">intersection</span><span class="o">=</span><span class="s1">&#39;linkwise&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) `sse1` and `sse2`, each</span>
<span class="sd">    consisting of a pool of positions (iK, jK) of matrix entries and</span>
<span class="sd">    associated synchronous events SK, finds the intersection among them.</span>
<span class="sd">    The intersection can be performed &#39;pixelwise&#39; or &#39;linkwise&#39;.</span>
<span class="sd">        </span>
<span class="sd">        * if &#39;pixelwise&#39;, it yields a new SSE which retains only events in sse1</span>
<span class="sd">          whose pixel position matches a pixel position in sse2. This operation</span>
<span class="sd">          is not symmetric: intersection(sse1, sse2) != intersection(sse2, sse1).</span>
<span class="sd">        * if &#39;linkwise&#39;, an additional step is performed where each retained</span>
<span class="sd">          synchronous event SK in sse1 is intersected with the corresponding</span>
<span class="sd">          event in sse2. This yields a symmetric operation:</span>
<span class="sd">          intersection(sse1, sse2) = intersection(sse2, sse1).</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">    </span>
<span class="sd">    .. centered:: {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    </span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        each is a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>
<span class="sd">    intersection : str, optional</span>
<span class="sd">        the type of intersection to perform among the two SSEs. Either</span>
<span class="sd">        &#39;pixelwise&#39; or &#39;linkwise&#39; (see above).</span>
<span class="sd">        Default: &#39;linkwise&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sse : dict</span>
<span class="sd">        a new SSE (same structure as sse1 and sse2) which retains only the</span>
<span class="sd">        events of sse1 associated to keys present both in sse1 and sse2.</span>
<span class="sd">        If intersection = &#39;linkwise&#39;, such events are additionally</span>
<span class="sd">        intersected with the associated events in sse2 (see above).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sse_new</span> <span class="o">=</span> <span class="n">sse1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pixel1</span> <span class="ow">in</span> <span class="n">sse1</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">pixel1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sse2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">intersection</span> <span class="o">==</span> <span class="s1">&#39;linkwise&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pixel1</span><span class="p">,</span> <span class="n">link1</span> <span class="ow">in</span> <span class="n">sse_new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">sse2</span><span class="p">[</span><span class="n">pixel1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">intersection</span> <span class="o">==</span> <span class="s1">&#39;pixelwise&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;intersection (=</span><span class="si">%s</span><span class="s2">) can only be&quot;</span> <span class="o">%</span> <span class="n">intersection</span> <span class="o">+</span>
            <span class="s2">&quot; &#39;pixelwise&#39; or &#39;linkwise&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sse_new</span></div>


<div class="viewcode-block" id="sse_difference"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_difference">[docs]</a><span class="k">def</span> <span class="nf">sse_difference</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">,</span> <span class="n">difference</span><span class="o">=</span><span class="s1">&#39;linkwise&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), computes the difference between sse1 and sse2.</span>
<span class="sd">    The difference can be performed &#39;pixelwise&#39; or &#39;linkwise&#39;:</span>

<span class="sd">        * if &#39;pixelwise&#39;, it yields a new SSE which contains all (and only) the</span>
<span class="sd">          events in sse1 whose pixel position doesn&#39;t match any pixel in sse2.</span>
<span class="sd">        * if &#39;linkwise&#39;, for each pixel (i, j) in sse1 and corresponding</span>
<span class="sd">          synchronous event S1, if (i, j) is a pixel in sse2 corresponding to the</span>
<span class="sd">          event S2, it retains the set difference S1 - S2. If (i, j) is not a</span>
<span class="sd">          pixel in sse2, it retains the full set S1.</span>

<span class="sd">    Note that in either case the difference is a non-symmetric operation:</span>
<span class="sd">    intersection(sse1, sse2) != intersection(sse2, sse1).</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>

<span class="sd">    .. centered:: {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>

<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    difference : str, optional</span>
<span class="sd">        the type of difference to perform between sse1 and sse2. Either</span>
<span class="sd">        &#39;pixelwise&#39; or &#39;linkwise&#39; (see above).</span>
<span class="sd">        Default: &#39;linkwise&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sse : dict</span>
<span class="sd">        a new SSE (same structure as sse1 and sse2) which retains the</span>
<span class="sd">        difference between sse1 and sse2 (see above).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sse_new</span> <span class="o">=</span> <span class="n">sse1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pixel1</span> <span class="ow">in</span> <span class="n">sse1</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">pixel1</span> <span class="ow">in</span> <span class="n">sse2</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">difference</span> <span class="o">==</span> <span class="s1">&#39;pixelwise&#39;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">difference</span> <span class="o">==</span> <span class="s1">&#39;linkwise&#39;</span><span class="p">:</span>
                <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">sse2</span><span class="p">[</span><span class="n">pixel1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;difference (=</span><span class="si">%s</span><span class="s2">) can only be&quot;</span> <span class="o">%</span> <span class="n">difference</span> <span class="o">+</span>
                    <span class="s2">&quot; &#39;pixelwise&#39; or &#39;linkwise&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sse_new</span></div>


<span class="k">def</span> <span class="nf">_remove_empty_events</span><span class="p">(</span><span class="n">sse</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a sequence of synchronous events (SSE) sse consisting of a pool of</span>
<span class="sd">    pixel positions and associated synchronous events (see below), returns a</span>
<span class="sd">    copy of sse where all empty events have been removed.</span>

<span class="sd">    sse must be provided as a dictionary of type</span>
<span class="sd">    </span>
<span class="sd">    .. centered:: {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    </span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse : dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sse_new : dict</span>
<span class="sd">        a copy of sse where all empty events have been removed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sse_new</span> <span class="o">=</span> <span class="n">sse</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pixel</span><span class="p">,</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">sse</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">link</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">del</span> <span class="n">sse_new</span><span class="p">[</span><span class="n">pixel</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sse_new</span>


<div class="viewcode-block" id="sse_isequal"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_isequal">[docs]</a><span class="k">def</span> <span class="nf">sse_isequal</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), determines whether sse1 is strictly contained in sse2.</span>
<span class="sd">    sse1 is strictly contained in sse2 if all its pixels are pixels of sse2,</span>
<span class="sd">    if its associated events are subsets of the corresponding events</span>
<span class="sd">    in sse2, and if sse2 contains events, or neuron ids in some event, which</span>
<span class="sd">    do not belong to sse1 (i.e. sse1 and sse2 are not identical)</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">    </span>
<span class="sd">    .. centered:: {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    </span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_equal : bool</span>
<span class="sd">        returns True if sse1 is identical to sse2</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Remove empty links from sse11 and sse22, if any</span>
    <span class="n">sse11</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse1</span><span class="p">)</span>
    <span class="n">sse22</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse2</span><span class="p">)</span>

    <span class="c1"># Return whether sse11 == sse22</span>
    <span class="k">return</span> <span class="n">sse11</span> <span class="o">==</span> <span class="n">sse22</span></div>


<div class="viewcode-block" id="sse_isdisjoint"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_isdisjoint">[docs]</a><span class="k">def</span> <span class="nf">sse_isdisjoint</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), determines whether sse1 and sse2 are disjoint.</span>
<span class="sd">    Two SSEs are disjoint if they don&#39;t share pixels, or if the events</span>
<span class="sd">    associated to common pixels are disjoint.</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">    </span>
<span class="sd">    .. centered:: {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    </span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dictionary</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_disjoint : bool</span>
<span class="sd">        returns True if sse1 is disjoint from sse2.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Remove empty links from sse11 and sse22, if any</span>
    <span class="n">sse11</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse1</span><span class="p">)</span>
    <span class="n">sse22</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse2</span><span class="p">)</span>

    <span class="c1"># If both SSEs are empty, return False (we consider them equal)</span>
    <span class="k">if</span> <span class="n">sse11</span> <span class="o">==</span> <span class="p">{}</span> <span class="ow">and</span> <span class="n">sse22</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">common_pixels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sse11</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sse22</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">if</span> <span class="n">common_pixels</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">sse11</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">sse22</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">common_pixels</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="sse_issub"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_issub">[docs]</a><span class="k">def</span> <span class="nf">sse_issub</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), determines whether sse1 is strictly contained in sse2.</span>
<span class="sd">    sse1 is strictly contained in sse2 if all its pixels are pixels of sse2,</span>
<span class="sd">    if its associated events are subsets of the corresponding events</span>
<span class="sd">    in sse2, and if sse2 contains non-empty events, or neuron ids in some</span>
<span class="sd">    event, which do not belong to sse1 (i.e. sse1 and sse2 are not identical)</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">            {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_sub : bool</span>
<span class="sd">        returns True if sse1 is a subset of sse2</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Remove empty links from sse11 and sse22, if any</span>
    <span class="n">sse11</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse1</span><span class="p">)</span>
    <span class="n">sse22</span> <span class="o">=</span> <span class="n">_remove_empty_events</span><span class="p">(</span><span class="n">sse2</span><span class="p">)</span>

    <span class="c1"># Return False if sse11 and sse22 are disjoint</span>
    <span class="k">if</span> <span class="n">sse_isdisjoint</span><span class="p">(</span><span class="n">sse11</span><span class="p">,</span> <span class="n">sse22</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Return False if any pixel in sse1 is not contained in sse2, or if any</span>
    <span class="c1"># link of sse1 is not a subset of the corresponding link in sse2.</span>
    <span class="c1"># Otherwise (if sse1 is a subset of sse2) continue</span>
    <span class="k">for</span> <span class="n">pixel1</span><span class="p">,</span> <span class="n">link1</span> <span class="ow">in</span> <span class="n">sse11</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">pixel1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sse22</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">link1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">sse22</span><span class="p">[</span><span class="n">pixel1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check that sse1 is a STRICT subset of sse2, i.e. that sse2 contains at</span>
    <span class="c1"># least one pixel or neuron id not present in sse1.</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">sse_isequal</span><span class="p">(</span><span class="n">sse11</span><span class="p">,</span> <span class="n">sse22</span><span class="p">)</span></div>


<div class="viewcode-block" id="sse_issuper"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_issuper">[docs]</a><span class="k">def</span> <span class="nf">sse_issuper</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), determines whether sse1 strictly contains sse2.</span>
<span class="sd">    sse1 strictly contains sse2 if it contains all pixels of sse2, if all</span>
<span class="sd">    associated events in sse1 contain those in sse2, and if sse1 additionally</span>
<span class="sd">    contains other pixels / events not contained in sse2.</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">            {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Note: sse_issuper(sse1, sse2) is identical to sse_issub(sse2, sse1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_super : bool</span>
<span class="sd">        returns True if sse1 strictly contains sse2.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sse_issub</span><span class="p">(</span><span class="n">sse2</span><span class="p">,</span> <span class="n">sse1</span><span class="p">)</span></div>


<div class="viewcode-block" id="sse_overlap"><a class="viewcode-back" href="../../source/elephant.asset.html#elephant.asset.sse_overlap">[docs]</a><span class="k">def</span> <span class="nf">sse_overlap</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two sequences of synchronous events (SSEs) sse1 and sse2, each</span>
<span class="sd">    consisting of a pool of pixel positions and associated synchronous events</span>
<span class="sd">    (see below), determines whether sse1 strictly contains sse2.</span>
<span class="sd">    sse1 strictly contains sse2 if it contains all pixels of sse2, if all</span>
<span class="sd">    associated events in sse1 contain those in sse2, and if sse1 additionally</span>
<span class="sd">    contains other pixels / events not contained in sse2.</span>

<span class="sd">    Both sse1 and sse2 must be provided as dictionaries of the type</span>
<span class="sd">            {(i1, j1): S1, (i2, j2): S2, ..., (iK, jK): SK},</span>
<span class="sd">    where each i, j is an integer and each S is a set of neuron ids.</span>
<span class="sd">    (See also: extract_sse() that extracts SSEs from given spiketrains).</span>

<span class="sd">    Note: sse_issuper(sse1, sse2) is identical to sse_issub(sse2, sse1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sse1, sse2 : each a dict</span>
<span class="sd">        a dictionary of pixel positions (i, j) as keys, and sets S of</span>
<span class="sd">        synchronous events as values (see above).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_super : bool</span>
<span class="sd">        returns True if sse1 strictly contains sse2.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sse_issub</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sse_issuper</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">sse_isequal</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sse_isdisjoint</span><span class="p">(</span><span class="n">sse1</span><span class="p">,</span> <span class="n">sse2</span><span class="p">))</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2018, Elephant authors and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>