
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>elephant.spike_train_generation &#8212; Elephant 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/elephant_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/elephant_logo_sidebar.png"></span>
          Elephant</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Pages <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Prerequisites / Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Function Reference by Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide.html">Developers&#8217; guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc_style_guidelines.html">Documentation and style guideline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors and contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for elephant.spike_train_generation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions to generate spike trains from analog signals,</span>
<span class="sd">or to generate random spike trains.</span>

<span class="sd">Some functions are based on the NeuroTools stgen module, which was mostly</span>
<span class="sd">written by Eilif Muller, or from the NeuroTools signals.analogs module.</span>

<span class="sd">:copyright: Copyright 2015 by the Elephant team, see AUTHORS.txt.</span>
<span class="sd">:license: Modified BSD, see LICENSE.txt for details.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">quantities</span> <span class="k">import</span> <span class="n">ms</span><span class="p">,</span> <span class="n">mV</span><span class="p">,</span> <span class="n">Hz</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">dimensionless</span>
<span class="kn">from</span> <span class="nn">neo</span> <span class="k">import</span> <span class="n">SpikeTrain</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">elephant.spike_train_surrogates</span> <span class="k">import</span> <span class="n">dither_spike_train</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="spike_extraction"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.spike_extraction">[docs]</a><span class="k">def</span> <span class="nf">spike_extraction</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">mV</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;above&#39;</span><span class="p">,</span>
                     <span class="n">time_stamps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extr_interval</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ms</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the peak times for all events that cross threshold and the</span>
<span class="sd">    waveforms. Usually used for extracting spikes from a membrane</span>
<span class="sd">    potential to calculate waveform properties.</span>
<span class="sd">    Similar to spike_train_generation.peak_detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : neo AnalogSignal object</span>
<span class="sd">        &#39;signal&#39; is an analog signal.</span>
<span class="sd">    threshold : A quantity, e.g. in mV</span>
<span class="sd">        &#39;threshold&#39; contains a value that must be reached for an event</span>
<span class="sd">        to be detected. Default: 0.0 * mV.</span>
<span class="sd">    sign : &#39;above&#39; or &#39;below&#39;</span>
<span class="sd">        &#39;sign&#39; determines whether to count thresholding crossings</span>
<span class="sd">        that cross above or below the threshold. Default: &#39;above&#39;.</span>
<span class="sd">    time_stamps: None, quantity array or Object with .times interface</span>
<span class="sd">        if &#39;spike_train&#39; is a quantity array or exposes a quantity array</span>
<span class="sd">        exposes the .times interface, it provides the time_stamps</span>
<span class="sd">        around which the waveform is extracted. If it is None, the</span>
<span class="sd">        function peak_detection is used to calculate the time_stamps</span>
<span class="sd">        from signal. Default: None.</span>
<span class="sd">    extr_interval: unpackable time quantities, len == 2</span>
<span class="sd">        &#39;extr_interval&#39; specifies the time interval around the</span>
<span class="sd">        time_stamps where the waveform is extracted. The default is an</span>
<span class="sd">        interval of &#39;6 ms&#39;. Default: (-2 * ms, 4 * ms).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result_st : neo SpikeTrain object</span>
<span class="sd">        &#39;result_st&#39; contains the time_stamps of each of the spikes and</span>
<span class="sd">        the waveforms in result_st.waveforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get spike time_stamps</span>
    <span class="k">if</span> <span class="n">time_stamps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">time_stamps</span> <span class="o">=</span> <span class="n">peak_detection</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">,</span> <span class="s1">&#39;times&#39;</span><span class="p">):</span>
        <span class="n">time_stamps</span> <span class="o">=</span> <span class="n">time_stamps</span><span class="o">.</span><span class="n">times</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Quantity</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;time_stamps must be None, a quantity array or&quot;</span> <span class="o">+</span>
                        <span class="s2">&quot; expose the.times interface&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                          <span class="n">t_start</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span>
                          <span class="n">waveforms</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                          <span class="n">sampling_rate</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># Unpack the extraction interval from tuple or array</span>
    <span class="n">extr_left</span><span class="p">,</span> <span class="n">extr_right</span> <span class="o">=</span> <span class="n">extr_interval</span>
    <span class="k">if</span> <span class="n">extr_left</span> <span class="o">&gt;</span> <span class="n">extr_right</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;extr_interval[0] must be &lt; extr_interval[1]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">extr_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Waveforms overlap.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

    <span class="n">data_left</span> <span class="o">=</span> <span class="p">((</span><span class="n">extr_left</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span><span class="o">.</span><span class="n">simplified</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>

    <span class="n">data_right</span> <span class="o">=</span> <span class="p">((</span><span class="n">extr_right</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span><span class="o">.</span><span class="n">simplified</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>

    <span class="n">data_stamps</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time_stamps</span> <span class="o">-</span> <span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">signal</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span><span class="o">.</span><span class="n">simplified</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>

    <span class="n">data_stamps</span> <span class="o">=</span> <span class="n">data_stamps</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">borders_left</span> <span class="o">=</span> <span class="n">data_stamps</span> <span class="o">+</span> <span class="n">data_left</span>

    <span class="n">borders_right</span> <span class="o">=</span> <span class="n">data_stamps</span> <span class="o">+</span> <span class="n">data_right</span>

    <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">borders_left</span><span class="p">,</span> <span class="n">borders_right</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">borders</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">units</span>

    <span class="c1"># len(np.shape(waveforms)) == 1 if waveforms do not have the same width.</span>
    <span class="c1"># this can occur when extr_interval indexes beyond the signal.</span>
    <span class="c1"># Workaround: delete spikes shorter than the maximum length with</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">waveforms</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">waveforms</span><span class="p">]))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>
                             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_len</span><span class="p">])</span>
        <span class="n">waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">waveforms</span><span class="p">])</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Waveforms &quot;</span> <span class="o">+</span>
                      <span class="p">(</span><span class="s2">&quot;</span><span class="si">{:d}</span><span class="s2">, &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_delete</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">to_delete</span><span class="p">)</span> <span class="o">+</span>
                      <span class="s2">&quot;exceeded signal and had to be deleted. &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;Change extr_interval to keep.&quot;</span><span class="p">)</span>

    <span class="n">waveforms</span> <span class="o">=</span> <span class="n">waveforms</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">time_stamps</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                      <span class="n">t_start</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span>
                      <span class="n">sampling_rate</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">=</span><span class="n">waveforms</span><span class="p">,</span>
                      <span class="n">left_sweep</span><span class="o">=</span><span class="n">extr_left</span><span class="p">)</span></div>


<div class="viewcode-block" id="threshold_detection"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.threshold_detection">[docs]</a><span class="k">def</span> <span class="nf">threshold_detection</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">mV</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;above&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the times when the analog signal crosses a threshold.</span>
<span class="sd">    Usually used for extracting spike times from a membrane potential.</span>
<span class="sd">    Adapted from version in NeuroTools.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : neo AnalogSignal object</span>
<span class="sd">        &#39;signal&#39; is an analog signal.</span>
<span class="sd">    threshold : A quantity, e.g. in mV</span>
<span class="sd">        &#39;threshold&#39; contains a value that must be reached</span>
<span class="sd">        for an event to be detected. Default: 0.0 * mV.</span>
<span class="sd">    sign : &#39;above&#39; or &#39;below&#39;</span>
<span class="sd">        &#39;sign&#39; determines whether to count thresholding crossings</span>
<span class="sd">        that cross above or below the threshold.</span>
<span class="sd">    format : None or &#39;raw&#39;</span>
<span class="sd">        Whether to return as SpikeTrain (None)</span>
<span class="sd">        or as a plain array of times (&#39;raw&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result_st : neo SpikeTrain object</span>
<span class="sd">        &#39;result_st&#39; contains the spike times of each of the events (spikes)</span>
<span class="sd">        extracted from the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;A threshold must be provided&quot;</span>

    <span class="k">if</span> <span class="n">sign</span> <span class="ow">is</span> <span class="s1">&#39;above&#39;</span><span class="p">:</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signal</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">sign</span> <span class="ow">in</span> <span class="s1">&#39;below&#39;</span><span class="p">:</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signal</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">take</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">take</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">take</span><span class="p">)</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">times</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">cutout</span><span class="p">][</span><span class="n">take</span><span class="p">]</span>

    <span class="n">events_base</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">base</span>
    <span class="k">if</span> <span class="n">events_base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This occurs in some Python 3 builds due to some</span>
        <span class="c1"># bug in quantities.</span>
        <span class="n">events_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">event</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">])</span>  <span class="c1"># Workaround</span>

    <span class="n">result_st</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">events_base</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                           <span class="n">t_start</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_st</span></div>


<div class="viewcode-block" id="peak_detection"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.peak_detection">[docs]</a><span class="k">def</span> <span class="nf">peak_detection</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">mV</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;above&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the peak times for all events that cross threshold.</span>
<span class="sd">    Usually used for extracting spike times from a membrane potential.</span>
<span class="sd">    Similar to spike_train_generation.threshold_detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : neo AnalogSignal object</span>
<span class="sd">        &#39;signal&#39; is an analog signal.</span>
<span class="sd">    threshold : A quantity, e.g. in mV</span>
<span class="sd">        &#39;threshold&#39; contains a value that must be reached</span>
<span class="sd">        for an event to be detected.</span>
<span class="sd">    sign : &#39;above&#39; or &#39;below&#39;</span>
<span class="sd">        &#39;sign&#39; determines whether to count thresholding crossings that</span>
<span class="sd">        cross above or below the threshold. Default: &#39;above&#39;.</span>
<span class="sd">    format : None or &#39;raw&#39;</span>
<span class="sd">        Whether to return as SpikeTrain (None) or as a plain array</span>
<span class="sd">        of times (&#39;raw&#39;). Default: None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result_st : neo SpikeTrain object</span>
<span class="sd">        &#39;result_st&#39; contains the spike times of each of the events</span>
<span class="sd">        (spikes) extracted from the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;A threshold must be provided&quot;</span>

    <span class="k">if</span> <span class="n">sign</span> <span class="ow">is</span> <span class="s1">&#39;above&#39;</span><span class="p">:</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signal</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peak_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span>
    <span class="k">elif</span> <span class="n">sign</span> <span class="ow">in</span> <span class="s1">&#39;below&#39;</span><span class="p">:</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signal</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peak_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sign must be &#39;above&#39; or &#39;below&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">events_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Select thr crossings lasting at least 2 dtps, np.diff(cutout) &gt; 2</span>
        <span class="c1"># This avoids empty slices</span>
        <span class="n">border_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">border_end</span> <span class="o">=</span> <span class="n">border_start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">border_start</span><span class="p">,</span> <span class="n">border_end</span><span class="p">))</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">borders</span><span class="p">)</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">borders</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutout</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">borders</span><span class="p">)</span>
        <span class="n">true_borders</span> <span class="o">=</span> <span class="n">cutout</span><span class="p">[</span><span class="n">borders</span><span class="p">]</span>
        <span class="n">right_borders</span> <span class="o">=</span> <span class="n">true_borders</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">true_borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">true_borders</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">right_borders</span><span class="p">))</span>

        <span class="c1"># Workaround for bug that occurs when signal goes below thr for 1 dtp,</span>
        <span class="c1"># Workaround eliminates empy slices from np. split</span>
        <span class="n">backward_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">true_borders</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">forward_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">true_borders</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                              <span class="n">to_begin</span><span class="o">=</span><span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">true_borders</span> <span class="o">=</span> <span class="n">true_borders</span><span class="p">[</span><span class="n">backward_mask</span> <span class="o">*</span> <span class="n">forward_mask</span><span class="p">]</span>
        <span class="n">split_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">true_borders</span><span class="p">)[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">maxima_idc_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">split_signal</span><span class="p">])</span>

        <span class="n">max_idc</span> <span class="o">=</span> <span class="n">maxima_idc_split</span> <span class="o">+</span> <span class="n">true_borders</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">events</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">max_idc</span><span class="p">]</span>
        <span class="n">events_base</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">base</span>

    <span class="k">if</span> <span class="n">events_base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This occurs in some Python 3 builds due to some</span>
        <span class="c1"># bug in quantities.</span>
        <span class="n">events_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">event</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">])</span>  <span class="c1"># Workaround</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result_st</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">events_base</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                               <span class="n">t_start</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;raw&#39;</span><span class="p">:</span>
        <span class="n">result_st</span> <span class="o">=</span> <span class="n">events_base</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Format argument must be None or &#39;raw&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result_st</span></div>


<span class="k">def</span> <span class="nf">_homogeneous_process</span><span class="p">(</span><span class="n">interval_generator</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">mean_rate</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
                         <span class="n">as_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a spike train whose spikes are a realization of a random process</span>
<span class="sd">    generated by the function `interval_generator` with the given rate,</span>
<span class="sd">    starting at time `t_start` and stopping `time t_stop`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">mean_rate</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">mean_rate</span><span class="p">)</span><span class="o">.</span><span class="n">simplified</span><span class="p">)</span>
    <span class="n">number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">number</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="mi">4</span>  <span class="c1"># if positive, number cannot be less than 5</span>
    <span class="n">isi</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">interval_generator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">)))</span>
    <span class="n">spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">isi</span><span class="p">)</span>
    <span class="n">spikes</span> <span class="o">+=</span> <span class="n">t_start</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">spikes</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_stop</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes</span><span class="p">):</span>
        <span class="c1"># ISI buffer overrun</span>
        <span class="n">extra_spikes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_last</span> <span class="o">=</span> <span class="n">spikes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">rescale</span><span class="p">(</span><span class="n">interval_generator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">t_last</span> <span class="o">&lt;</span> <span class="n">t_stop</span><span class="p">:</span>
            <span class="n">extra_spikes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_last</span><span class="p">)</span>
            <span class="n">t_last</span> <span class="o">=</span> <span class="n">t_last</span> <span class="o">+</span> <span class="n">rescale</span><span class="p">(</span><span class="n">interval_generator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># np.concatenate does not conserve units</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">spikes</span><span class="p">,</span> <span class="n">extra_spikes</span><span class="p">))</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">spikes</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">as_array</span><span class="p">:</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span>
            <span class="n">spikes</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">spikes</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spikes</span>


<div class="viewcode-block" id="homogeneous_poisson_process"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.homogeneous_poisson_process">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span>
                                <span class="n">as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a spike train whose spikes are a realization of a Poisson process</span>
<span class="sd">    with the given rate, starting at time `t_start` and stopping time `t_stop`.</span>

<span class="sd">    All numerical values should be given as Quantities, e.g. 100*Hz.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    rate : Quantity scalar with dimension 1/time</span>
<span class="sd">           The rate of the discharge.</span>
<span class="sd">    t_start : Quantity scalar with dimension time</span>
<span class="sd">              The beginning of the spike train.</span>
<span class="sd">    t_stop : Quantity scalar with dimension time</span>
<span class="sd">             The end of the spike train.</span>
<span class="sd">    as_array : bool</span>
<span class="sd">               If True, a NumPy array of sorted spikes is returned,</span>
<span class="sd">               rather than a SpikeTrain object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : If `t_start` and `t_stop` are not of type `pq.Quantity`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; from quantities import Hz, ms</span>
<span class="sd">        &gt;&gt;&gt; spikes = homogeneous_poisson_process(50*Hz, 0*ms, 1000*ms)</span>
<span class="sd">        &gt;&gt;&gt; spikes = homogeneous_poisson_process(</span>
<span class="sd">            20*Hz, 5000*ms, 10000*ms, as_array=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_start and t_stop must be of type pq.Quantity&quot;</span><span class="p">)</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">rescale</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">t_start</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="n">mean_interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rate</span><span class="o">.</span><span class="n">magnitude</span>
    <span class="k">return</span> <span class="n">_homogeneous_process</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">,</span> <span class="p">(</span><span class="n">mean_interval</span><span class="p">,),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span>
        <span class="n">as_array</span><span class="p">)</span></div>

<div class="viewcode-block" id="inhomogeneous_poisson_process"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.inhomogeneous_poisson_process">[docs]</a><span class="k">def</span> <span class="nf">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a spike train whose spikes are a realization of an inhomogeneous</span>
<span class="sd">    Poisson process with the given rate profile.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rate : neo.AnalogSignal</span>
<span class="sd">        A `neo.AnalogSignal` representing the rate profile evolving over time. </span>
<span class="sd">        Its values have all to be `&gt;=0`. The output spiketrain will have </span>
<span class="sd">        `t_start = rate.t_start` and `t_stop = rate.t_stop`</span>
<span class="sd">    as_array : bool</span>
<span class="sd">           If True, a NumPy array of sorted spikes is returned,</span>
<span class="sd">           rather than a SpikeTrain object.</span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : If `rate` contains any negative value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check rate contains only positive values</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">rate</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;rate must be a positive non empty signal, representing the&#39;</span>
            <span class="s1">&#39;rate at time t&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Generate n hidden Poisson SpikeTrains with rate equal to the peak rate</span>
        <span class="n">max_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
        <span class="n">homogeneous_poiss</span> <span class="o">=</span> <span class="n">homogeneous_poisson_process</span><span class="p">(</span>
            <span class="n">rate</span><span class="o">=</span><span class="n">max_rate</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">rate</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">rate</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span>
        <span class="c1"># Compute the rate profile at each spike time by interpolation</span>
        <span class="n">rate_interpolated</span> <span class="o">=</span> <span class="n">_analog_signal_linear_interp</span><span class="p">(</span>
            <span class="n">signal</span><span class="o">=</span><span class="n">rate</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">homogeneous_poiss</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span>
                               <span class="n">homogeneous_poiss</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="c1"># Accept each spike at time t with probability rate(t)/max_rate</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">homogeneous_poiss</span><span class="p">))</span> <span class="o">*</span> <span class="n">max_rate</span>
        <span class="n">spikes</span> <span class="o">=</span> <span class="n">homogeneous_poiss</span><span class="p">[</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">rate_interpolated</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">as_array</span><span class="p">:</span>
            <span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="k">return</span> <span class="n">spikes</span></div>


<span class="k">def</span> <span class="nf">_analog_signal_linear_interp</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the linear interpolation of a signal at desired times.</span>

<span class="sd">    Given the `signal` (neo.AnalogSignal) taking value `s0` and `s1` at two</span>
<span class="sd">    consecutive time points `t0` and `t1` `(t0 &lt; t1)`, for every time `t` in </span>
<span class="sd">    `times`, such that `t0&lt;t&lt;=t1` is returned the value of the linear </span>
<span class="sd">    interpolation, given by:</span>
<span class="sd">                `s = ((s1 - s0) / (t1 - t0)) * t + s0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : Quantity vector(time)</span>
<span class="sd">        The time points for which the interpolation is computed</span>

<span class="sd">    signal : neo.core.AnalogSignal</span>
<span class="sd">        The analog signal containing the discretization of the function to</span>
<span class="sd">        interpolate</span>
<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    out: Quantity array representing the values of the interpolated signal at the</span>
<span class="sd">    times given by times</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `signal` has sampling period `dt=signal.sampling_period`, its values </span>
<span class="sd">    are defined at `t=signal.times`, such that `t[i] = signal.t_start + i * dt` </span>
<span class="sd">    The last of such times is lower than </span>
<span class="sd">    signal.t_stop`:t[-1] = signal.t_stop - dt`. </span>
<span class="sd">    For the interpolation at times t such that `t[-1] &lt;= t &lt;= signal.t_stop`,</span>
<span class="sd">    the value of `signal` at `signal.t_stop` is taken to be that</span>
<span class="sd">    at time `t[-1]`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sampling_period</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">t_start</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="n">t_stop</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">t_stop</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="c1"># Extend the signal (as a dimensionless array) copying the last value</span>
    <span class="c1"># one time, and extend its times to t_stop</span>
    <span class="n">signal_extended</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">signal</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">times_extended</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">])</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">units</span>
    <span class="n">time_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(((</span><span class="n">times</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span>
        <span class="n">dimensionless</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the slope m of the signal at each time in times</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">signal_extended</span><span class="p">[</span><span class="n">time_ids</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">signal_extended</span><span class="p">[</span><span class="n">time_ids</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>

    <span class="c1"># Interpolate the signal at each time in times by linear interpolation</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">times</span> <span class="o">-</span> <span class="n">times_extended</span><span class="p">[</span><span class="n">time_ids</span><span class="p">]))</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">units</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

<div class="viewcode-block" id="homogeneous_gamma_process"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.homogeneous_gamma_process">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_gamma_process</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span>
                              <span class="n">as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a spike train whose spikes are a realization of a gamma process</span>
<span class="sd">    with the given parameters, starting at time `t_start` and stopping time</span>
<span class="sd">    `t_stop` (average rate will be b/a).</span>

<span class="sd">    All numerical values should be given as Quantities, e.g. 100*Hz.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    a : int or float</span>
<span class="sd">        The shape parameter of the gamma distribution.</span>
<span class="sd">    b : Quantity scalar with dimension 1/time</span>
<span class="sd">        The rate parameter of the gamma distribution.</span>
<span class="sd">    t_start : Quantity scalar with dimension time</span>
<span class="sd">              The beginning of the spike train.</span>
<span class="sd">    t_stop : Quantity scalar with dimension time</span>
<span class="sd">             The end of the spike train.</span>
<span class="sd">    as_array : bool</span>
<span class="sd">               If True, a NumPy array of sorted spikes is returned,</span>
<span class="sd">               rather than a SpikeTrain object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError : If `t_start` and `t_stop` are not of type `pq.Quantity`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        &gt;&gt;&gt; from quantities import Hz, ms</span>
<span class="sd">        &gt;&gt;&gt; spikes = homogeneous_gamma_process(2.0, 50*Hz, 0*ms, 1000*ms)</span>
<span class="sd">        &gt;&gt;&gt; spikes = homogeneous_gamma_process(</span>
<span class="sd">                5.0, 20*Hz, 5000*ms, 10000*ms, as_array=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_start and t_stop must be of type pq.Quantity&quot;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">rescale</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">t_start</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">simplified</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_homogeneous_process</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">theta</span><span class="p">),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">as_array</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_n_poisson</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mf">0.0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates one or more independent Poisson spike trains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rate : Quantity or Quantity array</span>
<span class="sd">        Expected firing rate (frequency) of each output SpikeTrain.</span>
<span class="sd">        Can be one of:</span>
<span class="sd">        *  a single Quantity value: expected firing rate of each output</span>
<span class="sd">           SpikeTrain</span>
<span class="sd">        *  a Quantity array: rate[i] is the expected firing rate of the i-th</span>
<span class="sd">           output SpikeTrain</span>
<span class="sd">    t_stop : Quantity</span>
<span class="sd">        Single common stop time of each output SpikeTrain. Must be &gt; t_start.</span>
<span class="sd">    t_start : Quantity (optional)</span>
<span class="sd">        Single common start time of each output SpikeTrain. Must be &lt; t_stop.</span>
<span class="sd">        Default: 0 s.</span>
<span class="sd">    n: int (optional)</span>
<span class="sd">        If rate is a single Quantity value, n specifies the number of</span>
<span class="sd">        SpikeTrains to be generated. If rate is an array, n is ignored and the</span>
<span class="sd">        number of SpikeTrains is equal to len(rate).</span>
<span class="sd">        Default: 1</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of neo.SpikeTrain</span>
<span class="sd">        Each SpikeTrain contains one of the independent Poisson spike trains,</span>
<span class="sd">        either n SpikeTrains of the same rate, or len(rate) SpikeTrains with</span>
<span class="sd">        varying rates according to the rate parameter. The time unit of the</span>
<span class="sd">        SpikeTrains is given by t_stop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that the provided input is Hertz of return error</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rate argument must have rate unit (1/time)&#39;</span><span class="p">)</span>

    <span class="c1"># Check t_start &lt; t_stop and create their strip dimensions</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">t_start</span> <span class="o">&lt;</span> <span class="n">t_stop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;t_start (=</span><span class="si">%s</span><span class="s1">) must be &lt; t_stop (=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">))</span>

    <span class="c1"># Set number n of output spike trains (specified or set to len(rate))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n (=</span><span class="si">%s</span><span class="s1">) must be a positive integer&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">rate_dl</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">simplified</span><span class="o">.</span><span class="n">magnitude</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Check rate input parameter</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate_dl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rate_dl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rate (=</span><span class="si">%s</span><span class="s1">) must be non-negative.&#39;</span> <span class="o">%</span> <span class="n">rate</span><span class="p">)</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rate_dl</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">rate_dl</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">rates</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rate must have non-negative elements.&#39;</span><span class="p">)</span>
    <span class="n">sts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rates</span><span class="p">:</span>
        <span class="n">sts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">homogeneous_poisson_process</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">Hz</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sts</span>


<div class="viewcode-block" id="single_interaction_process"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.single_interaction_process">[docs]</a><span class="k">def</span> <span class="nf">single_interaction_process</span><span class="p">(</span>
        <span class="n">rate</span><span class="p">,</span> <span class="n">rate_c</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">coincidences</span><span class="o">=</span><span class="s1">&#39;deterministic&#39;</span><span class="p">,</span>
        <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">min_delay</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">,</span> <span class="n">return_coinc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a multidimensional Poisson SIP (single interaction process)</span>
<span class="sd">    plus independent Poisson processes</span>

<span class="sd">    A Poisson SIP consists of Poisson time series which are independent</span>
<span class="sd">    except for simultaneous events in all of them. This routine generates</span>
<span class="sd">    a SIP plus additional parallel independent Poisson processes.</span>

<span class="sd">    See [1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    t_stop: quantities.Quantity</span>
<span class="sd">        Total time of the simulated processes. The events are drawn between</span>
<span class="sd">        0 and `t_stop`.</span>
<span class="sd">    rate: quantities.Quantity</span>
<span class="sd">        Overall mean rate of the time series to be generated (coincidence</span>
<span class="sd">        rate `rate_c` is subtracted to determine the background rate). Can be:</span>
<span class="sd">        * a float, representing the overall mean rate of each process. If</span>
<span class="sd">          so, it must be higher than `rate_c`.</span>
<span class="sd">        * an iterable of floats (one float per process), each float</span>
<span class="sd">          representing the overall mean rate of a process. If so, all the</span>
<span class="sd">          entries must be larger than `rate_c`.</span>
<span class="sd">    rate_c: quantities.Quantity</span>
<span class="sd">        Coincidence rate (rate of coincidences for the n-dimensional SIP).</span>
<span class="sd">        The SIP spike trains will have coincident events with rate `rate_c`</span>
<span class="sd">        plus independent &#39;background&#39; events with rate `rate-rate_c`.</span>
<span class="sd">    n: int, optional</span>
<span class="sd">        If `rate` is a single Quantity value, `n` specifies the number of</span>
<span class="sd">        SpikeTrains to be generated. If rate is an array, `n` is ignored and</span>
<span class="sd">        the number of SpikeTrains is equal to `len(rate)`.</span>
<span class="sd">        Default: 1</span>
<span class="sd">    jitter: quantities.Quantity, optional</span>
<span class="sd">        Jitter for the coincident events. If `jitter == 0`, the events of all</span>
<span class="sd">        n correlated processes are exactly coincident. Otherwise, they are</span>
<span class="sd">        jittered around a common time randomly, up to +/- `jitter`.</span>
<span class="sd">    coincidences: string, optional</span>
<span class="sd">        Whether the total number of injected coincidences must be determin-</span>
<span class="sd">        istic (i.e. rate_c is the actual rate with which coincidences are</span>
<span class="sd">        generated) or stochastic (i.e. rate_c is the mean rate of coincid-</span>
<span class="sd">        ences):</span>
<span class="sd">        * &#39;deterministic&#39;: deterministic rate</span>
<span class="sd">        * &#39;stochastic&#39;: stochastic rate</span>
<span class="sd">        Default: &#39;deterministic&#39;</span>
<span class="sd">    t_start: quantities.Quantity, optional</span>
<span class="sd">        Starting time of the series. If specified, it must be lower than</span>
<span class="sd">        t_stop</span>
<span class="sd">        Default: 0 * ms</span>
<span class="sd">    min_delay: quantities.Quantity, optional</span>
<span class="sd">        Minimum delay between consecutive coincidence times.</span>
<span class="sd">        Default: 0 * ms</span>
<span class="sd">    return_coinc: bool, optional</span>
<span class="sd">        Whether to return the coincidence times for the SIP process</span>
<span class="sd">        Default: False</span>


<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: list</span>
<span class="sd">        Realization of a SIP consisting of n Poisson processes characterized</span>
<span class="sd">        by synchronous events (with the given jitter)</span>
<span class="sd">        If `return_coinc` is `True`, the coincidence times are returned as a</span>
<span class="sd">        second output argument. They also have an associated time unit (same</span>
<span class="sd">        as `t_stop`).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Kuhn, Aertsen, Rotter (2003) Neural Comput 15(1):67-101</span>

<span class="sd">    EXAMPLE:</span>

<span class="sd">    &gt;&gt;&gt; import quantities as qt</span>
<span class="sd">    &gt;&gt;&gt; import jelephant.core.stocmod as sm</span>
<span class="sd">    &gt;&gt;&gt; sip, coinc = sm.sip_poisson(n=10, n=0, t_stop=1*qt.sec, \</span>
<span class="sd">            rate=20*qt.Hz,  rate_c=4, return_coinc = True)</span>

<span class="sd">    *************************************************************************</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if n is a positive integer</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n (=</span><span class="si">%s</span><span class="s1">) must be a positive integer&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># Assign time unit to jitter, or check that its existing unit is a time</span>
    <span class="c1"># unit</span>
    <span class="n">jitter</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">jitter</span><span class="p">)</span>

    <span class="c1"># Define the array of rates from input argument rate. Check that its length</span>
    <span class="c1"># matches with n</span>
    <span class="k">if</span> <span class="n">rate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">Hz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;rate (=</span><span class="si">%s</span><span class="s1">) must be non-negative.&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">rate</span><span class="p">))</span>
        <span class="n">rates_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">rate</span><span class="o">.</span><span class="n">magnitude</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span> <span class="o">*</span> <span class="n">rate</span><span class="o">.</span><span class="n">units</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rates_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">*</span> <span class="n">rate</span><span class="o">.</span><span class="n">units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">rates_b</span> <span class="o">&gt;=</span> <span class="mf">0.</span> <span class="o">*</span> <span class="n">Hz</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;*rate* must have non-negative elements&#39;</span><span class="p">)</span>

    <span class="c1"># Check: rate&gt;=rate_c</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rates_b</span> <span class="o">&lt;</span> <span class="n">rate_c</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all elements of *rate* must be &gt;= *rate_c*&#39;</span><span class="p">)</span>

    <span class="c1"># Check min_delay &lt; 1./rate_c</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rate_c</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">Hz</span> <span class="ow">or</span> <span class="n">min_delay</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">rate_c</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;*min_delay* (</span><span class="si">%s</span><span class="s2">) must be lower than 1/*rate_c* (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">min_delay</span><span class="p">),</span> <span class="nb">str</span><span class="p">((</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">rate_c</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">min_delay</span><span class="o">.</span><span class="n">units</span><span class="p">))))</span>

    <span class="c1"># Generate the n Poisson processes there are the basis for the SIP</span>
    <span class="c1"># (coincidences still lacking)</span>
    <span class="n">embedded_poisson_trains</span> <span class="o">=</span> <span class="n">_n_poisson</span><span class="p">(</span>
        <span class="n">rate</span><span class="o">=</span><span class="n">rates_b</span> <span class="o">-</span> <span class="n">rate_c</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>
    <span class="c1"># Convert the trains from neo SpikeTrain objects to simpler Quantity</span>
    <span class="c1"># objects</span>
    <span class="n">embedded_poisson_trains</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">emb</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">emb</span> <span class="ow">in</span> <span class="n">embedded_poisson_trains</span><span class="p">]</span>

    <span class="c1"># Generate the array of times for coincident events in SIP, not closer than</span>
    <span class="c1"># min_delay. The array is generated as a quantity from the Quantity class</span>
    <span class="c1"># in the quantities module</span>
    <span class="k">if</span> <span class="n">coincidences</span> <span class="o">==</span> <span class="s1">&#39;deterministic&#39;</span><span class="p">:</span>
        <span class="n">Nr_coinc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">rate_c</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">dimensionless</span><span class="p">))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">coinc_times</span> <span class="o">=</span> <span class="n">t_start</span> <span class="o">+</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">Nr_coinc</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">min_delay</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">elif</span> <span class="n">coincidences</span> <span class="o">==</span> <span class="s1">&#39;stochastic&#39;</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">coinc_times</span> <span class="o">=</span> <span class="n">homogeneous_poisson_process</span><span class="p">(</span>
                <span class="n">rate</span><span class="o">=</span><span class="n">rate_c</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">min_delay</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c1"># Convert coinc_times from a neo SpikeTrain object to a Quantity object</span>
        <span class="c1"># pq.Quantity(coinc_times.base)*coinc_times.units</span>
        <span class="n">coinc_times</span> <span class="o">=</span> <span class="n">coinc_times</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span>
        <span class="c1"># Set the coincidence times to T-jitter if larger. This ensures that</span>
        <span class="c1"># the last jittered spike time is &lt;T</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">coinc_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">t_stop</span> <span class="o">-</span> <span class="n">jitter</span><span class="p">:</span>
                <span class="n">coinc_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_stop</span> <span class="o">-</span> <span class="n">jitter</span>

    <span class="c1"># Replicate coinc_times n times, and jitter each event in each array by</span>
    <span class="c1"># +/- jitter (within (t_start, t_stop))</span>
    <span class="n">embedded_coinc</span> <span class="o">=</span> <span class="n">coinc_times</span> <span class="o">+</span> \
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rates_b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coinc_times</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">-</span> <span class="n">jitter</span>
    <span class="n">embedded_coinc</span> <span class="o">=</span> <span class="n">embedded_coinc</span> <span class="o">+</span> \
        <span class="p">(</span><span class="n">t_start</span> <span class="o">-</span> <span class="n">embedded_coinc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">embedded_coinc</span> <span class="o">&lt;</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">-</span> \
        <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">embedded_coinc</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">embedded_coinc</span> <span class="o">&gt;</span> <span class="n">t_stop</span><span class="p">)</span>

    <span class="c1"># Inject coincident events into the n SIP processes generated above, and</span>
    <span class="c1"># merge with the n independent processes</span>
    <span class="n">sip_process</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
            <span class="n">embedded_poisson_trains</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">),</span>
            <span class="n">embedded_coinc</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">)))</span> <span class="o">*</span> <span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rates_b</span><span class="p">))]</span>

    <span class="c1"># Convert back sip_process and coinc_times from Quantity objects to</span>
    <span class="c1"># neo.SpikeTrain objects</span>
    <span class="n">sip_process</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sip_process</span><span class="p">]</span>
    <span class="n">coinc_times</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">embedded_coinc</span><span class="p">]</span>

    <span class="c1"># Return the processes in the specified output_format</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_coinc</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">sip_process</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">sip_process</span><span class="p">,</span> <span class="n">coinc_times</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">def</span> <span class="nf">_pool_two_spiketrains</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extremes</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pool the spikes of two spike trains a and b into a unique spike train.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : neo.SpikeTrains</span>
<span class="sd">        Spike trains to be pooled</span>

<span class="sd">    extremes: str, optional</span>
<span class="sd">        Only spikes of a and b in the specified extremes are considered.</span>
<span class="sd">        * &#39;inner&#39;: pool all spikes from max(a.tstart_ b.t_start) to</span>
<span class="sd">           min(a.t_stop, b.t_stop)</span>
<span class="sd">        * &#39;outer&#39;: pool all spikes from min(a.tstart_ b.t_start) to</span>
<span class="sd">           max(a.t_stop, b.t_stop)</span>
<span class="sd">        Default: &#39;inner&#39;</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    neo.SpikeTrain containing all spikes in a and b falling in the</span>
<span class="sd">    specified extremes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">units</span>
    <span class="n">times_a_dimless</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="n">times_b_dimless</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="n">times_a_dimless</span> <span class="o">+</span> <span class="n">times_b_dimless</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit</span>

    <span class="k">if</span> <span class="n">extremes</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span>
        <span class="n">t_stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">extremes</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span>
        <span class="n">t_stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">t_stop</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">times</span> <span class="o">&gt;</span> <span class="n">t_start</span><span class="p">]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">times</span> <span class="o">&lt;</span> <span class="n">t_stop</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;extremes (</span><span class="si">%s</span><span class="s1">) can only be &quot;inner&quot; or &quot;outer&quot;&#39;</span> <span class="o">%</span> <span class="n">extremes</span><span class="p">)</span>
    <span class="n">pooled_train</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span>
        <span class="n">times</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">magnitude</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span>
        <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pooled_train</span>


<span class="k">def</span> <span class="nf">_pool_spiketrains</span><span class="p">(</span><span class="n">trains</span><span class="p">,</span> <span class="n">extremes</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pool spikes from any number of spike trains into a unique spike train.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trains: list</span>
<span class="sd">        list of spike trains to merge</span>

<span class="sd">    extremes: str, optional</span>
<span class="sd">        Only spikes of a and b in the specified extremes are considered.</span>
<span class="sd">        * &#39;inner&#39;: pool all spikes from min(a.t_start b.t_start) to</span>
<span class="sd">           max(a.t_stop, b.t_stop)</span>
<span class="sd">        * &#39;outer&#39;: pool all spikes from max(a.tstart_ b.t_start) to</span>
<span class="sd">           min(a.t_stop, b.t_stop)</span>
<span class="sd">        Default: &#39;inner&#39;</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    neo.SpikeTrain containing all spikes in trains falling in the</span>
<span class="sd">    specified extremes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">merge_trains</span> <span class="o">=</span> <span class="n">trains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trains</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">merge_trains</span> <span class="o">=</span> <span class="n">_pool_two_spiketrains</span><span class="p">(</span>
            <span class="n">merge_trains</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">extremes</span><span class="o">=</span><span class="n">extremes</span><span class="p">)</span>
    <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span> <span class="o">=</span> <span class="n">merge_trains</span><span class="o">.</span><span class="n">t_start</span><span class="p">,</span> <span class="n">merge_trains</span><span class="o">.</span><span class="n">t_stop</span>
    <span class="n">merge_trains</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">merge_trains</span><span class="p">)</span>
    <span class="n">merge_trains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">merge_trains</span><span class="p">)</span>
    <span class="n">merge_trains</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span>
        <span class="n">merge_trains</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">trains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merge_trains</span>


<span class="k">def</span> <span class="nf">_sample_int_from_pdf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw n independent samples from the set {0,1,...,L}, where L=len(a)-1,</span>
<span class="sd">    according to the probability distribution a.</span>
<span class="sd">    a[j] is the probability to sample j, for each j from 0 to L.</span>


<span class="sd">    Parameters</span>
<span class="sd">    -----</span>
<span class="sd">    a: numpy.array</span>
<span class="sd">        Probability vector (i..e array of sum 1) that at each entry j carries</span>
<span class="sd">        the probability to sample j (j=0,1,...,len(a)-1).</span>

<span class="sd">    n: int</span>
<span class="sd">        Number of samples generated with the function</span>

<span class="sd">    Output</span>
<span class="sd">    -------</span>
<span class="sd">    array of n samples taking values between 0 and n=len(a)-1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># cumulative distribution of a</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># copy u (as column vector) len(a) times</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">A</span> <span class="o">&lt;</span> <span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mother_proc_cpp_stat</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the hidden (&quot;mother&quot;) Poisson process for a Compound Poisson</span>
<span class="sd">    Process (CPP).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.array</span>
<span class="sd">        Amplitude distribution. A[j] represents the probability of a</span>
<span class="sd">        synchronous event of size j.</span>
<span class="sd">        The sum over all entries of a must be equal to one.</span>
<span class="sd">    t_stop : quantities.Quantity</span>
<span class="sd">        The stopping time of the mother process</span>
<span class="sd">    rate : quantities.Quantity</span>
<span class="sd">        Homogeneous rate of the n spike trains that will be genereted by the</span>
<span class="sd">        CPP function</span>
<span class="sd">    t_start : quantities.Quantity, optional</span>
<span class="sd">        The starting time of the mother process</span>
<span class="sd">        Default: 0 ms</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    Poisson spike train representing the mother process generating the CPP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">exp_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># expected value of a</span>
    <span class="n">exp_mother</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">rate</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">exp_A</span><span class="p">)</span>  <span class="c1"># rate of the mother process</span>
    <span class="k">return</span> <span class="n">homogeneous_poisson_process</span><span class="p">(</span>
        <span class="n">rate</span><span class="o">=</span><span class="n">exp_mother</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cpp_hom_stat</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Compound Poisson Process (CPP) with amplitude distribution</span>
<span class="sd">    A and heterogeneous firing rates r=r[0], r[1], ..., r[-1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.ndarray</span>
<span class="sd">        Amplitude distribution. A[j] represents the probability of a</span>
<span class="sd">        synchronous event of size j.</span>
<span class="sd">        The sum over all entries of A must be equal to one.</span>
<span class="sd">    t_stop : quantities.Quantity</span>
<span class="sd">        The end time of the output spike trains</span>
<span class="sd">    rate : quantities.Quantity</span>
<span class="sd">        Average rate of each spike train generated</span>
<span class="sd">    t_start : quantities.Quantity, optional</span>
<span class="sd">        The start time of the output spike trains</span>
<span class="sd">        Default: 0 ms</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    List of n neo.SpikeTrains, having average firing rate r and correlated</span>
<span class="sd">    such to form a CPP with amplitude distribution a</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Generate mother process and associated spike labels</span>
    <span class="n">mother</span> <span class="o">=</span> <span class="n">_mother_proc_cpp_stat</span><span class="p">(</span>
        <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">_sample_int_from_pdf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mother</span><span class="p">))</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Number of trains in output</span>

    <span class="k">try</span><span class="p">:</span>  <span class="c1"># Faster but more memory-consuming approach</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mother</span><span class="p">)</span>  <span class="c1"># number of spikes in the mother process</span>
        <span class="n">spike_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># for each spike, take its label l</span>
        <span class="k">for</span> <span class="n">spike_id</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="c1"># choose l random trains</span>
            <span class="n">train_ids</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">l</span><span class="p">)</span>
            <span class="c1"># and set the spike matrix for that train</span>
            <span class="k">for</span> <span class="n">train_id</span> <span class="ow">in</span> <span class="n">train_ids</span><span class="p">:</span>
                <span class="n">spike_matrix</span><span class="p">[</span><span class="n">train_id</span><span class="p">,</span> <span class="n">spike_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># and spike to True</span>

        <span class="n">times</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">train_id</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spike_matrix</span><span class="p">):</span>
            <span class="n">times</span><span class="p">[</span><span class="n">train_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">mother</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>  <span class="c1"># Slower (~2x) but less memory-consuming approach</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;memory case&#39;</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mother</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="n">train_ids</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">l</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">train_id</span> <span class="ow">in</span> <span class="n">train_ids</span><span class="p">:</span>
                <span class="n">times</span><span class="p">[</span><span class="n">train_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">trains</span> <span class="o">=</span> <span class="p">[</span><span class="n">SpikeTrain</span><span class="p">(</span>
        <span class="n">times</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">trains</span>


<span class="k">def</span> <span class="nf">_cpp_het_stat</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mf">0.</span> <span class="o">*</span> <span class="n">ms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Compound Poisson Process (CPP) with amplitude distribution</span>
<span class="sd">    A and heterogeneous firing rates r=r[0], r[1], ..., r[-1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array</span>
<span class="sd">        CPP&#39;s amplitude distribution. A[j] represents the probability of</span>
<span class="sd">        a synchronous event of size j among the generated spike trains.</span>
<span class="sd">        The sum over all entries of A must be equal to one.</span>
<span class="sd">    t_stop : Quantity (time)</span>
<span class="sd">        The end time of the output spike trains</span>
<span class="sd">    rate : Quantity (1/time)</span>
<span class="sd">        Average rate of each spike train generated</span>
<span class="sd">    t_start : quantities.Quantity, optional</span>
<span class="sd">        The start time of the output spike trains</span>
<span class="sd">        Default: 0 ms</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    List of neo.SpikeTrains with different firing rates, forming</span>
<span class="sd">    a CPP with amplitude distribution A</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Computation of Parameters of the two CPPs that will be merged</span>
    <span class="c1"># (uncorrelated with heterog. rates + correlated with homog. rates)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>  <span class="c1"># number of output spike trains</span>
    <span class="n">A_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># expectation of A</span>
    <span class="n">r_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>  <span class="c1"># sum of all output firing rates</span>
    <span class="n">r_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>  <span class="c1"># minimum of the firing rates</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r_sum</span> <span class="o">-</span> <span class="n">N</span> <span class="o">*</span> <span class="n">r_min</span>  <span class="c1"># rate of the uncorrelated CPP</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r_sum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">A_exp</span><span class="p">)</span> <span class="o">-</span> <span class="n">r1</span>  <span class="c1"># rate of the correlated CPP</span>
    <span class="n">r_mother</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span>  <span class="c1"># rate of the hidden mother process</span>

    <span class="c1"># Check the analytical constraint for the amplitude distribution</span>
    <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r1</span> <span class="o">/</span> <span class="n">r_mother</span><span class="p">)</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">dimensionless</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;A[1] too small / A[i], i&gt;1 too high&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the amplitude distrib of the correlated CPP, and generate it</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r_mother</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span>
    <span class="n">CPP</span> <span class="o">=</span> <span class="n">_cpp_hom_stat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">t_start</span><span class="p">)</span>

    <span class="c1"># Generate the independent heterogeneous Poisson processes</span>
    <span class="n">POISS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">homogeneous_poisson_process</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rate</span><span class="p">]</span>

    <span class="c1"># Pool the correlated CPP and the corresponding Poisson processes</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">_pool_two_spiketrains</span><span class="p">(</span><span class="n">CPP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">POISS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="compound_poisson_process"><a class="viewcode-back" href="../../source/elephant.spike_train_generation.html#elephant.spike_train_generation.compound_poisson_process">[docs]</a><span class="k">def</span> <span class="nf">compound_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Compound Poisson Process (CPP; see [1]) with a given amplitude</span>
<span class="sd">    distribution A and stationary marginal rates r.</span>

<span class="sd">    The CPP process is a model for parallel, correlated processes with Poisson</span>
<span class="sd">    spiking statistics at pre-defined firing rates. It is composed of len(A)-1</span>
<span class="sd">    spike trains with a correlation structure determined by the amplitude</span>
<span class="sd">    distribution A: A[j] is the probability that a spike occurs synchronously</span>
<span class="sd">    in any j spike trains.</span>

<span class="sd">    The CPP is generated by creating a hidden mother Poisson process, and then</span>
<span class="sd">    copying spikes of the mother process to j of the output spike trains with</span>
<span class="sd">    probability A[j].</span>

<span class="sd">    Note that this function decorrelates the firing rate of each SpikeTrain</span>
<span class="sd">    from the probability for that SpikeTrain to participate in a synchronous</span>
<span class="sd">    event (which is uniform across SpikeTrains).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rate : quantities.Quantity</span>
<span class="sd">        Average rate of each spike train generated. Can be:</span>
<span class="sd">          - a single value, all spike trains will have same rate rate</span>
<span class="sd">          - an array of values (of length len(A)-1), each indicating the</span>
<span class="sd">            firing rate of one process in output</span>
<span class="sd">    A : array</span>
<span class="sd">        CPP&#39;s amplitude distribution. A[j] represents the probability of</span>
<span class="sd">        a synchronous event of size j among the generated spike trains.</span>
<span class="sd">        The sum over all entries of A must be equal to one.</span>
<span class="sd">    t_stop : quantities.Quantity</span>
<span class="sd">        The end time of the output spike trains.</span>
<span class="sd">    shift : None or quantities.Quantity, optional</span>
<span class="sd">        If None, the injected synchrony is exact. If shift is a Quantity, all</span>
<span class="sd">        the spike trains are shifted independently by a random amount in</span>
<span class="sd">        the interval [-shift, +shift].</span>
<span class="sd">        Default: None</span>
<span class="sd">    t_start : quantities.Quantity, optional</span>
<span class="sd">        The t_start time of the output spike trains.</span>
<span class="sd">        Default: 0 s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List of neo.SpikeTrains</span>
<span class="sd">        SpikeTrains with specified firing rates forming the CPP with amplitude</span>
<span class="sd">        distribution A.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Staude, Rotter, Gruen (2010) J Comput Neurosci 29:327-350.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check A is a probability distribution (it sums to 1 and is positive)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;A must be a probability vector, sum(A)= </span><span class="si">%f</span><span class="s1"> !=1&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;A must be a probability vector, all the elements of must be &gt;0&#39;</span><span class="p">)</span>
    <span class="c1"># Check that the rate is not an empty Quantity</span>
    <span class="k">if</span> <span class="n">rate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rate</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Rate is an empty Quantity array&#39;</span><span class="p">)</span>
    <span class="c1"># Return empty spike trains for specific parameters</span>
    <span class="k">elif</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rate</span><span class="o">.</span><span class="n">magnitude</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">SpikeTrain</span><span class="p">([]</span> <span class="o">*</span> <span class="n">t_stop</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span>
                       <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Homogeneous rates</span>
        <span class="k">if</span> <span class="n">rate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cpp</span> <span class="o">=</span> <span class="n">_cpp_hom_stat</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>
        <span class="c1"># Heterogeneous rates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpp</span> <span class="o">=</span> <span class="n">_cpp_het_stat</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="n">t_stop</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">rate</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cpp</span>
        <span class="c1"># Dither the output spiketrains</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpp</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">dither_spike_train</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cpp</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">cpp</span></div>

<span class="c1"># Alias for the compound poisson process</span>
<span class="n">cpp</span> <span class="o">=</span> <span class="n">compound_poisson_process</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2018, Elephant authors and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>