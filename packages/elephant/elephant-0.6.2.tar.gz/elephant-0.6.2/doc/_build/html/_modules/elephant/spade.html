
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>elephant.spade &#8212; Elephant 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/my-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/elephant_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/elephant_logo_sidebar.png"></span>
          Elephant</a>
        <span class="navbar-text navbar-version pull-left"><b>0.5</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Pages <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Prerequisites / Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Function Reference by Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide.html">Developers&#8217; guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc_style_guidelines.html">Documentation and style guideline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors and contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release Notes</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for elephant.spade</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SPADE is the combination of a mining technique and multiple statistical tests</span>
<span class="sd">to detect and asses the statistical significance of repeated occurrences of</span>
<span class="sd">spike sequences (spatio-temporal patterns, STP).</span>

<span class="sd">Given a list of Neo Spiketrain objects, assumed to be recorded in parallel, the</span>
<span class="sd">SPADE analysis can be applied as demonstrated in this short toy example of 10</span>
<span class="sd">artificial spike trains of exhibiting fully synchronous events of order 10.</span>

<span class="sd">This modules relies on the implementation of the fp-growth algorithm contained</span>
<span class="sd">in the file fim.so which can be found here (http://www.borgelt.net/pyfim.html)</span>
<span class="sd">and should be available in the spade_src folder (elephant/spade_src/).</span>
<span class="sd">If the fim.so module is not present in the correct location or cannot be </span>
<span class="sd">imported (only available for linux OS) SPADE will make use of a python </span>
<span class="sd">implementation of the fast fca algorithm contained in </span>
<span class="sd">elephant/spade_src/fast_fca.py, which is about 10 times slower.</span>


<span class="sd">import elephant.spade</span>
<span class="sd">import elephant.spike_train_generation</span>
<span class="sd">import quantities as pq</span>

<span class="sd"># Generate correlated data</span>
<span class="sd">sts = elephant.spike_train_generation.cpp(</span>
<span class="sd">    rate=5*pq.Hz, A=[0]+[0.99]+[0]*9+[0.01], t_stop=10*pq.s)</span>

<span class="sd"># Mining patterns with SPADE using a binsize of 1 ms and a window length of 1</span>
<span class="sd"># bin (i.e., detecting only synchronous patterns).</span>
<span class="sd">patterns = spade.spade(</span>
<span class="sd">        data=sts, binsize=1*pq.ms, winlen=1, dither=5*pq.ms,</span>
<span class="sd">        min_spikes=10, n_surr=10, psr_param=[0,0,3],</span>
<span class="sd">        output_format=&#39;patterns&#39;)[&#39;patterns&#39;][0]</span>

<span class="sd"># Plotting</span>
<span class="sd">plt.figure()</span>
<span class="sd">for neu in patterns[&#39;neurons&#39;]:</span>
<span class="sd">    if neu == 0:</span>
<span class="sd">        plt.plot(</span>
<span class="sd">            patterns[&#39;times&#39;], [neu]*len(patterns[&#39;times&#39;]), &#39;ro&#39;,</span>
<span class="sd">            label=&#39;pattern&#39;)</span>
<span class="sd">    else:</span>
<span class="sd">        plt.plot(</span>
<span class="sd">            patterns[&#39;times&#39;], [neu] * len(patterns[&#39;times&#39;]), &#39;ro&#39;)</span>
<span class="sd"># Raster plot of the data</span>
<span class="sd">for st_idx, st in enumerate(sts):</span>
<span class="sd">    if st_idx == 0:</span>
<span class="sd">        plt.plot(st.rescale(pq.ms), [st_idx] * len(st), &#39;k.&#39;, label=&#39;spikes&#39;)</span>
<span class="sd">    else:</span>
<span class="sd">        plt.plot(st.rescale(pq.ms), [st_idx] * len(st), &#39;k.&#39;)</span>
<span class="sd">plt.ylim([-1, len(sts)])</span>
<span class="sd">plt.xlabel(&#39;time (ms)&#39;)</span>
<span class="sd">plt.ylabel(&#39;neurons ids&#39;)</span>
<span class="sd">plt.legend()</span>
<span class="sd">plt.show()</span>

<span class="sd">:copyright: Copyright 2017 by the Elephant team, see AUTHORS.txt.</span>
<span class="sd">:license: BSD, see LICENSE.txt for details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">neo</span>
<span class="kn">import</span> <span class="nn">elephant.spike_train_surrogates</span> <span class="k">as</span> <span class="nn">surr</span>
<span class="kn">import</span> <span class="nn">elephant.conversion</span> <span class="k">as</span> <span class="nn">conv</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">combinations</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;once&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="k">import</span> <span class="n">MPI</span>  <span class="c1"># for parallelized routines</span>
    <span class="n">HAVE_MPI</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">HAVE_MPI</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">elephant.spade_src</span> <span class="k">import</span> <span class="n">fim</span>
    <span class="n">HAVE_FIM</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">HAVE_FIM</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s1">&#39;fim.so not found in elephant/spade_src folder,&#39;</span> <span class="o">+</span>
        <span class="s1">&#39;you are using the python implementation of fast fca&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">elephant.spade_src</span> <span class="k">import</span> <span class="n">fast_fca</span>


<div class="viewcode-block" id="spade"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.spade">[docs]</a><span class="k">def</span> <span class="nf">spade</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">min_spikes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_occ</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">n_subsets</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stability_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_surr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="n">dither</span><span class="o">=</span><span class="mi">15</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stat_corr</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span> <span class="n">psr_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">output_format</span><span class="o">=</span><span class="s1">&#39;concepts&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the SPADE [1,2] analysis for the parallel spike trains given in the</span>
<span class="sd">    input. The data are discretized with a temporal resolution equal binsize</span>
<span class="sd">    in a sliding window of winlen*binsize milliseconds.</span>

<span class="sd">    First, spike patterns are mined from the data using a technique termed</span>
<span class="sd">    frequent itemset mining (FIM) or formal concept analysis (FCA). In this</span>
<span class="sd">    framework, a particular spatio-temporal spike pattern is termed a</span>
<span class="sd">    &quot;concept&quot;. It is then possible to compute the stability and the signature</span>
<span class="sd">    significance of all pattern candidates. In a final step, it is possible to</span>
<span class="sd">    select a stability threshold and the significance level to select only</span>
<span class="sd">    stable/significant concepts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: list of neo.SpikeTrains</span>
<span class="sd">        List containing the parallel spike trains to analyze</span>
<span class="sd">    binsize: Quantity</span>
<span class="sd">        The time precision used to discretize the data (binning).</span>
<span class="sd">    winlen: int (positive)</span>
<span class="sd">        The size (number of bins) of the sliding window used for the analysis.</span>
<span class="sd">        The maximal length of a pattern (delay between first and last spike) is</span>
<span class="sd">        then given by winlen*binsize</span>
<span class="sd">    min_spikes: int (positive)</span>
<span class="sd">        Minimum number of spikes of a sequence to be considered a pattern.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_occ: int (positive)</span>
<span class="sd">       Minimum number of occurrences of a sequence to be considered as a</span>
<span class="sd">       pattern.</span>
<span class="sd">       Default: 2</span>
<span class="sd">    min_neu: int (positive)</span>
<span class="sd">        Minimum number of neurons in a sequence to considered a pattern.</span>
<span class="sd">        Default: 1</span>
<span class="sd">    n_subsets: int</span>
<span class="sd">        Number of subsets of a concept used to approximate its stability. If</span>
<span class="sd">        n_subset is set to 0 the stability is not computed. If, however,</span>
<span class="sd">        for parameters delta and epsilon (see below) delta + epsilon == 0,</span>
<span class="sd">        then an optimal n_subsets is calculated according to the formula given</span>
<span class="sd">        in Babin, Kuznetsov (2012), proposition 6:</span>

<span class="sd">         ..math::</span>
<span class="sd">                n_subset = frac{1}{2\eps^2} \ln(frac{2}{\delta}) +1</span>

<span class="sd">        Default:0</span>
<span class="sd">    delta: float</span>
<span class="sd">        delta: probability with at least ..math:$1-\delta$</span>
<span class="sd">        Default: 0</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        epsilon: absolute error</span>
<span class="sd">        Default: 0</span>
<span class="sd">    stability_thresh: None or list of float</span>
<span class="sd">        List containing the stability thresholds used to filter the concepts.</span>
<span class="sd">        If stab_thr is None, then the concepts are not filtered. Otherwise,</span>
<span class="sd">        only concepts with intensional stability &gt; stab_thr[0] or extensional</span>
<span class="sd">        stability &gt; stab_thr[1] are returned and used for further analysis</span>
<span class="sd">        within SPADE.</span>
<span class="sd">        Default: None</span>
<span class="sd">    n_surr: int</span>
<span class="sd">        Number of surrogates to generate to compute the p-value spectrum.</span>
<span class="sd">        This number should be large (n_surr&gt;=1000 is recommended for 100</span>
<span class="sd">        spike trains in *sts*). If n_surr is 0, then the p-value spectrum is</span>
<span class="sd">        not computed.</span>
<span class="sd">        Default: 0</span>
<span class="sd">    dither: Quantity</span>
<span class="sd">        Amount of spike time dithering for creating the surrogates for</span>
<span class="sd">        filtering the pattern spectrum. A spike at time t is placed randomly</span>
<span class="sd">        within ]t-dither, t+dither[ (see also</span>
<span class="sd">        elephant.spike_train_surrogates.dither_spikes).</span>
<span class="sd">        Default: 15*pq.s</span>
<span class="sd">    alpha: float</span>
<span class="sd">        The significance level of the hypothesis tests performed. If alpha=1</span>
<span class="sd">        all the concepts are returned. If 0&lt;alpha&lt;1 the concepts</span>
<span class="sd">        are filtered according to their signature in the p-value spectrum.</span>
<span class="sd">        Default: 1</span>
<span class="sd">    stat_corr: str</span>
<span class="sd">        Statistical correction to be applied:</span>
<span class="sd">            &#39;&#39; : no statistical correction</span>
<span class="sd">            &#39;f&#39;, &#39;fdr&#39; : false discovery rate</span>
<span class="sd">            &#39;b&#39;, &#39;bonf&#39;: Bonferroni correction</span>
<span class="sd">         Default: &#39;fdr&#39;</span>
<span class="sd">    psr_param: None or list of int</span>
<span class="sd">        This list contains parameters used in the pattern spectrum filtering:</span>
<span class="sd">            psr_param[0]: correction parameter for subset filtering</span>
<span class="sd">                (see parameter h of psr()).</span>
<span class="sd">            psr_param[1]: correction parameter for superset filtering</span>
<span class="sd">                (see parameter k of psr()).</span>
<span class="sd">            psr_param[2]: correction parameter for covered-spikes criterion</span>
<span class="sd">                (see parameter l for psr()).</span>
<span class="sd">    output_format: str</span>
<span class="sd">        distinguish the format of the output (see Returns). Can assume values</span>
<span class="sd">        &#39;concepts&#39; and &#39;patterns&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The output depends on the value of the parameter output_format.</span>

<span class="sd">    If output_format is &#39;concepts&#39;:</span>
<span class="sd">        output: dict</span>
<span class="sd">            Dictionary containing the following keys:</span>
<span class="sd">            patterns: tuple</span>
<span class="sd">                Each element of the tuple corresponds to a pattern and is</span>
<span class="sd">                itself a tuple consisting of:</span>
<span class="sd">                    (spikes in the pattern, occurrences of the patterns)</span>
<span class="sd">                For details see function concepts_mining().</span>

<span class="sd">                If n_subsets&gt;0:</span>
<span class="sd">                    (spikes in the pattern, occurrences of the patterns,</span>
<span class="sd">                    (intensional stability, extensional stability))</span>
<span class="sd">                    corresponding pvalue</span>

<span class="sd">            The patterns are filtered depending on the parameters in input:</span>
<span class="sd">            If stability_thresh==None and alpha==None:</span>
<span class="sd">                output[&#39;patterns&#39;] contains all the candidates patterns</span>
<span class="sd">                (all concepts mined with the fca algorithm)</span>
<span class="sd">            If stability_thresh!=None and alpha==None:</span>
<span class="sd">                output contains only patterns candidates with:</span>
<span class="sd">                    intensional stability&gt;stability_thresh[0] or</span>
<span class="sd">                    extensional stability&gt;stability_thresh[1]</span>
<span class="sd">            If stability_thresh==None and alpha!=1:</span>
<span class="sd">                output contains only pattern candidates with a signature</span>
<span class="sd">                significant in respect the significance level alpha corrected</span>
<span class="sd">            If stability_thresh!=None and alpha!=1:</span>
<span class="sd">                output[&#39;patterns&#39;] contains only pattern candidates with a</span>
<span class="sd">                signature significant in respect the significance level alpha</span>
<span class="sd">                corrected and such that:</span>
<span class="sd">                    intensional stability&gt;stability_thresh[0] or</span>
<span class="sd">                    extensional stability&gt;stability_thresh[1]</span>
<span class="sd">                In addition, output[&#39;non_sgnf_sgnt&#39;] contains the list of</span>
<span class="sd">                non-significant signature for the significance level alpha.</span>
<span class="sd">            If n_surr&gt;0:</span>
<span class="sd">                output[&#39;pvalue_spectrum&#39;] contains a tuple of signatures and</span>
<span class="sd">                the corresponding p-value.</span>

<span class="sd">    If output_format is &#39;patterns&#39;:</span>
<span class="sd">        output: list</span>
<span class="sd">            List of dictionaries. Each dictionary corresponds to a patterns and</span>
<span class="sd">            has the following keys:</span>
<span class="sd">                neurons: array containing the indices of the neurons of the</span>
<span class="sd">                    pattern.</span>
<span class="sd">                lags: array containing the lags (integers corresponding to the</span>
<span class="sd">                    number of bins) between the spikes of the patterns. The</span>
<span class="sd">                    first lag is always assumed to be 0 and correspond to the</span>
<span class="sd">                    first spike [&#39;times&#39;] array containing the times.</span>
<span class="sd">            (integers corresponding to the bin idx) of the occurrences of the</span>
<span class="sd">            patterns</span>
<span class="sd">                signature: tuple containing two integers:</span>
<span class="sd">                    (number of spikes of the patterns,</span>
<span class="sd">                    number of occurrences of the pattern)</span>
<span class="sd">            pvalue: the p-value corresponding to the pattern. If n_surr==0 the</span>
<span class="sd">                p-values are set to 0.0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If detected, this function will utilize MPI to parallelize the analysis.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    The following applies SPADE to a list of spike trains in data. These calls</span>
<span class="sd">    do not include the statistical testing (for details see the documentation</span>
<span class="sd">    of spade.spade())</span>

<span class="sd">    &gt;&gt;&gt; import elephant.spade</span>
<span class="sd">    &gt;&gt;&gt; import quantities as pq</span>
<span class="sd">    &gt;&gt;&gt; binsize = 3 * pq.ms # time resolution used to discretize the data</span>
<span class="sd">    &gt;&gt;&gt; winlen = 10 # maximal pattern length in bins (i.e., sliding window)</span>
<span class="sd">    &gt;&gt;&gt; result_spade = spade.spade(data, binsize, winlen)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Torre, E., Picado-Muino, D., Denker, M., Borgelt, C., &amp; Gruen, S.(2013)</span>
<span class="sd">     Statistical evaluation of synchronous spike patterns extracted by</span>
<span class="sd">     frequent item set mining. Frontiers in Computational Neuroscience, 7.</span>
<span class="sd">    [2] Quaglio, P., Yegenoglu, A., Torre, E., Endres, D. M., &amp; Gruen, S.(2017)</span>
<span class="sd">     Detection and Evaluation of Spatio-Temporal Spike Patterns in Massively</span>
<span class="sd">     Parallel Spike Train Data with SPADE.</span>
<span class="sd">    Frontiers in Computational Neuroscience, 11.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">HAVE_MPI</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>   <span class="c1"># create MPI communicator</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>  <span class="c1"># get rank of current MPI task</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">time_mining</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Decide if compute the approximated stability</span>
    <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Mine the data for extraction of concepts</span>
        <span class="n">concepts</span><span class="p">,</span> <span class="n">rel_matrix</span> <span class="o">=</span> <span class="n">concepts_mining</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span>
                                               <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                                               <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span>
                                               <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span>
                                               <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">time_mining</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_mining</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for data mining: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_mining</span><span class="p">))</span>
        <span class="c1"># Computing the approximated stability of all the concepts</span>
        <span class="n">time_stability</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">concepts</span> <span class="o">=</span> <span class="n">approximate_stability</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">,</span> <span class="n">n_subsets</span><span class="p">,</span>
                                         <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">time_stability</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_stability</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for stability computation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_stability</span><span class="p">))</span>
        <span class="c1"># Filtering the concepts using stability thresholds</span>
        <span class="k">if</span> <span class="n">stability_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">concepts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">_stability_filter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stability_thresh</span><span class="p">),</span> <span class="n">concepts</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">stability_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stability_thresh not None but stability has not been &#39;</span>
                      <span class="s1">&#39;computed (n_subsets==0)&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Mine the data for extraction of concepts</span>
        <span class="n">concepts</span><span class="p">,</span> <span class="n">rel_matrix</span> <span class="o">=</span> <span class="n">concepts_mining</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span>
                                               <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                                               <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span>
                                               <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span>
                                               <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">time_mining</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_mining</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for data mining: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_mining</span><span class="p">))</span>
    <span class="c1"># Decide whether compute pvalue spectrum</span>
    <span class="k">if</span> <span class="n">n_surr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Compute pvalue spectrum</span>
        <span class="n">time_pvalue_spectrum</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">pv_spec</span> <span class="o">=</span> <span class="n">pvalue_spectrum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">dither</span><span class="o">=</span><span class="n">dither</span><span class="p">,</span>
                                  <span class="n">n_surr</span><span class="o">=</span><span class="n">n_surr</span><span class="p">,</span> <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                                  <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">)</span>
        <span class="n">time_pvalue_spectrum</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_pvalue_spectrum</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time for pvalue spectrum computation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">time_pvalue_spectrum</span><span class="p">))</span>
        <span class="c1"># Storing pvalue spectrum</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;pvalue_spectrum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv_spec</span>
    <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;0&lt;alpha&lt;1 but p-value spectrum has not been &#39;</span>
                      <span class="s1">&#39;computed (n_surr==0)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Decide whether filter concepts with psf</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_surr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pv_spec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ns_sgnt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Computing non-significant entries of the spectrum applying</span>
                <span class="c1"># the statistical correction</span>
                <span class="n">ns_sgnt</span> <span class="o">=</span> <span class="n">test_signature_significance</span><span class="p">(</span><span class="n">pv_spec</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                                      <span class="n">corr</span><span class="o">=</span><span class="n">stat_corr</span><span class="p">,</span>
                                                      <span class="n">report</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
            <span class="c1"># Storing non-significant entries of the pvalue spectrum</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;non_sgnf_sgnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns_sgnt</span>
            <span class="c1"># Filter concepts with pvalue spectrum (psf)</span>
            <span class="n">concepts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">_pattern_spectrum_filter</span><span class="p">(</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">ns_sgnt</span><span class="p">),</span> <span class="n">concepts</span><span class="p">))</span>
        <span class="c1"># Decide whether filter the concepts using psr</span>
        <span class="k">if</span> <span class="n">psr_param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Filter using conditional tests (psr)</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_surr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">concepts</span> <span class="o">=</span> <span class="n">pattern_set_reduction</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">ns_sgnt</span><span class="p">,</span>
                                                 <span class="n">winlen</span><span class="o">=</span><span class="n">winlen</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">k</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                 <span class="n">l</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                 <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                                                 <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">concepts</span> <span class="o">=</span> <span class="n">pattern_set_reduction</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="p">[],</span> <span class="n">winlen</span><span class="o">=</span><span class="n">winlen</span><span class="p">,</span>
                                                 <span class="n">h</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">k</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                 <span class="n">l</span><span class="o">=</span><span class="n">psr_param</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                 <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                                                 <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">)</span>
        <span class="c1"># Storing patterns</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;patterns&#39;</span><span class="p">:</span>
            <span class="c1"># If the p-value spectra was not computed, is set to an empty list</span>
            <span class="k">if</span> <span class="n">n_surr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pv_spec</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Transfroming concepts to dictionary containing pattern infos</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;patterns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">concept_output_to_patterns</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span>
                                                            <span class="n">winlen</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span>
                                                            <span class="n">pv_spec</span><span class="p">,</span>
                                                            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;patterns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">concepts</span>
        <span class="k">return</span> <span class="n">output</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="concepts_mining"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.concepts_mining">[docs]</a><span class="k">def</span> <span class="nf">concepts_mining</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">min_spikes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_occ</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">max_spikes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_occ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find pattern candidates extracting all the concepts of the context formed</span>
<span class="sd">    by the objects defined as all windows of length winlen*binsize slided</span>
<span class="sd">    along the data and the attributes as the spikes occurring in each of the</span>
<span class="sd">    window discretized at a time resolution equal to binsize. Hence, the output</span>
<span class="sd">    are all the repeated sequences of spikes with maximal length winlen, which</span>
<span class="sd">    are not trivially explained by the same number of occurrences of a superset</span>
<span class="sd">    of spikes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: list of neo.SpikeTrains</span>
<span class="sd">        List containing the parallel spike trains to analyze</span>
<span class="sd">    binsize: Quantity</span>
<span class="sd">        The time precision used to discretize the data (binning).</span>
<span class="sd">    winlen: int (positive)</span>
<span class="sd">        The size (number of bins) of the sliding window used for the analysis.</span>
<span class="sd">        The maximal length of a pattern (delay between first and last spike) is</span>
<span class="sd">        then given by winlen*binsize</span>
<span class="sd">    min_spikes: int (positive)</span>
<span class="sd">        Minimum number of spikes of a sequence to be considered a pattern.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_occ: int (positive)</span>
<span class="sd">        Minimum number of occurrences of a sequence to be considered as a</span>
<span class="sd">        pattern.</span>
<span class="sd">       Default: 2</span>
<span class="sd">    max_spikes: int (positive)</span>
<span class="sd">        Maximum number of spikes of a sequence to be considered a pattern. If</span>
<span class="sd">        None no maximal number of spikes is considered.</span>
<span class="sd">        Default: None</span>
<span class="sd">    max_occ: int (positive)</span>
<span class="sd">        Maximum number of occurrences of a sequence to be considered as a</span>
<span class="sd">        pattern. If None, no maximal number of occurrences is considered.</span>
<span class="sd">        Default: None</span>
<span class="sd">    min_neu: int (positive)</span>
<span class="sd">        Minimum number of neurons in a sequence to considered a pattern.</span>
<span class="sd">        Default: 1</span>
<span class="sd">    report: str</span>
<span class="sd">        Indicates the output of the function.</span>
<span class="sd">        &#39;a&#39;: all the mined patterns</span>
<span class="sd">        &#39;#&#39;: pattern spectrum</span>
<span class="sd">        Default: &#39;a&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mining_results: list</span>
<span class="sd">        If report == &#39;a&#39;:</span>
<span class="sd">            All the pattern candidates (concepts) found in the data. Each</span>
<span class="sd">            pattern is represented as a tuple containing</span>
<span class="sd">                (spike IDs, discrete times (window position)</span>
<span class="sd">            of the  occurrences of the pattern). The spike IDs are defined as:</span>
<span class="sd">            spike_id=neuron_id*bin_id; with neuron_id in [0, len(data)] and</span>
<span class="sd">            bin_id in [0, winlen].</span>
<span class="sd">        If report == &#39;#&#39;:</span>
<span class="sd">             The pattern spectrum is represented as a list of triplets each</span>
<span class="sd">             formed by:</span>
<span class="sd">                 (pattern size, number of occurrences, number of patterns)</span>
<span class="sd">    rel_matrix : numpy.array</span>
<span class="sd">        A binary matrix with shape (number of windows, winlen*len(data)). Each</span>
<span class="sd">        row corresponds to a window (order according to their position in</span>
<span class="sd">        time). Each column correspond to one bin and one neuron and it is 0 if</span>
<span class="sd">        no spikes or 1 if one or more spikes occurred in that bin for that</span>
<span class="sd">        particular neuron. For example, the entry [0,0] of this matrix</span>
<span class="sd">        corresponds to the first bin of the first window position for the first</span>
<span class="sd">        neuron, the entry [0,winlen] to the first bin of the first window</span>
<span class="sd">        position for the second neuron.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># If data is a list of SpikeTrains</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">neo</span><span class="o">.</span><span class="n">SpikeTrain</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data must be either a list of SpikeTrains&#39;</span><span class="p">)</span>
    <span class="c1"># Check taht all spiketrains have same t_start and same t_stop</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">st</span><span class="o">.</span><span class="n">t_start</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t_start</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">st</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t_stop</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s1">&#39;All spiketrains must have the same t_start and t_stop&#39;</span><span class="p">)</span>
    <span class="c1"># Binning the data and clipping (binary matrix)</span>
    <span class="n">binary_matrix</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">)</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">()</span>
    <span class="c1"># Computing the context and the binary matrix encoding the relation between</span>
    <span class="c1"># objects (window positions) and attributes (spikes,</span>
    <span class="c1"># indexed with a number equal to  neuron idx*winlen+bin idx)</span>
    <span class="n">context</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span> <span class="n">rel_matrix</span> <span class="o">=</span> <span class="n">_build_context</span><span class="p">(</span><span class="n">binary_matrix</span><span class="p">,</span> <span class="n">winlen</span><span class="p">)</span>
    <span class="c1"># By default, set the maximum pattern size to the maximum number of</span>
    <span class="c1"># spikes in a window</span>
    <span class="k">if</span> <span class="n">max_spikes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rel_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))),</span>
                            <span class="n">min_spikes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># By default, set maximum number of occurrences to number of non-empty</span>
    <span class="c1"># windows</span>
    <span class="k">if</span> <span class="n">max_occ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_occ</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rel_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Check if fim.so available and use it</span>
    <span class="k">if</span> <span class="n">HAVE_FIM</span><span class="p">:</span>
        <span class="c1"># Return the output</span>
        <span class="n">mining_results</span> <span class="o">=</span> <span class="n">_fpgrowth</span><span class="p">(</span>
            <span class="n">transactions</span><span class="p">,</span>
            <span class="n">rel_matrix</span><span class="o">=</span><span class="n">rel_matrix</span><span class="p">,</span>
            <span class="n">min_c</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span>
            <span class="n">min_z</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
            <span class="n">max_z</span><span class="o">=</span><span class="n">max_spikes</span><span class="p">,</span>
            <span class="n">max_c</span><span class="o">=</span><span class="n">max_occ</span><span class="p">,</span>
            <span class="n">winlen</span><span class="o">=</span><span class="n">winlen</span><span class="p">,</span>
            <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span>
            <span class="n">report</span><span class="o">=</span><span class="n">report</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mining_results</span><span class="p">,</span> <span class="n">rel_matrix</span>
    <span class="c1"># Otherwise use fast_fca python implementation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return output</span>
        <span class="n">mining_results</span> <span class="o">=</span> <span class="n">_fast_fca</span><span class="p">(</span>
            <span class="n">context</span><span class="p">,</span>
            <span class="n">min_c</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span>
            <span class="n">min_z</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
            <span class="n">max_z</span><span class="o">=</span><span class="n">max_spikes</span><span class="p">,</span>
            <span class="n">max_c</span><span class="o">=</span><span class="n">max_occ</span><span class="p">,</span>
            <span class="n">winlen</span><span class="o">=</span><span class="n">winlen</span><span class="p">,</span>
            <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span>
            <span class="n">report</span><span class="o">=</span><span class="n">report</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mining_results</span><span class="p">,</span> <span class="n">rel_matrix</span></div>


<span class="k">def</span> <span class="nf">_build_context</span><span class="p">(</span><span class="n">binary_matrix</span><span class="p">,</span> <span class="n">winlen</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Building the context given a matrix (number of trains x number of bins) of</span>
<span class="sd">    binned spike trains</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binary_matrix : numpy.array</span>
<span class="sd">        Binary matrix containing the binned spike trais</span>
<span class="sd">    winlen : int</span>
<span class="sd">        Length of the binsize used to bin the data</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    context : list</span>
<span class="sd">        List of tuples containing one object (window position idx) and one of</span>
<span class="sd">        the correspondent spikes idx (bin idx * neuron idx)</span>
<span class="sd">    transactions : list</span>
<span class="sd">        List of all transactions, each element of the list contains the</span>
<span class="sd">        attributes of the corresponding object.</span>
<span class="sd">    rel_matrix : numpy.array</span>
<span class="sd">        A binary matrix with shape (number of windows, winlen*len(data)). Each</span>
<span class="sd">        row correspond to a window (order according to their position in time).</span>
<span class="sd">        Each column correspond to one bin and one neuron and it is 0 if no</span>
<span class="sd">        spikes or 1 if one or more spikes occurred in that bin for that</span>
<span class="sd">        particular neuron.</span>
<span class="sd">        E.g. the entry [0,0] of this matrix correspond to the first bin of the</span>
<span class="sd">        first window position for the first neuron, the entry [0,winlen] to the</span>
<span class="sd">        first bin of the first window position for the second neuron.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialization of the outputs</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transactions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Shape of the rel_matrix:</span>
    <span class="c1"># (num of window positions, num of bins in one window * number of neurons)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">binary_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">winlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">binary_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">winlen</span><span class="p">)</span>
    <span class="n">rel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Array containing all the possible attributes (each spikes is indexed by</span>
    <span class="c1"># a number equal to neu idx*winlen + bin_idx)</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">s</span> <span class="o">*</span> <span class="n">winlen</span> <span class="o">+</span> <span class="n">t</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">binary_matrix</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">winlen</span><span class="p">)])</span>
    <span class="c1"># Building context and rel_matrix</span>
    <span class="c1"># Looping all the window positions w</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">binary_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">winlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># spikes in the current window</span>
        <span class="n">current_window</span> <span class="o">=</span> <span class="n">binary_matrix</span><span class="p">[:,</span> <span class="n">w</span><span class="p">:</span><span class="n">w</span> <span class="o">+</span> <span class="n">winlen</span><span class="p">]</span>
        <span class="c1"># only keep windows that start with a spike</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">current_window</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># concatenating horizzontally the boolean arrays of spikes</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">current_window</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># adding to the context the window positions and the correspondent</span>
        <span class="c1"># attributes (spike idx) (fast_fca input)</span>
        <span class="n">context</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">[</span><span class="n">times</span><span class="p">]]</span>
        <span class="c1"># placing in the w row of the rel matrix the boolen array of spikes</span>
        <span class="n">rel_matrix</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">times</span>
        <span class="c1"># appending to the transactions spike idx (fast_fca input) of the</span>
        <span class="c1"># current window (fpgrowth input)</span>
        <span class="n">transactions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="n">times</span><span class="p">]))</span>
    <span class="c1"># Return context and rel_matrix</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span> <span class="n">rel_matrix</span>


<span class="k">def</span> <span class="nf">_fpgrowth</span><span class="p">(</span><span class="n">transactions</span><span class="p">,</span> <span class="n">min_c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_z</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">max_c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">winlen</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
              <span class="n">target</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find frequent item sets with the fpgrowth algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transactions: tuple</span>
<span class="sd">                Transactions database to mine.</span>
<span class="sd">                The database must be an iterable of transactions;</span>
<span class="sd">                each transaction must be an iterable of items;</span>
<span class="sd">                each item must be a hashable object.</span>
<span class="sd">                If the database is a dictionary, the transactions are</span>
<span class="sd">                the keys, the values their (integer) multiplicities.</span>
<span class="sd">    target: str</span>
<span class="sd">            type of frequent item sets to find</span>
<span class="sd">            s/a   sets/all   all     frequent item sets</span>
<span class="sd">            c     closed     closed  frequent item sets</span>
<span class="sd">            m     maximal    maximal frequent item sets</span>
<span class="sd">            g     gens       generators</span>
<span class="sd">            Default:&#39;c&#39;</span>
<span class="sd">    min_c: int</span>
<span class="sd">        minimum support of an item set</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_z: int</span>
<span class="sd">         minimum number of items per item set</span>
<span class="sd">        Default: 2</span>
<span class="sd">    max_z: None/int</span>
<span class="sd">         maximum number of items per item set. If max_c==None no maximal</span>
<span class="sd">         size required</span>
<span class="sd">        Default: None</span>
<span class="sd">    max_c: None/int</span>
<span class="sd">         maximum support per item set. If max_c==None no maximal</span>
<span class="sd">         support required</span>
<span class="sd">        Default: None</span>
<span class="sd">    report: str</span>
<span class="sd">        values to report with an item set      (default: a)</span>
<span class="sd">            a     absolute item set support (number of transactions)</span>
<span class="sd">            s     relative item set support as a fraction</span>
<span class="sd">            S     relative item set support as a percentage</span>
<span class="sd">            e     value of item set evaluation measure</span>
<span class="sd">            E     value of item set evaluation measure as a percentage</span>
<span class="sd">            #     pattern spectrum instead of full pattern set</span>
<span class="sd">    rel_matrix : None or numpy.array</span>
<span class="sd">        A binary matrix with shape (number of windows, winlen*len(data)). Each</span>
<span class="sd">        row correspond to a window (order according to their position in time).</span>
<span class="sd">        Each column correspond to one bin and one neuron and it is 0 if no</span>
<span class="sd">        spikes or 1 if one or more spikes occurred in that bin for that</span>
<span class="sd">        particular neuron.</span>
<span class="sd">        E.g. the entry [0,0] of this matrix correspond to the first bin of the</span>
<span class="sd">        first window position for the first neuron, the entry [0,winlen] to the</span>
<span class="sd">        first bin of the first window position for the second neuron.</span>
<span class="sd">        If == None only the closed frequent itemsets (intent) are returned and</span>
<span class="sd">        not which the index of their occurrences (extent)</span>
<span class="sd">        Default: None</span>
<span class="sd">    The following parameters are specific to Massive parallel SpikeTrains</span>
<span class="sd">    winlen: int (positive)</span>
<span class="sd">        The size (number of bins) of the sliding window used for the</span>
<span class="sd">        analysis. The maximal length of a pattern (delay between first and</span>
<span class="sd">        last spike) is then given by winlen*binsize</span>
<span class="sd">        Deafault: 1</span>
<span class="sd">    min_neu: int (positive)</span>
<span class="sd">         Minimum number of neurons in a sequence to considered a</span>
<span class="sd">         potential pattern.</span>
<span class="sd">         Default: 1</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    returns:</span>
<span class="sd">    * If report != &#39;#&#39;:</span>
<span class="sd">        concepts: list</span>
<span class="sd">        List of pairs (i.e. tuples with two elements),</span>
<span class="sd">        each consisting of a tuple with a found frequent item set</span>
<span class="sd">        and a tuple listing the values selected with &#39;report&#39;</span>
<span class="sd">    * If report == &#39;#&#39;:</span>
<span class="sd">        spectrum: list</span>
<span class="sd">        List of triplets (size,supp,frq), i.e. a pattern spectrum.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># By default, set the maximum pattern size to the number of spiketrains</span>
    <span class="k">if</span> <span class="n">max_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">transactions</span><span class="p">]),</span> <span class="n">min_z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># By default set maximum number of data to number of bins</span>
    <span class="k">if</span> <span class="n">max_c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transactions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_neu</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_neu</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;min_neu must be an integer &gt;=1&#39;</span><span class="p">)</span>
        <span class="c1"># Inizializing outputs</span>
        <span class="n">concepts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spec_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_z</span><span class="p">,</span> <span class="n">max_c</span><span class="p">))</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Mining the data with fpgrowth algorithm</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">transactions</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">transactions</span><span class="p">):</span>
            <span class="n">fpgrowth_output</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">transactions</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">transactions</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fpgrowth_output</span> <span class="o">=</span> <span class="n">fim</span><span class="o">.</span><span class="n">fpgrowth</span><span class="p">(</span>
                <span class="n">tracts</span><span class="o">=</span><span class="n">transactions</span><span class="p">,</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">supp</span><span class="o">=-</span><span class="n">min_c</span><span class="p">,</span>
                <span class="n">zmin</span><span class="o">=</span><span class="n">min_z</span><span class="p">,</span>
                <span class="n">zmax</span><span class="o">=</span><span class="n">max_z</span><span class="p">,</span>
                <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span>
                <span class="n">algo</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
        <span class="c1"># Applying min/max conditions and computing extent (window positions)</span>
        <span class="n">fpgrowth_output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">_fpgrowth_filter</span><span class="p">(</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">max_c</span><span class="p">,</span> <span class="n">min_neu</span><span class="p">),</span> <span class="n">fpgrowth_output</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">supp</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fpgrowth_output</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rel_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rel_matrix</span><span class="p">[:,</span> <span class="n">intent</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">concepts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">extent</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
                <span class="n">spec_matrix</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">supp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="n">fpgrowth_output</span>
        <span class="c1"># Computing spectrum</span>
        <span class="k">if</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">concepts</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spec_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="n">spectrum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec_matrix</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">])))</span>
            <span class="k">del</span> <span class="n">spec_matrix</span>
            <span class="k">return</span> <span class="n">spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concepts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;min_neu must be an integer &gt;=1&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fpgrowth_filter</span><span class="p">(</span><span class="n">concept</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">max_c</span><span class="p">,</span> <span class="n">min_neu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter for selecting closed frequent items set with a minimum number of</span>
<span class="sd">    neurons and a maximum number of occurrences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keep_concepts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">concept</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">//</span> <span class="n">winlen</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">min_neu</span> <span class="ow">and</span> <span class="n">concept</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_c</span>
    <span class="k">return</span> <span class="n">keep_concepts</span>


<span class="k">def</span> <span class="nf">_fast_fca</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">min_c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_z</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">max_c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">winlen</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find concepts of the context with the fast-fca algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    context : list</span>
<span class="sd">        List of tuples containing one object and one the correspondent</span>
<span class="sd">        attribute</span>
<span class="sd">    min_c: int</span>
<span class="sd">        minimum support of an item set</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_z: int</span>
<span class="sd">         minimum number of items per item set</span>
<span class="sd">        Default: 2</span>
<span class="sd">    max_z: None/int</span>
<span class="sd">         maximum number of items per item set. If max_c==None no maximal</span>
<span class="sd">         size required</span>
<span class="sd">        Default: None</span>
<span class="sd">    max_c: None/int</span>
<span class="sd">         maximum support per item set. If max_c==None no maximal</span>
<span class="sd">         support required</span>
<span class="sd">        Default: None</span>
<span class="sd">    report: str</span>
<span class="sd">        values to report with an item set      (default: a)</span>
<span class="sd">            a     absolute item set support (number of transactions)</span>
<span class="sd">            #     pattern spectrum instead of full pattern set</span>
<span class="sd">    The following parameters are specific to Massive parallel SpikeTrains</span>
<span class="sd">    winlen: int (positive)</span>
<span class="sd">        The size (number of bins) of the sliding window used for the</span>
<span class="sd">        analysis. The maximal length of a pattern (delay between first and</span>
<span class="sd">        last spike) is then given by winlen*binsize</span>
<span class="sd">        Deafault: 1</span>
<span class="sd">    min_neu: int (positive)</span>
<span class="sd">         Minimum number of neurons in a sequence to considered a</span>
<span class="sd">         potential pattern.</span>
<span class="sd">         Default: 1</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    returns:</span>
<span class="sd">    * If report != &#39;#&#39;:</span>
<span class="sd">        concepts: list</span>
<span class="sd">        List of pairs (i.e. tuples with two elements),</span>
<span class="sd">        each consisting of a tuple with a found frequent item set</span>
<span class="sd">        and a tuple listing the values selected with &#39;report&#39;</span>
<span class="sd">    * If report == &#39;#&#39;:</span>
<span class="sd">        spectrum: list</span>
<span class="sd">        List of triplets (size,supp,frq), i.e. a pattern spectrum.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Initializing outputs</span>
    <span class="n">concepts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Check parameters</span>
    <span class="k">if</span> <span class="n">min_neu</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;min_neu must be an integer &gt;=1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_z</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># By default set maximum number of data to number of bins</span>
    <span class="k">if</span> <span class="n">max_c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">spec_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_z</span><span class="p">,</span> <span class="n">max_c</span><span class="p">))</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Mining the data with fast fca algorithm</span>
    <span class="n">fca_out</span> <span class="o">=</span> <span class="n">fast_fca</span><span class="o">.</span><span class="n">formalConcepts</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">fca_out</span><span class="o">.</span><span class="n">computeLattice</span><span class="p">()</span>
    <span class="n">fca_concepts</span> <span class="o">=</span> <span class="n">fca_out</span><span class="o">.</span><span class="n">concepts</span>
    <span class="n">fca_concepts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">_fca_filter</span><span class="p">(</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">min_c</span><span class="p">,</span> <span class="n">min_z</span><span class="p">,</span> <span class="n">max_c</span><span class="p">,</span> <span class="n">max_z</span><span class="p">,</span> <span class="n">min_neu</span><span class="p">),</span> <span class="n">fca_concepts</span><span class="p">))</span>
    <span class="c1"># Applying min/max conditions</span>
    <span class="k">for</span> <span class="n">fca_concept</span> <span class="ow">in</span> <span class="n">fca_concepts</span><span class="p">:</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fca_concept</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fca_concept</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span>
        <span class="n">concepts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">extent</span><span class="p">))</span>
        <span class="c1"># computing spectrum</span>
        <span class="k">if</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">spec_matrix</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">report</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concepts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># returning spectrum</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spec_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec_matrix</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">spectrum</span>


<span class="k">def</span> <span class="nf">_fca_filter</span><span class="p">(</span><span class="n">concept</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">min_c</span><span class="p">,</span> <span class="n">min_z</span><span class="p">,</span> <span class="n">max_c</span><span class="p">,</span> <span class="n">max_z</span><span class="p">,</span> <span class="n">min_neu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter to select concepts with minimum/maximum number of spikes and</span>
<span class="sd">    occurrences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">concept</span><span class="o">.</span><span class="n">intent</span><span class="p">)</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">concept</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span>
    <span class="n">keep_concepts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_z</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_c</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">intent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_z</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_c</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">//</span> <span class="n">winlen</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">min_neu</span>
    <span class="k">return</span> <span class="n">keep_concepts</span>


<div class="viewcode-block" id="pvalue_spectrum"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.pvalue_spectrum">[docs]</a><span class="k">def</span> <span class="nf">pvalue_spectrum</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">dither</span><span class="p">,</span> <span class="n">n_surr</span><span class="p">,</span>
        <span class="n">min_spikes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_occ</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the p-value spectrum of pattern signatures extracted from</span>
<span class="sd">    surrogates of parallel spike trains, under the null hypothesis of</span>
<span class="sd">    independent spiking.</span>

<span class="sd">    * n_surr surrogates are obtained from each spike train by spike dithering</span>
<span class="sd">    * pattern candidates (concepts) are collected from each surrogate data</span>
<span class="sd">    * the signatures (number of spikes, number of occurrences) of all patterns</span>
<span class="sd">      are computed, and their  occurrence probability estimated by their</span>
<span class="sd">      occurrence frequency (p-value spectrum)</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: list of neo.SpikeTrains</span>
<span class="sd">        List containing the parallel spike trains to analyze</span>
<span class="sd">    binsize: Quantity</span>
<span class="sd">        The time precision used to discretize the data (binning).</span>
<span class="sd">    winlen: int (positive)</span>
<span class="sd">        The size (number of bins) of the sliding window used for the analysis.</span>
<span class="sd">        The maximal length of a pattern (delay between first and last spike) is</span>
<span class="sd">        then given by winlen*binsize</span>
<span class="sd">    dither: Quantity</span>
<span class="sd">        Amount of spike time dithering for creating the surrogates for</span>
<span class="sd">        filtering the pattern spectrum. A spike at time t is placed randomly</span>
<span class="sd">        within ]t-dither, t+dither[ (see also</span>
<span class="sd">        elephant.spike_train_surrogates.dither_spikes).</span>
<span class="sd">        Default: 15*pq.s</span>
<span class="sd">    n_surr: int</span>
<span class="sd">        Number of surrogates to generate to compute the p-value spectrum.</span>
<span class="sd">        This number should be large (n_surr&gt;=1000 is recommended for 100</span>
<span class="sd">        spike trains in *sts*). If n_surr is 0, then the p-value spectrum is</span>
<span class="sd">        not computed.</span>
<span class="sd">        Default: 0</span>
<span class="sd">    min_spikes: int (positive)</span>
<span class="sd">        Minimum number of spikes of a sequence to be considered a pattern.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_occ: int (positive)</span>
<span class="sd">       Minimum number of occurrences of a sequence to be considered as a</span>
<span class="sd">       pattern.</span>
<span class="sd">       Default: 2</span>
<span class="sd">    min_neu: int (positive)</span>
<span class="sd">        Minimum number of neurons in a sequence to considered a pattern.</span>
<span class="sd">        Default: 1</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    spectrum: list</span>
<span class="sd">        A list of triplets (z,c,p), where (z,c) is a pattern signature and p is</span>
<span class="sd">        the corresponding p-value (fraction of surrogates containing signatures</span>
<span class="sd">        (z*,c*)&gt;=(z,c)). Signatures whose empirical p-value is 0 are not</span>
<span class="sd">        listed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Initializing variables for parallel computing</span>
    <span class="k">if</span> <span class="n">HAVE_MPI</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>   <span class="c1"># create MPI communicator</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>  <span class="c1"># get rank of current MPI task</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>  <span class="c1"># get tot number of MPI tasks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Check on number of surrogates</span>
    <span class="k">if</span> <span class="n">n_surr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;n_surr has to be &gt;0&#39;</span><span class="p">)</span>
    <span class="n">len_partition</span> <span class="o">=</span> <span class="n">n_surr</span> <span class="o">//</span> <span class="n">size</span>  <span class="c1"># length of each MPI task</span>
    <span class="n">len_remainder</span> <span class="o">=</span> <span class="n">n_surr</span> <span class="k">if</span> <span class="n">len_partition</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n_surr</span> <span class="o">%</span> <span class="n">len_partition</span>

    <span class="c1"># For each surrogate collect the signatures (z,c) such that (z*,c*)&gt;=(z,c)</span>
    <span class="c1"># exists in that surrogate. Group such signatures (with repetition)</span>
    <span class="c1"># list of all signatures found in surrogates, initialized to []</span>
    <span class="n">surr_sgnts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_partition</span> <span class="o">+</span> <span class="n">len_remainder</span><span class="p">):</span>
            <span class="n">surrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">surr</span><span class="o">.</span><span class="n">dither_spikes</span><span class="p">(</span>
                <span class="n">xx</span><span class="p">,</span> <span class="n">dither</span><span class="o">=</span><span class="n">dither</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

            <span class="c1"># Find all pattern signatures in the current surrogate data set</span>
            <span class="n">surr_sgnt</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span>
                 <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span>
                    <span class="n">a</span><span class="p">,</span>
                    <span class="n">b</span><span class="p">,</span>
                    <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">concepts_mining</span><span class="p">(</span>
                    <span class="n">surrs</span><span class="p">,</span>
                    <span class="n">binsize</span><span class="p">,</span>
                    <span class="n">winlen</span><span class="p">,</span>
                    <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                    <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span>
                    <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span>
                    <span class="n">report</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># List all signatures (z,c) &lt;= (z*, c*), for each (z*,c*) in the</span>
            <span class="c1"># current surrogate, and add it to the list of all signatures</span>
            <span class="n">filled_sgnt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">surr_sgnt</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_spikes</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_occ</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">filled_sgnt</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">surr_sgnts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filled_sgnt</span><span class="p">)))</span>
    <span class="c1"># Same procedure on different PCU</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_partition</span><span class="p">):</span>
            <span class="n">surrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">surr</span><span class="o">.</span><span class="n">dither_spikes</span><span class="p">(</span>
                <span class="n">xx</span><span class="p">,</span> <span class="n">dither</span><span class="o">=</span><span class="n">dither</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
            <span class="c1"># Find all pattern signatures in the current surrogate data set</span>
            <span class="n">surr_sgnt</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">concepts_mining</span><span class="p">(</span>
                    <span class="n">surrs</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">min_spikes</span><span class="o">=</span><span class="n">min_spikes</span><span class="p">,</span>
                    <span class="n">min_occ</span><span class="o">=</span><span class="n">min_occ</span><span class="p">,</span> <span class="n">min_neu</span><span class="o">=</span><span class="n">min_neu</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># List all signatures (z,c) &lt;= (z*, c*), for each (z*,c*) in the</span>
            <span class="c1"># current surrogate, and add it to the list of all signatures</span>
            <span class="n">filled_sgnt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">surr_sgnt</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_spikes</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_occ</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">filled_sgnt</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">surr_sgnts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filled_sgnt</span><span class="p">)))</span>
    <span class="c1"># Collecting results on the first PCU</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">surr_sgnts</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">surr_sgnts</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">recv_list</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="n">surr_sgnts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">recv_list</span><span class="p">)</span>

        <span class="c1"># Compute the p-value spectrum, and return it</span>
        <span class="n">pv_spec</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">surr_sgnts</span><span class="p">:</span>
            <span class="n">pv_spec</span><span class="p">[(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">surr_sgnts</span><span class="p">:</span>
            <span class="n">pv_spec</span><span class="p">[(</span><span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_surr</span>
        <span class="n">pv_spec</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">pv_spec</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">pv_spec</span></div>


<span class="k">def</span> <span class="nf">_stability_filter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">stab_thr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Criteria by which to filter concepts from the lattice&quot;&quot;&quot;</span>
    <span class="c1"># stabilities larger then min_st</span>
    <span class="n">keep_concept</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stab_thr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stab_thr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">keep_concept</span>


<span class="k">def</span> <span class="nf">_fdr</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    performs False Discovery Rate (FDR) statistical correction on a list of</span>
<span class="sd">    p-values, and assesses accordingly which of the associated statistical</span>
<span class="sd">    tests is significant at the desired level *alpha*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pvalues: list</span>
<span class="sd">        list of p-values, each corresponding to a statistical test</span>
<span class="sd">    alpha: float</span>
<span class="sd">        significance level (desired FDR-ratio)</span>

<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    Returns a triplet containing:</span>
<span class="sd">    * an array of bool, indicating for each p-value whether it was</span>
<span class="sd">      significantly low or not</span>
<span class="sd">    * the largest p-value that was below the FDR linear threshold</span>
<span class="sd">      (effective confidence level). That and each lower p-value are</span>
<span class="sd">      considered significant.</span>
<span class="sd">    * the rank of the largest significant p-value</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Sort the p-values from largest to smallest</span>
    <span class="n">pvs_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvalues</span><span class="p">)</span>              <span class="c1"># Convert PVs to an array</span>
    <span class="n">pvs_sorted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pvs_array</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Sort PVs in decreasing order</span>

    <span class="c1"># Perform FDR on the sorrted p-values</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvalues</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>    <span class="c1"># Whether the loop stopped due to a significant p-value.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pvs_sorted</span><span class="p">):</span>  <span class="c1"># For each PV, from the largest on</span>
        <span class="k">if</span> <span class="n">pv</span> <span class="o">&gt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">((</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">m</span><span class="p">):</span>  <span class="c1"># continue if PV &gt; fdr-threshold</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>                          <span class="c1"># otherwise stop</span>

    <span class="n">thresh</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">((</span><span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stop</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Return outcome of the test, critical p-value and its order</span>
    <span class="k">return</span> <span class="n">pvalues</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stop</span>


<div class="viewcode-block" id="test_signature_significance"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.test_signature_significance">[docs]</a><span class="k">def</span> <span class="nf">test_signature_significance</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">report</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the significance spectrum of a pattern spectrum.</span>

<span class="sd">    Given pvalue_spectrum as a list of triplets (z,c,p), where z is pattern</span>
<span class="sd">    size, c is pattern support and p is the p-value of the signature (z,c),</span>
<span class="sd">    this routine assesses the significance of (z,c) using the confidence level</span>
<span class="sd">    alpha.</span>

<span class="sd">    Bonferroni or FDR statistical corrections can be applied.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pvalue_spectrum: list</span>
<span class="sd">        A list of triplets (z,c,p), where z is pattern size, c is pattern</span>
<span class="sd">        support and p is the p-value of signature (z,c)</span>
<span class="sd">    alpha: float</span>
<span class="sd">        Significance level of the statistical test</span>
<span class="sd">    corr: str</span>
<span class="sd">        Statistical correction to be applied:</span>
<span class="sd">        &#39;&#39; : no statistical correction</span>
<span class="sd">        &#39;f&#39;|&#39;fdr&#39; : false discovery rate</span>
<span class="sd">        &#39;b&#39;|&#39;bonf&#39;: Bonferroni correction</span>
<span class="sd">         Default: &#39;&#39;</span>
<span class="sd">    report: str</span>
<span class="sd">        Format to be returned for the significance spectrum:</span>
<span class="sd">        &#39;#&#39;: list of triplets (z,c,b), where b is a boolean specifying</span>
<span class="sd">             whether signature (z,c) is significant (True) or not (False)</span>
<span class="sd">        &#39;s&#39;: list containing only the significant signatures (z,c) of</span>
<span class="sd">            pvalue_spectrum</span>
<span class="sd">        &#39;e&#39;: list containing only the non-significant signatures</span>
<span class="sd">        Defualt: &#39;#&#39;</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    sig_spectrum: list</span>
<span class="sd">        Significant signatures of pvalue_spectrum, in the format specified</span>
<span class="sd">        by report</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">)</span>
    <span class="c1"># Compute significance...</span>
    <span class="k">if</span> <span class="n">corr</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">corr</span> <span class="o">==</span> <span class="s1">&#39;no&#39;</span><span class="p">:</span>  <span class="c1"># ...without statistical correction</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">alpha</span>
    <span class="k">elif</span> <span class="n">corr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;bonf&#39;</span><span class="p">]:</span>  <span class="c1"># or with Bonferroni correction</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">corr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;fdr&#39;</span><span class="p">]:</span>  <span class="c1"># or with FDR correction</span>
        <span class="n">tests</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">_fdr</span><span class="p">(</span><span class="n">x_array</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;corr must be either &#39;&#39;, &#39;b&#39;(&#39;bonf&#39;) or &#39;f&#39;(&#39;fdr&#39;)&quot;</span><span class="p">)</span>

    <span class="c1"># Return the specified results:</span>
    <span class="k">if</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">pv</span><span class="p">),</span> <span class="n">test</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">,</span> <span class="n">tests</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">pv</span><span class="p">),</span> <span class="n">test</span><span class="p">)</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">,</span> <span class="n">tests</span><span class="p">)</span> <span class="k">if</span> <span class="n">test</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">report</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">pv</span><span class="p">),</span> <span class="n">test</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">pvalue_spectrum</span><span class="p">,</span> <span class="n">tests</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;report must be either &#39;#&#39; or &#39;s&#39;.&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_pattern_spectrum_filter</span><span class="p">(</span><span class="n">concept</span><span class="p">,</span> <span class="n">ns_signature</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Filter to select concept which signature is significant&#39;&#39;&#39;</span>
    <span class="n">keep_concept</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns_signature</span>
    <span class="k">return</span> <span class="n">keep_concept</span>


<div class="viewcode-block" id="approximate_stability"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.approximate_stability">[docs]</a><span class="k">def</span> <span class="nf">approximate_stability</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">,</span> <span class="n">n_subsets</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximate the stability of concepts. Uses the algorithm described</span>
<span class="sd">    in Babin, Kuznetsov (2012): Approximating Concept Stability</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    concepts: list</span>
<span class="sd">        All the pattern candidates (concepts) found in the data. Each</span>
<span class="sd">        pattern is represented as a tuple containing (spike IDs, </span>
<span class="sd">        discrete times (window position)</span>
<span class="sd">        of the  occurrences of the pattern). The spike IDs are defined as:</span>
<span class="sd">        spike_id=neuron_id*bin_id; with neuron_id in [0, len(data)] and</span>
<span class="sd">        bin_id in [0, winlen].</span>
<span class="sd">    rel_matrix: numpy.array</span>
<span class="sd">        A binary matrix with shape (number of windows, winlen*len(data)). Each</span>
<span class="sd">        row corresponds to a window (order according to their position in</span>
<span class="sd">        time). Each column correspond to one bin and one neuron and it is 0 if</span>
<span class="sd">        no spikes or 1 if one or more spikes occurred in that bin for that</span>
<span class="sd">        particular neuron. For example, the entry [0,0] of this matrix</span>
<span class="sd">        corresponds to the first bin of the first window position for the first</span>
<span class="sd">        neuron, the entry [0,winlen] to the first bin of the first window</span>
<span class="sd">        position for the second neuron.</span>
<span class="sd">    n_subsets: int</span>
<span class="sd">        Number of subsets of a concept used to approximate its stability. If</span>
<span class="sd">        n_subset is set to 0 the stability is not computed. If, however,</span>
<span class="sd">        for parameters delta and epsilon (see below) delta + epsilon == 0,</span>
<span class="sd">        then an optimal n_subsets is calculated according to the formula given</span>
<span class="sd">        in Babin, Kuznetsov (2012), proposition 6:</span>

<span class="sd">         ..math::</span>
<span class="sd">                n_subset = frac{1}{2\eps^2} \ln(frac{2}{\delta}) +1</span>

<span class="sd">        Default:0</span>
<span class="sd">    delta: float</span>
<span class="sd">        delta: probability with at least ..math:$1-\delta$</span>
<span class="sd">        Default: 0</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        epsilon: absolute error</span>
<span class="sd">        Default: 0</span>

<span class="sd">    Output</span>
<span class="sd">    ------</span>
<span class="sd">    output: list</span>
<span class="sd">        List of all the pattern candidates (concepts) given in input, each with </span>
<span class="sd">        the correspondent intensional and extensional stability. Each</span>
<span class="sd">        pattern is represented as a tuple containing:</span>
<span class="sd">         (spike IDs, </span>
<span class="sd">        discrete times of the  occurrences of the pattern, intensional </span>
<span class="sd">        stability of the pattern, extensional stability of the pattern). </span>
<span class="sd">        The spike IDs are defined as:</span>
<span class="sd">        spike_id=neuron_id*bin_id; with neuron_id in [0, len(data)] and</span>
<span class="sd">        bin_id in [0, winlen].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        If n_subset is larger than the extent all subsets are directly</span>
<span class="sd">        calculated, otherwise for small extent size an infinite</span>
<span class="sd">        loop can be created while doing the recursion,</span>
<span class="sd">        since the random generation will always contain the same</span>
<span class="sd">        numbers and the algorithm will be stuck searching for</span>
<span class="sd">        other (random) numbers</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">HAVE_MPI</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>   <span class="c1"># create MPI communicator</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>  <span class="c1"># get rank of current MPI task</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>  <span class="c1"># get tot number of MPI tasks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;n_subsets has to be &gt;=0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">rank_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rank_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="o">//</span> <span class="n">size</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">concepts</span><span class="p">)]</span>
    <span class="c1"># Calculate optimal n</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">epsilon</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_subsets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_subsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">concept</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">[</span>
                <span class="n">rank_idx</span><span class="p">[</span><span class="n">rank</span><span class="p">]:</span><span class="n">rank_idx</span><span class="p">[</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">concepts</span><span class="p">[</span>
                <span class="n">rank_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span><span class="n">rank_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="n">stab_ext</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">stab_int</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">intent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">r_unique_ext</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">r_unique_int</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">excluded_subset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Calculate all subsets if n is larger than the power set of</span>
            <span class="c1"># the extent</span>
            <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">):</span>
                <span class="n">subsets_ext</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">combinations</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsets_ext</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span> <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_extensional</span><span class="p">(</span>
                            <span class="n">intent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_ext</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">):</span>
                    <span class="n">subset_ext</span> <span class="o">=</span> <span class="n">extent</span><span class="p">[</span>
                        <span class="n">_give_random_idx</span><span class="p">(</span><span class="n">r_unique_ext</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">))]</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">subset_ext</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span>
                            <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_extensional</span><span class="p">(</span>
                            <span class="n">intent</span><span class="p">,</span> <span class="n">subset_ext</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_ext</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset_ext</span><span class="p">)</span>
            <span class="n">stab_ext</span> <span class="o">/=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">))</span>
            <span class="n">excluded_subset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Calculate all subsets if n is larger than the power set of</span>
            <span class="c1"># the extent</span>
            <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">):</span>
                <span class="n">subsets_int</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">combinations</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsets_int</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span> <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_intensional</span><span class="p">(</span>
                            <span class="n">extent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_int</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">):</span>
                    <span class="n">subset_int</span> <span class="o">=</span> <span class="n">intent</span><span class="p">[</span>
                        <span class="n">_give_random_idx</span><span class="p">(</span><span class="n">r_unique_int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">))]</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">subset_int</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span>
                            <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_intensional</span><span class="p">(</span>
                            <span class="n">extent</span><span class="p">,</span> <span class="n">subset_int</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_int</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset_int</span><span class="p">)</span>
            <span class="n">stab_int</span> <span class="o">/=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">))</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">stab_int</span><span class="p">,</span> <span class="n">stab_ext</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">for</span> <span class="n">concept</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">[</span><span class="n">rank_idx</span><span class="p">[</span><span class="n">rank</span><span class="p">]:</span><span class="n">rank_idx</span><span class="p">[</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]:</span>
            <span class="n">stab_ext</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">stab_int</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">intent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">concept</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">r_unique_ext</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">r_unique_int</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">excluded_subset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Calculate all subsets if n is larger than the power set of</span>
            <span class="c1"># the extent</span>
            <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">):</span>
                <span class="n">subsets_ext</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">combinations</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsets_ext</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span> <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_extensional</span><span class="p">(</span>
                            <span class="n">intent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_ext</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">):</span>
                    <span class="n">subset_ext</span> <span class="o">=</span> <span class="n">extent</span><span class="p">[</span>
                        <span class="n">_give_random_idx</span><span class="p">(</span><span class="n">r_unique_ext</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">))]</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">subset_ext</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span>
                            <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_extensional</span><span class="p">(</span>
                            <span class="n">intent</span><span class="p">,</span> <span class="n">subset_ext</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_ext</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset_ext</span><span class="p">)</span>
            <span class="n">stab_ext</span> <span class="o">/=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">))</span>
            <span class="n">excluded_subset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Calculate all subsets if n is larger than the power set of</span>
            <span class="c1"># the extent</span>
            <span class="k">if</span> <span class="n">n_subsets</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">):</span>
                <span class="n">subsets_int</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">combinations</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsets_int</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span> <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_intensional</span><span class="p">(</span>
                            <span class="n">extent</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_int</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">):</span>
                    <span class="n">subset_int</span> <span class="o">=</span> <span class="n">intent</span><span class="p">[</span>
                        <span class="n">_give_random_idx</span><span class="p">(</span><span class="n">r_unique_int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">))]</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">subset_int</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">for</span>
                            <span class="n">se</span> <span class="ow">in</span> <span class="n">excluded_subset</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">_closure_probability_intensional</span><span class="p">(</span>
                            <span class="n">extent</span><span class="p">,</span> <span class="n">subset_int</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
                        <span class="n">stab_int</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset_int</span><span class="p">)</span>
            <span class="n">stab_int</span> <span class="o">/=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">intent</span><span class="p">))</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">stab_int</span><span class="p">,</span> <span class="n">stab_ext</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">recv_list</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">recv_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="k">def</span> <span class="nf">_closure_probability_extensional</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return True if the closure of the subset of the extent given in input is</span>
<span class="sd">    equal to the intent given in input</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intent : array</span>
<span class="sd">    Set of the attributes of the concept</span>
<span class="sd">    subset : list</span>
<span class="sd">    List of objects that form the subset of the extent to be evaluated</span>
<span class="sd">    rel_matrix: ndarray</span>
<span class="sd">    Binary matrix that specify the relation that defines the context</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    1 if (subset)&#39; == intent</span>
<span class="sd">    0 else</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># computation of the &#39; operator for the subset</span>
    <span class="n">subset_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rel_matrix</span><span class="p">[</span><span class="n">subset</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">subset_prime</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">intent</span><span class="p">)):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_closure_probability_intensional</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return True if the closure of the subset of the intent given in input is</span>
<span class="sd">    equal to the extent given in input</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    extent : list</span>
<span class="sd">    Set of the objects of the concept</span>
<span class="sd">    subset : list</span>
<span class="sd">    List of attributes that form the subset of the intent to be evaluated</span>
<span class="sd">    rel_matrix: ndarray</span>
<span class="sd">    Binary matrix that specify the relation that defines the context</span>

<span class="sd">    Returns:</span>
<span class="sd">    1 if (subset)&#39; == extent</span>
<span class="sd">    0 else</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># computation of the &#39; operator for the subset</span>
    <span class="n">subset_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">rel_matrix</span><span class="p">[:,</span> <span class="n">subset</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">subset_prime</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">extent</span><span class="p">)):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_give_random_idx</span><span class="p">(</span><span class="n">r_unique</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; asd &quot;&quot;&quot;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n</span><span class="p">,</span>
                          <span class="n">size</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">high</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
    <span class="n">r_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_tuple</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_unique</span><span class="p">:</span>
        <span class="n">r_unique</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r_tuple</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_give_random_idx</span><span class="p">(</span><span class="n">r_unique</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>


<div class="viewcode-block" id="pattern_set_reduction"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.pattern_set_reduction">[docs]</a><span class="k">def</span> <span class="nf">pattern_set_reduction</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">excluded</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_spikes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_occ</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes a list concepts and performs  pattern set reduction (PSR).</span>
<span class="sd">    Same as psr(), but compares each concept A in concepts_psf to each other</span>
<span class="sd">    one which overlaps with A.</span>

<span class="sd">    PSR determines which patterns in concepts_psf are statistically significant</span>
<span class="sd">    given any other pattern, on the basis of the pattern size and</span>
<span class="sd">    occurrence count (&quot;support&quot;). Only significant patterns are retained.</span>
<span class="sd">    The significance of a pattern A is evaluated through its signature</span>
<span class="sd">    (|A|,c_A), where |A| is the size and c_A the support of A, by either of:</span>
<span class="sd">    * subset filtering: any pattern B is discarded if *cfis* contains a</span>
<span class="sd">      superset A of B such that (z_B, c_B-c_A+*h*) \in *excluded*</span>
<span class="sd">    * superset filtering: any pattern A is discarded if *cfis* contains a</span>
<span class="sd">      subset B of A such that (z_A-z_B+*k*, c_A) \in  *excluded*</span>
<span class="sd">    * covered-spikes criterion: for any two patterns A, B with A \subset B, B</span>
<span class="sd">      is discarded if (z_B-l)*c_B &lt;= c_A*(z_A-*l*), A is discarded otherwise.</span>
<span class="sd">    * combined filtering: combines the three procedures above</span>
<span class="sd">    takes a list concepts (see output psf function) and performs</span>
<span class="sd">    combined filtering based on the signature (z, c) of each pattern, where</span>
<span class="sd">    z is the pattern size and c the pattern support.</span>

<span class="sd">    For any two patterns A and B in concepts_psf such that B \subset A, check:</span>
<span class="sd">    1) (z_B, c_B-c_A+*h*) \in *excluded*, and</span>
<span class="sd">    2) (z_A-z_B+*k*, c_A) \in *excluded*.</span>
<span class="sd">    Then:</span>
<span class="sd">    * if 1) and not 2): discard B</span>
<span class="sd">    * if 2) and not 1): discard A</span>
<span class="sd">    * if 1) and 2): discard B if c_B*(z_B-*l*) &lt;= c_A*(z_A-*l*), A otherwise;</span>
<span class="sd">    * if neither 1) nor 2): keep both patterns.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    concept_psf: list</span>
<span class="sd">        List of concepts, each consisting in its intent and extent</span>
<span class="sd">    excluded: list</span>
<span class="sd">        A list of non-significant pattern signatures (z, c) (see above).</span>
<span class="sd">    h: int</span>
<span class="sd">        Correction parameter for subset filtering (see above).</span>
<span class="sd">        Defaults: 0</span>
<span class="sd">    k: int</span>
<span class="sd">        Correction parameter for superset filtering (see above).</span>
<span class="sd">        Default: 0</span>
<span class="sd">    l int ]</span>
<span class="sd">        Correction parameter for covered-spikes criterion (see above).</span>
<span class="sd">        Default: 0</span>
<span class="sd">    min_size: int</span>
<span class="sd">        Minimum pattern size.</span>
<span class="sd">        Default: 2</span>
<span class="sd">    min_supp: int</span>
<span class="sd">        Minimum pattern support.</span>
<span class="sd">        Default: 2</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">      returns a tuple containing the elements of the input argument</span>
<span class="sd">      that are significant according to combined filtering.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">conc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Extracting from the extent and intent the spike and window times</span>
    <span class="k">for</span> <span class="n">concept</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">:</span>
        <span class="n">intent</span> <span class="o">=</span> <span class="n">concept</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">concept</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">st</span> <span class="o">%</span> <span class="n">winlen</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">intent</span><span class="p">])</span>
        <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">intent</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">extent</span><span class="p">)))</span>

    <span class="c1"># by default, select all elements in conc to be returned in the output</span>
    <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">conc</span><span class="p">]</span>

    <span class="c1"># scan all conc and their subsets</span>
    <span class="k">for</span> <span class="n">id1</span><span class="p">,</span> <span class="p">(</span><span class="n">conc1</span><span class="p">,</span> <span class="n">s_times1</span><span class="p">,</span> <span class="n">winds1</span><span class="p">,</span> <span class="n">count1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conc</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">id2</span><span class="p">,</span> <span class="p">(</span><span class="n">conc2</span><span class="p">,</span> <span class="n">s_times2</span><span class="p">,</span> <span class="n">winds2</span><span class="p">,</span> <span class="n">count2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">id1</span> <span class="o">==</span> <span class="n">id2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Collecting all the possible distances between the windows</span>
            <span class="c1"># of the two concepts</span>
            <span class="n">time_diff_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">w2</span> <span class="o">-</span> <span class="n">w1</span> <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">winds2</span> <span class="k">for</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">winds1</span><span class="p">])</span>
            <span class="n">sorted_time_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">time_diff_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_diff_all</span><span class="p">))])</span>
            <span class="c1"># Rescaling the spike times to realign to real time</span>
            <span class="k">for</span> <span class="n">time_diff</span> <span class="ow">in</span> <span class="n">sorted_time_diff</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sorted_time_diff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">winlen</span><span class="p">]:</span>
                <span class="n">conc1_new</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">t_old</span> <span class="o">-</span> <span class="n">time_diff</span> <span class="k">for</span> <span class="n">t_old</span> <span class="ow">in</span> <span class="n">conc1</span><span class="p">]</span>
                <span class="n">winds1_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">w_old</span> <span class="o">-</span> <span class="n">time_diff</span> <span class="k">for</span> <span class="n">w_old</span> <span class="ow">in</span> <span class="n">winds1</span><span class="p">]</span>
                <span class="c1"># if conc1 is  of conc2 are disjointed or they have both been</span>
                <span class="c1"># already de-selected, skip the step</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">conc2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">id1</span> <span class="o">!=</span> <span class="n">id2</span> <span class="ow">and</span> <span class="n">selected</span><span class="p">[</span>
                        <span class="n">id1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]:</span>
                    <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">conc2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">])</span> <span class="ow">or</span> <span class="n">id1</span> <span class="o">==</span> <span class="n">id2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Test the case con1 is a superset of con2</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">conc2</span><span class="p">):</span>
                    <span class="c1"># Determine whether the subset (conc2) should be rejected</span>
                    <span class="c1"># according to the test for excess occurrences</span>
                    <span class="n">supp_diff</span> <span class="o">=</span> <span class="n">count2</span> <span class="o">-</span> <span class="n">count1</span> <span class="o">+</span> <span class="n">h</span>
                    <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc2</span><span class="p">)</span>
                    <span class="n">size_diff</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">-</span> <span class="n">size2</span> <span class="o">+</span> <span class="n">k</span>
                    <span class="n">reject_sub</span> <span class="o">=</span> <span class="p">(</span><span class="n">size2</span><span class="p">,</span> <span class="n">supp_diff</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excluded</span> \
                        <span class="ow">or</span> <span class="n">supp_diff</span> <span class="o">&lt;</span> <span class="n">min_occ</span>

                    <span class="c1"># Determine whether the superset (conc1_new) should be</span>
                    <span class="c1"># rejected according to the test for excess items</span>
                    <span class="n">reject_sup</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_diff</span><span class="p">,</span> <span class="n">count1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excluded</span> \
                        <span class="ow">or</span> <span class="n">size_diff</span> <span class="o">&lt;</span> <span class="n">min_spikes</span>
                    <span class="c1"># Reject the superset and/or the subset accordingly:</span>
                    <span class="k">if</span> <span class="n">reject_sub</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_sup</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_sup</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_sub</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_sub</span> <span class="ow">and</span> <span class="n">reject_sup</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">size1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count1</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">size2</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count2</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both sets are significant given the other, keep both</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">conc2</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">):</span>
                    <span class="c1"># Determine whether the subset (conc2) should be rejected</span>
                    <span class="c1"># according to the test for excess occurrences</span>
                    <span class="n">supp_diff</span> <span class="o">=</span> <span class="n">count1</span> <span class="o">-</span> <span class="n">count2</span> <span class="o">+</span> <span class="n">h</span>
                    <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc2</span><span class="p">)</span>
                    <span class="n">size_diff</span> <span class="o">=</span> <span class="n">size2</span> <span class="o">-</span> <span class="n">size1</span> <span class="o">+</span> <span class="n">k</span>
                    <span class="n">reject_sub</span> <span class="o">=</span> <span class="p">(</span><span class="n">size2</span><span class="p">,</span> <span class="n">supp_diff</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excluded</span> \
                        <span class="ow">or</span> <span class="n">supp_diff</span> <span class="o">&lt;</span> <span class="n">min_occ</span>

                    <span class="c1"># Determine whether the superset (conc1_new) should be</span>
                    <span class="c1"># rejected according to the test for excess items</span>
                    <span class="n">reject_sup</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_diff</span><span class="p">,</span> <span class="n">count1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excluded</span> \
                        <span class="ow">or</span> <span class="n">size_diff</span> <span class="o">&lt;</span> <span class="n">min_spikes</span>
                    <span class="c1"># Reject the superset and/or the subset accordingly:</span>
                    <span class="k">if</span> <span class="n">reject_sub</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_sup</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_sup</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_sub</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_sub</span> <span class="ow">and</span> <span class="n">reject_sup</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">size1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count1</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">size2</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count2</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both sets are significant given the other, keep both</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc2</span><span class="p">)</span>
                    <span class="n">inter_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">conc1_new</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">conc2</span><span class="p">))</span>
                    <span class="n">reject_1</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">size1</span> <span class="o">-</span> <span class="n">inter_size</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span>
                        <span class="n">count1</span><span class="p">)</span> <span class="ow">in</span> \
                        <span class="n">excluded</span> <span class="ow">or</span> <span class="n">size1</span> <span class="o">-</span> <span class="n">inter_size</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">min_spikes</span>
                    <span class="n">reject_2</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">size2</span> <span class="o">-</span> <span class="n">inter_size</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">count2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">excluded</span> <span class="ow">or</span> \
                        <span class="n">size2</span> <span class="o">-</span> <span class="n">inter_size</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">min_spikes</span>
                    <span class="c1"># Reject accordingly:</span>
                    <span class="k">if</span> <span class="n">reject_2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_1</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reject_2</span><span class="p">:</span>
                        <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">reject_1</span> <span class="ow">and</span> <span class="n">reject_2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">size1</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count1</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">size2</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">count2</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">selected</span><span class="p">[</span><span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="c1"># if both sets are significant given the other, keep both</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>

    <span class="c1"># Return the selected concepts</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">concepts</span><span class="p">)</span> <span class="k">if</span> <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span></div>


<div class="viewcode-block" id="concept_output_to_patterns"><a class="viewcode-back" href="../../source/elephant.spade.html#elephant.spade.concept_output_to_patterns">[docs]</a><span class="k">def</span> <span class="nf">concept_output_to_patterns</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">winlen</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span> <span class="n">pvalue_spectrum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construction of dictionaries containing all the information about a pattern</span>
<span class="sd">    starting from a list of concepts and its associated pvalue_spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    concepts: tuple</span>
<span class="sd">        Each element of the tuple correspond to a pattern and it is itself a</span>
<span class="sd">        tuple consisting of:</span>
<span class="sd">            ((spikes in the pattern), (occurrences of the patterns))</span>
<span class="sd">    winlen: int</span>
<span class="sd">        Length (in bins) of the sliding window used for the analysis</span>
<span class="sd">    pvalue_spectrum: None or tuple</span>
<span class="sd">        Contains a tuple of signatures and the corresponding p-value. If equal</span>
<span class="sd">        to None all the pvalues are set to -1</span>
<span class="sd">    t_start: Quantity </span>
<span class="sd">        t_start of the analyzed spike trains</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    output: list</span>
<span class="sd">        List of dictionaries. Each dictionary correspond to a patterns and</span>
<span class="sd">        has the following entries:</span>
<span class="sd">            [&#39;neurons&#39;] array containing the idx of the neurons of the pattern</span>
<span class="sd">            [&#39;lags&#39;] array containing the lags (integers corresponding to the</span>
<span class="sd">                number of bins) between the spikes of the patterns. The first</span>
<span class="sd">                lag is always assumed to be 0 and correspond to the first</span>
<span class="sd">                spike.</span>
<span class="sd">            [&#39;times&#39;] array contianing the times (integers corresponding to the</span>
<span class="sd">                bin idx) of the occurrences of the patterns.</span>
<span class="sd">            [&#39;signature&#39;] tuple containing two integers</span>
<span class="sd">                (number of spikes of the patterns,</span>
<span class="sd">                number of occurrences of the pattern)</span>
<span class="sd">            [&#39;pvalue&#39;] the pvalue corresponding to the pattern. If n_surr==0</span>
<span class="sd">                the pvalues are set to -1.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pvalue_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Creating a dictionary for the pvalue spectrum</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">pvalue_spectrum</span><span class="p">:</span>
        <span class="n">pvalue_dict</span><span class="p">[(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Initializing list containing all the patterns</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">conc</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">:</span>
        <span class="c1"># Vocabulary for each of the patterns</span>
        <span class="n">output_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Bins relative to the sliding window in which the spikes of patt fall</span>
        <span class="n">bin_ids_unsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="n">winlen</span>
        <span class="n">bin_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="n">winlen</span><span class="p">)</span>
        <span class="c1"># id of the neurons forming the pattern</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;neurons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">bin_ids_unsort</span><span class="p">)]</span> <span class="o">//</span> <span class="n">winlen</span><span class="p">)</span>
        <span class="c1"># Lags (in binsizes units) of the pattern</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;lags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_ids</span> <span class="o">-</span> <span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">binsize</span>
        <span class="c1"># Times (in binsize units) in which the pattern occurres</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">binsize</span> <span class="o">+</span> <span class="n">bin_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
            <span class="n">binsize</span> <span class="o">+</span> <span class="n">t_start</span>
        <span class="c1"># Signature (size, n occ) of the pattern</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;signature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># If None is given in input to the pval spectrum the pvalue</span>
        <span class="c1"># is set to -1 (pvalue spectrum not available)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvalue_spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;pvalue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># p-value assigned to the pattern from the pvalue spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;pvalue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvalue_dict</span><span class="p">[(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="s1">&#39;pvalue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># pattern dictionary appended to the output</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2018, Elephant authors and contributors.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.<br/>
    </p>
  </div>
</footer>
  </body>
</html>